{
  "version": "2.0",
  "last_updated": "2025-07-24",
  "description": "구조화된 개발 가이드라인 데이터베이스 - AI 기반 자동 분석 및 제안 시스템용",
  "categories": {
    "architecture": "아키텍처 및 설계 원칙",
    "performance": "성능 최적화",
    "security": "보안 관련",
    "testing": "테스트 전략",
    "code_quality": "코드 품질",
    "database": "데이터베이스 설계",
    "api_design": "API 설계"
  },
  "severity_levels": {
    "critical": { "score": 10, "description": "즉시 수정 필요 - 시스템 안정성에 직접적 영향" },
    "high": { "score": 8, "description": "높은 우선순위 - 성능이나 보안에 영향" },
    "medium": { "score": 5, "description": "중간 우선순위 - 코드 품질 개선" },
    "low": { "score": 2, "description": "낮은 우선순위 - 코드 일관성 개선" }
  },
  "rules": [
    {
      "id": "ARCH_001",
      "category": "architecture",
      "severity": "critical",
      "title": "단일 책임 원칙(SRP) 위반",
      "description": "하나의 클래스나 메서드가 너무 많은 책임을 가지고 있습니다.",
      "pattern_to_detect": {
        "file_patterns": ["**/*Service.java", "**/*Controller.java"],
        "code_patterns": [
          "class.*Service.*\\{[\\s\\S]*?public.*\\{[\\s\\S]*?public.*\\{[\\s\\S]*?public.*\\{[\\s\\S]*?public.*\\{",
          "class.*Controller.*\\{[\\s\\S]*?@PostMapping[\\s\\S]*?@GetMapping[\\s\\S]*?@PutMapping[\\s\\S]*?@DeleteMapping"
        ],
        "ast_checks": [
          {
            "type": "method_count_in_class",
            "threshold": 10,
            "message": "클래스의 public 메서드가 10개를 초과합니다."
          },
          {
            "type": "class_line_count",
            "threshold": 200,
            "message": "클래스의 줄 수가 200줄을 초과합니다."
          }
        ]
      },
      "good_code_example": "// ✅ 좋은 예: 책임이 명확히 분리된 서비스\n@Service\npublic class UserService {\n    public User findById(Long id) { /* 사용자 조회 */ }\n    public User save(User user) { /* 사용자 저장 */ }\n}\n\n@Service\npublic class UserNotificationService {\n    public void sendWelcomeEmail(User user) { /* 알림 전송 */ }\n}",
      "bad_code_example": "// ❌ 나쁜 예: 너무 많은 책임을 가진 서비스\n@Service\npublic class UserService {\n    public User findById(Long id) { /* 사용자 조회 */ }\n    public User save(User user) { /* 사용자 저장 */ }\n    public void sendEmail(User user) { /* 이메일 전송 */ }\n    public void generateReport() { /* 리포트 생성 */ }\n    public void processPayment() { /* 결제 처리 */ }\n}",
      "solution": {
        "steps": [
          "클래스의 책임을 분석하여 관련성이 낮은 메서드들을 식별합니다.",
          "새로운 전용 서비스 클래스를 생성합니다.",
          "관련 메서드들을 새 클래스로 이동합니다.",
          "의존성 주입을 통해 서비스 간 협력을 구성합니다."
        ],
        "estimated_time": "30-60분",
        "difficulty": "medium"
      },
      "related_rules": ["ARCH_002", "CODE_001"],
      "success_metrics": {
        "class_line_count_reduction": "30%",
        "method_count_per_class": "< 8",
        "cyclomatic_complexity": "< 10"
      }
    },
    {
      "id": "PERF_001",
      "category": "performance",
      "severity": "high",
      "title": "N+1 쿼리 문제",
      "description": "JPA 관계 매핑에서 N+1 쿼리 문제가 발생할 가능성이 높습니다.",
      "pattern_to_detect": {
        "file_patterns": ["**/*Repository.java", "**/*Service.java"],
        "code_patterns": [
          "@OneToMany.*fetchType\\s*=\\s*FetchType\\.LAZY",
          "@ManyToOne.*fetchType\\s*=\\s*FetchType\\.LAZY",
          "findAll\\(\\).*\\.get.*\\("
        ],
        "ast_checks": [
          {
            "type": "missing_entity_graph",
            "pattern": "@Query.*JOIN FETCH",
            "message": "@EntityGraph 어노테이션이 누락되었을 가능성이 있습니다."
          }
        ]
      },
      "good_code_example": "// ✅ 좋은 예: @EntityGraph로 N+1 문제 해결\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    @EntityGraph(attributePaths = {\"posts\", \"comments\"})\n    @Query(\"SELECT u FROM User u WHERE u.active = true\")\n    List<User> findActiveUsersWithDetails();\n}",
      "bad_code_example": "// ❌ 나쁜 예: N+1 쿼리 발생 가능\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    List<User> findByActiveTrue(); // 연관 엔티티 접근 시 추가 쿼리 발생\n}",
      "solution": {
        "steps": [
          "@EntityGraph 어노테이션을 추가합니다.",
          "attributePaths에 필요한 연관 엔티티를 명시합니다.",
          "쿼리 실행 시 실제 SQL을 확인하여 JOIN이 적용되었는지 검증합니다."
        ],
        "estimated_time": "15-30분",
        "difficulty": "easy"
      },
      "related_rules": ["PERF_002", "DB_001"],
      "success_metrics": {
        "query_count_reduction": "80%",
        "response_time_improvement": "50%"
      }
    },
    {
      "id": "SEC_001",
      "category": "security",
      "severity": "critical",
      "title": "민감 정보 로깅",
      "description": "비밀번호, 토큰 등 민감한 정보가 로그에 노출될 위험이 있습니다.",
      "pattern_to_detect": {
        "file_patterns": ["**/*.java"],
        "code_patterns": [
          "log\\..*password",
          "log\\..*token",
          "log\\..*secret",
          "System\\.out\\.println.*password",
          "logger\\..*jwt"
        ],
        "ast_checks": [
          {
            "type": "sensitive_data_logging",
            "sensitive_fields": ["password", "token", "secret", "jwt", "apiKey"],
            "message": "민감한 정보가 로그에 포함될 수 있습니다."
          }
        ]
      },
      "good_code_example": "// ✅ 좋은 예: 민감 정보 마스킹\nlog.info(\"User login attempt: username={}, success={}\", \n    user.getUsername(), loginSuccess);\n\n// 비밀번호는 로깅하지 않음",
      "bad_code_example": "// ❌ 나쁨 예: 민감 정보 직접 로깅\nlog.info(\"Login request: {}\", loginRequest); // password 포함된 객체\nlog.debug(\"JWT token: {}\", jwtToken); // 토큰 직접 노출",
      "solution": {
        "steps": [
          "민감한 필드를 가진 DTO에 @JsonIgnore 또는 @ToString.Exclude 추가",
          "로깅 시 필요한 정보만 명시적으로 추출",
          "민감한 정보는 마스킹 처리 후 로깅"
        ],
        "estimated_time": "15-30분",
        "difficulty": "easy"
      },
      "related_rules": ["SEC_002", "CODE_003"],
      "success_metrics": {
        "sensitive_data_exposure": "0%",
        "security_scan_pass": "100%"
      }
    },
    {
      "id": "TEST_001",
      "category": "testing",
      "severity": "high",
      "title": "Mock 과다 의존",
      "description": "통합 테스트 대신 Mock 객체에 과도하게 의존하여 실제 상호작용을 검증하지 못합니다.",
      "pattern_to_detect": {
        "file_patterns": ["**/*Test.java"],
        "code_patterns": [
          "@Mock.*Repository",
          "@Mock.*Service",
          "Mockito\\.when.*Repository",
          "@ExtendWith\\(MockitoExtension\\.class\\).*@Mock.*@Mock.*@Mock"
        ],
        "ast_checks": [
          {
            "type": "mock_to_real_ratio",
            "threshold": 0.7,
            "message": "Mock 객체 사용 비율이 70%를 초과합니다."
          }
        ]
      },
      "good_code_example": "// ✅ 좋은 예: 통합 테스트\n@DataJpaTest\n@ActiveProfiles(\"test\")\nclass UserServiceIntegrationTest {\n    @Autowired\n    private TestEntityManager entityManager;\n    \n    @Test\n    void testCreateUser() {\n        // 실제 데이터베이스와 상호작용\n    }\n}",
      "bad_code_example": "// ❌ 나쁜 예: Mock 과다 사용\n@ExtendWith(MockitoExtension.class)\nclass UserServiceTest {\n    @Mock UserRepository userRepository;\n    @Mock EmailService emailService;\n    @Mock AuditService auditService;\n    // 실제 상호작용 검증 불가\n}",
      "solution": {
        "steps": [
          "@DataJpaTest 또는 @SpringBootTest 사용",
          "TestEntityManager로 테스트 데이터 준비",
          "외부 시스템만 Mock 처리",
          "실제 데이터베이스 트랜잭션 검증"
        ],
        "estimated_time": "45-90분",
        "difficulty": "medium"
      },
      "related_rules": ["TEST_002", "ARCH_003"],
      "success_metrics": {
        "integration_test_ratio": "> 60%",
        "test_coverage": "> 85%",
        "test_reliability": "> 95%"
      }
    }
  ],
  "auto_fix_templates": {
    "ARCH_001": {
      "template": "// 자동 생성된 서비스 분리 제안\n@Service\npublic class {{newServiceName}} {\n    {{extractedMethods}}\n}",
      "variables": {
        "newServiceName": "분리될 서비스명",
        "extractedMethods": "이동할 메서드들"
      }
    },
    "PERF_001": {
      "template": "@EntityGraph(attributePaths = {{{attributePaths}}})\n@Query(\"{{originalQuery}}\")\n{{originalMethod}}",
      "variables": {
        "attributePaths": "로딩할 연관 엔티티 경로",
        "originalQuery": "기존 쿼리",
        "originalMethod": "기존 메서드 시그니처"
      }
    }
  },
  "learning_data": {
    "successful_fixes": [],
    "failed_fixes": [],
    "performance_metrics": {
      "total_suggestions": 0,
      "accepted_suggestions": 0,
      "success_rate": 0.0,
      "average_fix_time": 0
    }
  }
}