This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: build/**, node_modules/**, *.jar
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.github/
  workflows/
    auto-commit.yml
docs/
  phases/
    phase-1.md
    phase-2.md
    phase-3.md
    phase-4.md
    phase-5.md
    phase-6.md
    phase-overview.md
    돌봄지수-체크리스트-매칭서비스.md
  CLAUDE(전체계획).md
  DEVELOPMENT_PLAN.md
frontend/
  src/
    components/
      coordinator/
        CoordinatorCard.tsx
        MatchingPreferencePanel.tsx
        MatchingStatsDashboard.tsx
      ui/
        Button.tsx
        Card.tsx
        ProgressBar.tsx
        RadioGroup.tsx
    features/
      coordinator/
        CoordinatorMatchingWizard.tsx
      health/
        steps/
          AdditionalInfoStep.tsx
          AdlCommunicationStep.tsx
          AdlEatingStep.tsx
          AdlMobilityStep.tsx
          AdlToiletStep.tsx
          BasicInfoStep.tsx
          LtciGradeStep.tsx
          ReviewStep.tsx
        HealthAssessmentWizard.tsx
    services/
      coordinatorApi.ts
      healthApi.ts
    stores/
      healthAssessmentStore.ts
    types/
      health.ts
    App.css
    App.tsx
    main.tsx
    vite-env.d.ts
  index.html
  package.json
  postcss.config.js
  tailwind.config.js
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
gradle/
  wrapper/
    gradle-wrapper.properties
src/
  main/
    java/
      com/
        globalcarelink/
          auth/
            dto/
              LoginRequest.java
              MemberRegisterRequest.java
              MemberResponse.java
              MemberUpdateRequest.java
              TokenResponse.java
            AuthController.java
            JwtAuthenticationFilter.java
            JwtTokenProvider.java
            Member.java
            MemberController.java
            MemberRepository.java
            MemberRole.java
            MemberService.java
          common/
            config/
              AsyncConfig.java
              CacheConfig.java
              JpaConfig.java
              LoggingAspect.java
              LoggingFilter.java
              SecurityConfig.java
            entity/
              BaseEntity.java
            exception/
              CustomException.java
              GlobalExceptionHandler.java
            util/
              DateUtil.java
              SecurityUtil.java
              ValidationUtil.java
            HealthController.java
          coordinator/
            CoordinatorCareSettings.java
            CoordinatorCareSettingsRepository.java
            CoordinatorCareSettingsService.java
            CoordinatorLanguageSkill.java
            CoordinatorLanguageSkillRepository.java
            CoordinatorMatch.java
            CoordinatorMatchingController.java
            CoordinatorMatchingStatistics.java
            CoordinatorWorkloadOptimizer.java
            LanguageMatchingService.java
            MatchingExplanationGenerator.java
            MatchingPreference.java
            MatchingSimulationRequest.java
            MatchingSimulationResult.java
            OptimizedCoordinatorMatchingService.java
          health/
            dto/
              HealthAssessmentCreateRequest.java
              HealthAssessmentStatistics.java
              HealthAssessmentUpdateRequest.java
            CareGradeCalculator.java
            HealthAssessment.java
            HealthAssessmentController.java
            HealthAssessmentRepository.java
            HealthAssessmentService.java
          profile/
            dto/
              DomesticProfileRequest.java
              DomesticProfileResponse.java
              OverseasProfileRequest.java
              OverseasProfileResponse.java
            DomesticProfile.java
            DomesticProfileRepository.java
            OverseasProfile.java
            OverseasProfileRepository.java
            ProfileController.java
            ProfileService.java
          GlobalCareLinkApplication.java
    resources/
      application-test.yml
      application.yml
      logback-spring.xml
  test/
    java/
      com/
        globalcarelink/
          auth/
            AuthControllerTest.java
            MemberRepositoryTest.java
            MemberServiceTest.java
          coordinator/
            CoordinatorMatchingControllerTest.java
            CoordinatorMatchingServiceIntegrationTest.java
          e2e/
            HealthAssessmentToCoordinatorMatchingE2ETest.java
          health/
            HealthAssessmentControllerIntegrationTest.java
          GlobalCareLinkApplicationTest.java
.env.example
.gitignore
build.gradle.kts
CLAUDE.md
gradlew
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/phases/돌봄지수-체크리스트-매칭서비스.md">
# 돌봄지수 체크리스트 - 매칭서비스 활용 가이드

## 📋 개요
KB라이프생명 요양간병 컨설팅 서비스의 돌봄지수 체크 로직을 분석하여, 우리 LightCare 매칭서비스에 활용할 체크리스트를 작성합니다.

## 🎯 목적
- 요양시설과 이용자의 정확한 매칭을 위한 돌봄 필요도 평가
- 표준화된 평가 기준을 통한 객관적 판정
- 단계별 질문을 통한 사용자 친화적 인터페이스 제공

## 📊 평가 항목 및 단계

### 1. 기본 정보
- **성별**: 남자 / 여자
- **출생년도**: 4자리 연도 입력 (유효성 검증: 현재년도-150 ~ 현재년도)

### 2. 일상생활 기본동작 평가 (ADL)

#### 2.1 걷기 활동 능력
- **1단계 (양호)**: 혼자서 가능해요
- **2단계 (보통)**: 부분적인 도움이 필요해요 (타인의 부축, 지팡이 이용 등)
- **3단계 (중증)**: 혼자서는 보행이 어려워요 (휠체어 사용 등)

#### 2.2 식사 활동 능력
- **1단계 (양호)**: 혼자서 가능해요
- **2단계 (보통)**: 부분적인 도움이 필요해요 (반찬 집기, 자르기 등 일부 도움)
- **3단계 (중증)**: 완전한 도움이 필요해요 (음식을 떠 먹여줌)

#### 2.3 배변 활동 능력
- **1단계 (양호)**: 혼자서 화장실을 이용할 수 있어요
- **2단계 (보통)**: 화장실 이용 시 부분적인 도움이 필요해요
- **3단계 (중증)**: 완전한 도움이 필요해요 (간이변기, 기저귀 착용 등)

#### 2.4 의사소통 능력
- **1단계 (양호)**: 정상적으로 가능해요
- **2단계 (보통)**: 때때로 어려워요 (화장실 이용의사 표현 가능)
- **3단계 (중증)**: 소통이 어려워요 (화장실 이용의사 표현 잘 못함)

### 3. 식사 형태
- **1단계 (일반)**: 일반식
- **2단계 (보조)**: 다진식/갈은식
- **3단계 (특수)**: 경관식(튜브 주입)

### 4. 장기요양 판정등급
- **1등급**: 가장 중증
- **2등급**: 중증
- **3등급**: 중등도
- **4등급**: 경증
- **5등급**: 경미
- **인지지원등급**: 치매특화
- **잘 모르겠음**: 미확인
- **없음**: 해당없음

### 5. 특수 상황 평가 (치명적 상태)
- **1단계**: 6개월 이하의 기대수명 상태
- **2단계**: 질병이 회복하기 어려운 상황으로 수명이 얼마 남지 않음
- **3단계**: 완전히 타인 의존적인 상태이나 사망위험이 높지 않음
- **4단계**: 해당사항 없음

### 6. 질환 분류
- **치매**: 인지기능 저하
- **파킨슨**: 운동장애
- **뇌혈관질환**: 뇌졸중 등
- **잘 모르겠음**: 미확인

## 🔢 등급 산정 로직

### 최종 등급 (1-9단계)
1. **1등급 (최경증)**: 건강한 성인
2. **2등급**: 경미한 도움 필요 (중년층)
3. **3등급**: 경미한 도움 필요 (고령층)
4. **4등급**: 부분 도움 필요
5. **5등급**: 일반적 도움 필요
6. **6등급**: 상당한 도움 필요
7. **7등급**: 중증 상태
8. **8등급**: 생명위험 중등도
9. **9등급**: 생명위험 고도

### 등급 산정 규칙

#### 특수 상황 우선 적용
```javascript
// 치명적 상태에 따른 등급
if (치명적상태 === "1") return 9; // 6개월 이하 기대수명
if (치명적상태 === "2") return 8; // 회복 어려운 상황
if (치명적상태 === "3") return 7; // 완전 의존적 상태
```

#### 중증 지표 우선 체크
```javascript
// 배변활동 완전도움 또는 경관식 → 7등급
if (배변활동 === "3" || 식사형태 === "3") return 7;
```

#### 장기요양등급 기반 판정
- **1-3등급**: 공식등급에 따른 중증도 반영
- **4-6등급**: 일상생활능력과 조합하여 판정
- **미확인/없음**: 나이와 기능상태로 판정

## 🏥 매칭서비스 활용 방안

### 1. 시설 등급별 분류
- **1-3등급**: 재가서비스, 경증 시설
- **4-5등급**: 일반 요양원, 데이케어
- **6-7등급**: 전문 요양원, 간병서비스
- **8-9등급**: 호스피스, 중증 전문시설

### 2. 특화 서비스 매칭
- **치매**: 치매전문시설, 인지재활 프로그램
- **파킨슨**: 재활치료 전문시설
- **뇌혈관질환**: 재활병원 연계 시설

### 3. 경고 알림 시스템
```javascript
// 공식등급과 실제상태 불일치 시 경고
if (장기요양등급 <= 3 && 모든일상생활능력 === 1) {
    alert("등급 재평가 권장");
}
```

## 🛠️ 구현 고려사항

### 1. 사용자 인터페이스
- 단계별 진행 (GSAP 애니메이션 활용)
- 이전/다음 버튼으로 단계 이동
- 필수 입력 검증
- 실시간 피드백

### 2. 데이터 저장 구조
```sql
CREATE TABLE care_assessment (
    id BIGINT PRIMARY KEY,
    member_id BIGINT,
    birth_year INT,
    gender VARCHAR(1),
    walking_ability INT,     -- 걷기능력 1-3
    eating_ability INT,      -- 식사능력 1-3  
    toilet_ability INT,      -- 배변능력 1-3
    communication INT,       -- 의사소통 1-3
    meal_type INT,          -- 식사형태 1-3
    ltc_grade INT,          -- 장기요양등급
    critical_status INT,     -- 치명적상태
    disease_type INT,       -- 질환명
    calculated_grade INT,   -- 산출등급 1-9
    alert_flag VARCHAR(1),  -- 경고여부 Y/N
    created_at TIMESTAMP
);
```

### 3. API 설계
```java
@RestController
public class CareAssessmentController {
    
    @PostMapping("/api/care/assessment")
    public ResponseEntity<CareGradeResult> calculateGrade(@RequestBody CareAssessmentDTO dto) {
        // 등급 계산 로직
        int grade = careService.calculateGrade(dto);
        boolean alertFlag = careService.checkAlertCondition(dto);
        
        return ResponseEntity.ok(new CareGradeResult(grade, alertFlag));
    }
}
```

## 📈 품질 개선 방안

### 1. 검증 로직 강화
- 입력값 유효성 검사
- 논리적 일관성 검증
- 이상값 탐지

### 2. 개인화 추천
- 과거 평가 이력 반영
- 지역별 시설 현황 연계
- 가족 선호도 고려

### 3. 데이터 분석 활용
- 평가 결과 통계 분석
- 매칭 성공률 추적
- 서비스 개선 피드백

## 🔒 보안 및 개인정보보호
- 민감한 건강정보 암호화 저장
- 접근 권한 세분화
- 데이터 보존 기간 관리
- 개인정보 동의 절차

---

*이 체크리스트는 KB라이프생명의 돌봄지수 체크 시스템을 참고하여 LightCare 매칭서비스에 최적화하여 작성되었습니다.*
</file>

<file path="docs/CLAUDE(전체계획).md">
# CLAUDE.md

이 문서는 이 저장소에서 Claude Code (claude.ai/code)가 코드를 다룰 때 참고할 가이드입니다.

---

## 📌 프로젝트 개요

이 프로젝트는 한국 팀원 4명이 개발하는 \*\*글로벌 요양원 구인구직 웹사이트 "라이트케어(LightCare)"\*\*입니다. 이 플랫폼은 요양 시설과 요양업계 구직자를 연결해주는 서비스에서 시작하여, **재외동포 대상 글로벌 요양 서비스**로 확장되고 있습니다.

**⚠️ 중요: 이 프로젝트는 JDK 21 + Spring Boot 3.3.5 기반의 새로운 프로젝트로 재구성되었습니다. 기존 레거시 코드는 참고용으로만 활용하며, 모든 새로운 개발은 최신 기술 스택 기반으로 진행합니다.**

---

## 🛠 기술 스택 (최신화)

### 백엔드 (Modern Java Stack - 완전 무료)
* **언어**: Java 21 LTS (Virtual Threads, Pattern Matching)
* **프레임워크**: Spring Boot 3.3.5 
* **ORM**: Spring Data JPA + Hibernate 6.x
* **보안**: Spring Security 6.x + JWT + OAuth2
* **데이터베이스**: SQLite (자본금 0원 고려)
* **캐시**: Caffeine (메모리 캐시, 무료)
* **빌드**: Gradle 8.x + Kotlin DSL

### 프론트엔드 (Modern React Stack)  
* **언어**: TypeScript 5.x (타입 안정성)
* **프레임워크**: React 18 + Vite 5.x
* **상태관리**: Zustand (단순하고 현대적)
* **UI 라이브러리**: Tailwind CSS + Shadcn/ui
* **HTTP 클라이언트**: TanStack Query (React Query v5)
* **폼 관리**: React Hook Form + Zod

### 인프라 & 도구 (무료 우선)
* **실시간 통신**: WebSocket, STOMP (WebRTC는 추후)  
* **API 문서**: OpenAPI 3.0 + Swagger UI
* **테스트**: JUnit 5 + Spring Boot Test
* **CI/CD**: GitHub Actions (월 2000분 무료)
* **파일 저장**: GitHub Repository (무료 CDN)
* **이메일**: Gmail SMTP (일일 500통 무료)
* **지도**: OpenStreetMap + Leaflet.js (완전 무료), 카카오맵 (월 30만건 무료)
* **배포**: Railway/Render (무료 플랜) → GitHub Pages (프론트엔드)
* **개발 도구**: Lombok, MapStruct, Spring Boot DevTools
* **모니터링**: Spring Boot Actuator (무료)

---

## ⚙️ 멀티모듈 개발 명령어

### 빌드 및 실행 (JDK 21 기반)

```bash
# JDK 버전 확인 (21 이상이어야 함)
java -version

# 전체 프로젝트 빌드 (모든 모듈)
./gradlew build

# 특정 모듈만 빌드
./gradlew :api-module:build
./gradlew :member-module:build

# API 서버 실행 (개발 프로파일)
./gradlew :api-module:bootRun --args='--spring.profiles.active=dev'

# 프론트엔드 개발 서버 실행
cd web-module && npm run dev

# 전체 테스트 실행 (병렬 처리)
./gradlew test --parallel

# 특정 모듈 테스트
./gradlew :member-module:test

# 코드 품질 검사 (전체)
./gradlew check

# API 문서 생성 (OpenAPI)
./gradlew :api-module:generateOpenApiDocs

# 의존성 업데이트 확인
./gradlew dependencyUpdates
```

### 데이터베이스 설정 (SQLite - 무료)

```bash
# SQLite 데이터베이스 (파일 기반, 설치 불필요)
# 프로젝트 루트에 data/ 폴더 생성
mkdir data

# JPA 자동 DDL로 스키마 생성 (개발 환경)
# application.yml에서 spring.jpa.hibernate.ddl-auto: create-drop
# SQLite 파일이 자동으로 생성됨: ./data/lightcare.db
```

### 개발 서버 정보

* **백엔드**: `http://localhost:8080` (Spring Boot)
* **프론트엔드**: `http://localhost:5173` (Vite React)
* **데이터베이스**: `jdbc:sqlite:./data/lightcare.db` (파일 기반)
* **캐시**: 메모리 캐시 (Caffeine)
* **Hot Reload**: DevTools(백엔드) + Vite HMR(프론트엔드)

---

## 🧱 아키텍처 개요

### AI 주도 개발을 위한 구조 (1인 + AI 협업 최적화)

이 프로젝트는 **기존 레거시 코드의 마이그레이션 어려움** (JDK 11→21, Spring Boot 2.x→3.x 업그레이드 시 대량 컴파일 오류)을 해결하기 위해 **완전히 새로운 그린필드 프로젝트**로 시작합니다.

**⚠️ 개발 전략**:
- **AI 의존도**: 100% (주니어 레벨 팀)
- **개발 방식**: 기존 코드 포팅 대신 새로운 코드 생성
- **레거시 활용**: 비즈니스 로직 참고용으로만 활용

**기능별 패키지 구조 (단일 프로젝트 - AI 개발 최적화)**:
* **auth**: 인증 기능 (로그인, 회원가입, JWT) - Spring Security 6.x 기반
* **profile**: 프로필 관리 (국내/해외 사용자 구분)  
* **facility**: 시설 관리 (등록, 검색, 지도 연동) - OpenStreetMap + 카카오맵
* **job**: 구인구직 (공고 작성, 지원, 매칭) - AI 매칭 알고리즘 적용
* **review**: 리뷰 시스템 (평점, 후기, 추천) - 감정 분석 적용 예정
* **overseas**: 재외동포 전용 기능 (외교부 API, 화상상담) - WebRTC 기반
* **coordinator**: 코디네이터 원스톱 서비스 - 재외동포 입국부터 요양원 입주까지 전 과정 지원
* **notification**: 알림 시스템 (Gmail SMTP, WebSocket) - 무료 서비스 기반
* **common**: 공통 설정, 유틸, 예외처리 - Spring Boot 3.3.5 최적화

### 기능별 패키지 구조 (1인 개발 최적화)

```
global-care-link/
├── build.gradle.kts                   # 단일 빌드 파일 (멀티모듈 제거)
├── src/main/java/com/globalcarelink/
│   ├── auth/                          # 🔐 인증 기능 전체
│   │   ├── AuthController.java        # 로그인/회원가입 API
│   │   ├── AuthService.java           # 인증 비즈니스 로직
│   │   ├── JwtTokenProvider.java      # JWT 토큰 처리
│   │   ├── LoginRequest.java          # 로그인 요청 DTO
│   │   ├── RegisterRequest.java       # 회원가입 요청 DTO
│   │   ├── TokenResponse.java         # 토큰 응답 DTO
│   │   └── Member.java                # 기본 회원 엔티티
│   ├── profile/                       # 👤 프로필 관리 기능
│   │   ├── ProfileController.java     # 프로필 관리 API
│   │   ├── ProfileService.java        # 프로필 비즈니스 로직
│   │   ├── DomesticProfile.java       # 국내 사용자 프로필 엔티티
│   │   ├── OverseasProfile.java       # 해외 사용자 프로필 엔티티
│   │   └── ProfileRepository.java     # 프로필 데이터 접근
│   ├── facility/                      # 🏥 시설 관리 기능
│   │   ├── FacilityController.java    # 시설 관리 API
│   │   ├── FacilityService.java       # 시설 비즈니스 로직
│   │   ├── Facility.java              # 시설 엔티티
│   │   ├── FacilityRepository.java    # 시설 데이터 접근
│   │   ├── MapService.java            # 지도 서비스 (카카오/구글)
│   │   └── FacilitySearchDTO.java     # 시설 검색 DTO
│   ├── job/                           # 💼 구인구직 기능
│   │   ├── JobController.java         # 구인구직 API
│   │   ├── JobService.java            # 구인구직 비즈니스 로직
│   │   ├── JobPosting.java            # 구인공고 엔티티
│   │   ├── JobApplication.java        # 구직지원 엔티티
│   │   ├── JobRepository.java         # 구인구직 데이터 접근
│   │   └── JobMatchingService.java    # 매칭 알고리즘
│   ├── review/                        # ⭐ 리뷰 시스템
│   │   ├── ReviewController.java      # 리뷰 API
│   │   ├── ReviewService.java         # 리뷰 비즈니스 로직
│   │   ├── Review.java                # 리뷰 엔티티
│   │   └── ReviewRepository.java      # 리뷰 데이터 접근
│   ├── overseas/                      # 🌍 재외동포 전용 기능
│   │   ├── OverseasController.java    # 재외동포 서비스 API
│   │   ├── DiplomaticService.java     # 외교부 API 연동
│   │   ├── ConsultationService.java   # 화상 상담 관리
│   │   └── DiplomaticApiClient.java   # 외교부 API 클라이언트
│   ├── coordinator/                   # 🤝 코디네이터 원스톱 서비스
│   │   ├── CoordinatorController.java # 코디네이터 매칭 API
│   │   ├── CoordinatorService.java    # 원스톱 서비스 비즈니스 로직
│   │   ├── CoordinatorProfile.java    # 코디네이터 프로필 (전문분야, 언어능력)
│   │   ├── ServiceRequest.java        # 서비스 요청 엔티티 (입국~입주)
│   │   ├── ServicePlan.java           # 개인별 맞춤 서비스 계획
│   │   ├── ServiceProgress.java       # 서비스 진행 상황 추적
│   │   ├── EmergencyContact.java      # 응급상황 연락처 관리
│   │   └── ServicePayment.java        # 서비스 요금 및 정산
│   ├── notification/                  # 📧 알림 시스템
│   │   ├── EmailService.java          # 이메일 발송 서비스
│   │   ├── NotificationService.java   # 통합 알림 관리
│   │   └── NotificationTemplate.java  # 알림 템플릿 관리
│   ├── common/                        # 🔧 공통 기능
│   │   ├── config/                    # 설정 클래스
│   │   │   ├── SecurityConfig.java    # Spring Security 설정
│   │   │   ├── DatabaseConfig.java    # SQLite 설정
│   │   │   └── SwaggerConfig.java     # API 문서 설정
│   │   ├── exception/                 # 예외 처리
│   │   │   ├── GlobalExceptionHandler.java
│   │   │   └── CustomException.java
│   │   ├── util/                      # 유틸리티
│   │   │   ├── FileUtil.java          # 파일 처리 유틸
│   │   │   └── DateUtil.java          # 날짜 처리 유틸
│   │   └── entity/                    # 공통 엔티티
│   │       └── BaseEntity.java        # 기본 엔티티 (생성일, 수정일)
│   └── GlobalCareLinkApplication.java # 메인 애플리케이션 클래스
├── src/main/resources/
│   ├── application.yml                # SQLite 기반 설정
│   ├── data.sql                       # 초기 데이터
│   └── static/                        # 정적 파일
├── frontend/                          # 🎨 React 프론트엔드
│   ├── src/features/                  # 프론트엔드도 기능별 구조
│   │   ├── auth/                      # 인증 관련 React 컴포넌트
│   │   ├── facility/                  # 시설 관련 React 컴포넌트
│   │   ├── job/                       # 구인구직 관련 React 컴포넌트
│   │   └── overseas/                  # 재외동포 관련 React 컴포넌트
│   ├── package.json
│   └── vite.config.ts
└── data/                              # SQLite 데이터베이스
    └── lightcare.db                   # SQLite 파일
```

### 데이터베이스 설계

관계형 테이블 기반으로 외래키(FK)를 적절히 사용:

* **member**: 사용자 계정 및 인증 정보
* **facility**: 요양시설 정보 (위치 좌표 포함)
* **job\_posting**: 구인공고 정보
* **review**: 시설 리뷰 및 평점
* **board**: 커뮤니티/정보 게시판

### JPA 구성 (최신화)

* **ORM**: Spring Data JPA 3.x
* **엔티티 패키지**: `com.example.carelink.entity`
* **Repository 패키지**: `com.example.carelink.repository`
* **자동 DDL**: 개발 환경에서 `spring.jpa.hibernate.ddl-auto=update`
* **네이밍 전략**: camelCase → underscore 자동 매핑

---

## 🎨 프론트엔드 구조 (React SPA)

### React 프로젝트 구조 (Feature-Based)
```
frontend/src/
├── components/              # 재사용 가능한 컴포넌트
│   ├── ui/                 # 기본 UI 컴포넌트 (Shadcn/ui)
│   └── layout/             # 레이아웃 컴포넌트
├── features/               # 기능별 모듈
│   ├── auth/               # 인증 관련
│   ├── facility/           # 시설 관련
│   ├── job/                # 구인구직 관련
│   └── diplomatic/         # 외교 서비스 관련
├── hooks/                  # 커스텀 훅
├── services/               # API 서비스 (TanStack Query)
├── stores/                 # 상태 관리 (Zustand)
├── types/                  # TypeScript 타입 정의
└── utils/                  # 유틸리티 함수
```

### UI/UX 기술 스택 & 디자인 컨셉
* **디자인 시스템**: Tailwind CSS + Shadcn/ui
* **아이콘**: Lucide React  
* **반응형**: Mobile-First 디자인
* **다국어**: i18next (한국어, 영어, 중국어, 일본어)
* **디자인 컨셉**: 'elderberry' - 아멜리(ameli.co.kr) 스타일 미니멀 & 감성적
* **색상 팔레트**: 파스텔톤 그린/베이지/라이트블루 + 따뜻한 오렌지/옐로우
* **폰트**: Noto Sans KR, Pretendard (가독성 + 따뜻함)
* **애니메이션**: Framer Motion (스크롤 애니메이션 + 호버 효과)

---

## 🧾 주요 설정 파일

### application.yml (SQLite 기반 - 무료 설정)

```yaml
spring:
  application:
    name: global-care-link
  
  # SQLite 데이터베이스 설정 (완전 무료)
  datasource:
    url: jdbc:sqlite:./data/lightcare.db
    driver-class-name: org.sqlite.JDBC
    username: ""
    password: ""
  
  jpa:
    hibernate:
      ddl-auto: create-drop # 개발용, 운영에서는 update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.SQLiteDialect
  
  # Gmail SMTP 설정 (무료)
  mail:
    host: smtp.gmail.com
    port: 587
    username: ${GMAIL_USERNAME}
    password: ${GMAIL_APP_PASSWORD}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
  
  # 캐시 설정 (메모리 캐시)
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=1000,expireAfterWrite=30m
  
  security:
    jwt:
      secret: ${JWT_SECRET:default-secret-key-change-in-production}
      expiration: 86400000 # 24시간

server:
  port: 8080
  
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    com.globalcarelink: DEBUG
```

### 프론트엔드 설정 (package.json)

```json
{
  "name": "global-care-link-frontend",
  "type": "module",
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "zustand": "^4.4.6",
    "@tanstack/react-query": "^5.8.0",
    "axios": "^1.6.0",
    "react-hook-form": "^7.47.0",
    "zod": "^3.22.0",
    "tailwindcss": "^3.3.0",
    "lucide-react": "^0.292.0",
    "i18next": "^23.0.0",
    "react-i18next": "^13.0.0",
    "framer-motion": "^10.0.0",
    "@radix-ui/react-navigation-menu": "^1.1.0",
    "@radix-ui/react-dropdown-menu": "^2.0.0"
  }
}
```

---

## 🔄 개발 패턴

### 컨트롤러 패턴 (최신화)

Spring Boot 3.x MVC 구조:

* **REST API**: `@RestController` + `@RequestMapping` 조합
* **View 컨트롤러**: `@Controller` + Model 객체 활용
* **HTTP 매핑**: `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`
* **검증**: `@Valid` + `@Validated` 어노테이션 활용
* **로깅**: `@Slf4j` + 구조화된 로그 메시지

### 서비스 계층

컨트롤러와 로직 분리:

* 트랜잭션 처리
* 입력 검증
* 횡단 관심사 관리

### JPA Repository 패턴 (최신화)

Spring Data JPA 기반:

* `JpaRepository<Entity, ID>` 상속
* 메서드 이름 기반 쿼리 자동 생성
* `@Query` 어노테이션으로 복잡한 쿼리 처리
* `@Modifying`으로 수정/삭제 쿼리 정의

---

## ✅ 테스트

### 테스트 구조

* 단위 테스트: JUnit 5
* 통합 테스트: Spring Boot Test
* 테스트 설정은 운영과 별도 구성

### 테스트 명령어

```bash
# 전체 테스트 실행
./gradlew test

# 특정 클래스만 실행
./gradlew test --tests "ClassName"
```

---

## 🤝 팀 협업 규칙

### Git 워크플로우

* 기능 브랜치 명: `feature/member-기능명`
* 커밋 메시지: `[feat] 기능 설명`
* PR을 통한 코드 리뷰 진행

### 코드 컨벤션

* 클래스명: PascalCase
* 메서드명: camelCase
* 상수명: UPPER\_SNAKE\_CASE
* 패키지명: 모두 소문자

---

## ⚠️ 특이 사항

### 한글 지원

* 모든 텍스트 콘텐츠는 한글로 작성
* UTF-8 인코딩 유지
* 주석/문서도 한글 기반

### 지도 연동

* 카카오맵 API 연동 예정
* 위도/경도 기반 시설 검색 기능 포함

### 사용자 역할

* `USER`: 일반 구직자
* `FACILITY`: 요양시설 관리자
* `ADMIN`: 시스템 관리자

---

## 🤖 AI 개발 지원 최적화

### 개발 전략 (그린필드 개발)

프로젝트 상황 분석에 따라 다음과 같은 전략을 채택합니다:

#### **현재 문제점**:
- JDK 11→21 및 Spring Boot 2.x→3.3.5 업그레이드 과정에서 24개 에러, 5개 경고 발생
- Spring Security API 변경, Lombok 호환성, 타입 추론 문제 등 복잡한 마이그레이션 이슈
- 팀 개발 능력: AI에 100% 의존하는 주니어 레벨

#### **해결 방안**:
* **새로운 프로젝트 접근**: 기존 레거시 코드 마이그레이션 대신 최신 기술 스택 기반 새로운 개발
* **최신 Spring Boot 3.x 패턴 활용**: Spring Security 6.x, Spring Data JPA 3.x 등 최신 API 사용
* **AI 친화적 코드 작성**: 명확한 패턴, 표준 어노테이션, 일관된 네이밍 규칙
* **기존 코드 재활용**: 비즈니스 로직은 개념적 참고 + AI 포팅으로 최신 문법 적용

### AI에게 요청할 때 권장 사항

**✅ 좋은 질문 예시 (최신 기술 스택 기반):**
```
- "Java 21 + Spring Boot 3.3.5에서 JWT 인증 구현 방법"
- "Spring Security 6.x SecurityFilterChain으로 사용자 로그인 구현"  
- "JPA Entity와 Repository 패턴으로 회원 관리 기능 구현 (Hibernate 6.x)"
- "React 18 + TypeScript로 로그인 폼 구현 (React Hook Form + Zod)"
- "SQLite + Spring Data JPA 설정 방법"
- "Gradle 8.x Kotlin DSL로 멀티모듈 프로젝트 설정"
```

**❌ 피해야 할 요청 (레거시 기술):**
```
- 레거시 Spring Boot 2.x 기반 코드 수정 요청
- MyBatis XML 매퍼 파일 수정 요청  
- JDK 11 기반 코드 마이그레이션 요청
- Spring Security WebSecurityConfigurerAdapter 사용 요청 (Deprecated)
```

### 개발 시 체크리스트

* **기술 스택 확인**: 모든 새 코드는 JDK 21 + Spring Boot 3.3.5 기반
* **의존성 검증**: `build.gradle`에서 최신 버전 사용 확인
* **보안 설정**: Spring Security 6.x 방식으로 구현
* **테스트 코드**: JUnit 5 + Spring Boot Test 활용

---

## 🌐 환경 변수 (무료 서비스 기반)

### 백엔드 환경 변수 (.env)
```bash
# 데이터베이스 설정 (SQLite - 파일 기반, 비밀번호 불필요)
DATABASE_URL=jdbc:sqlite:./data/lightcare.db

# JWT 보안
JWT_SECRET=your_super_secret_jwt_key_with_256_bits_minimum
JWT_EXPIRATION=86400000

# Gmail SMTP 설정 (무료)
GMAIL_USERNAME=your-email@gmail.com
GMAIL_APP_PASSWORD=your_gmail_app_password

# 외부 API (무료 플랜)
KAKAO_API_KEY=your_kakao_map_api_key # 월 30만건 무료
GITHUB_TOKEN=your_github_token # 파일 저장용

# 개발 환경
JAVA_HOME=/path/to/jdk-21
SPRING_PROFILES_ACTIVE=dev
```

### 프론트엔드 환경 변수 (.env.local)
```bash
# API 엔드포인트
VITE_API_BASE_URL=http://localhost:8080/api
VITE_WS_URL=ws://localhost:8080/ws

# 무료 지도 서비스
VITE_KAKAO_API_KEY=your_kakao_api_key # 월 30만건 무료
VITE_USE_FREE_MAP=true # OpenStreetMap 사용 플래그

# GitHub 파일 저장소
VITE_GITHUB_REPO_OWNER=your-username
VITE_GITHUB_REPO_NAME=lightcare-files

# 개발 설정
VITE_DEV_MODE=true
VITE_LOG_LEVEL=debug
```

## 🚀 AI 주도 2주 완성 개발 워크플로우

### 개발자 1인 + AI 협업 모델 (현실적 접근)

* **개발 주체**: 1인 개발자 (100% AI 의존) + Claude AI
* **의사결정**: 개발자가 요구사항 정의, AI가 전체 구현 담당 (설계→코딩→테스트)  
* **품질 관리**: AI가 코드 리뷰, 테스트 코드 작성, 리팩토링, 문서화 모두 담당

### 2주 개발 로드맵 (AI-Driven Development)

#### **1주차: 백엔드 현대화 및 API 핵심 구현**

**Day 1-2: 백엔드 기반 시스템 구축 (AI-Powered Scaffolding)**
- ✅ Spring Boot 3.3.5, Java 21, Gradle 기반 프로젝트 뼈대 생성
- ✅ 기존 데이터베이스 스키마 분석하여 JPA Entity 클래스 자동 생성
- ✅ QueryDSL 설정 및 기본 Q-Type 클래스 생성
- ✅ Spring WebFlux, Spring Data JPA, Spring Security 의존성 추가

**Day 3-4: 핵심 API 구현 (AI Code Generation)**
- ✅ 기존 Controller/Service 분석하여 회원, 시설, 구인구직, 리뷰 도메인 핵심 CRUD API 재구현
- ✅ Spring MVC 기반 컨트롤러 로직 생성
- ✅ OpenAPI 3.0 어노테이션으로 API 문서 자동화

**Day 5: 보안 및 기본 설정 (AI Configuration)**  
- ✅ Spring Security 6.x JWT 인증/인가 시스템 구축
- ✅ @RestControllerAdvice 전역 예외 처리기 구현
- ✅ 로깅 설정 및 개발 환경 최적화

#### **2주차: 프론트엔드 구축 및 배포 자동화**

**Day 6-7: 프론트엔드 프로젝트 생성 (AI-Powered Frontend Setup)**
- ✅ Vite React 18, TypeScript 프로젝트 뼈대 생성
- ✅ 'elderberry' 디자인 시스템 기반 디렉토리 구조 생성
- ✅ Zustand, React Query, Tailwind CSS, Axios 설정

**Day 8-10: UI 구현 및 API 연동 (AI Component Generation & Integration)**
- ✅ 기능별 React 컴포넌트(Button, Header, FacilityCard) 기본 코드 생성
- ✅ API 연동 함수(authApi, facilityApi) 구현
- ✅ React Query와 Axios로 백엔드 연동 및 화면 표시

**Day 11-12: CI/CD 및 테스트 자동화 (AI DevOps)**
- ✅ GitHub Actions 워크플로우 생성 (Build → Test → Deploy)
- ✅ Dockerfile 및 docker-compose.yml 생성
- ✅ JUnit5, Mockito 단위/통합 테스트 코드 생성

**Day 13-14: 최종 통합 및 배포 (Finalization)**
- ✅ Railway/Render 등 무료 배포 서비스 설정
- ✅ README.md 프로젝트 문서 자동 업데이트
- ✅ 최종 통합 테스트 및 프로덕션 배포

### AI 활용 단계별 가이드 (실무 중심)

**1단계: 상황 분석 및 전략 수립**
```
- "JDK 11→21 마이그레이션 대신 새 프로젝트 생성하는 게 맞나요?"
- "Spring Boot 2.x 코드를 3.3.5로 포팅하는 방법"
- "멀티모듈 vs 단일 모듈 중 1인 개발에 적합한 구조"
- "SQLite vs PostgreSQL 중 자본금 0원에 적합한 DB"
```

**2단계: 프로젝트 구조 설계**
```
- "기능별 패키지 구조로 auth/profile/facility/job 모듈 설계"
- "Spring Boot 3.3.5 기반 Gradle Kotlin DSL 설정 파일 작성"
- "SQLite + JPA Entity 설계 (기존 schema.sql 기반)"
- "React + TypeScript + Vite 프론트엔드 구조 설계"
```

**3단계: 핵심 기능 구현**
```
- "Spring Security 6.x JWT 인증 시스템 완전 구현"
- "Member Entity + Repository + Service + Controller 전체 구현"
- "React 로그인/회원가입 폼 + API 연동 완전 구현"
- "Swagger UI API 문서화 자동 설정"
```

**4단계: 통합 및 배포**
```
- "JUnit5 테스트 코드 자동 생성"
- "GitHub Actions CI/CD 파이프라인 구성"
- "Railway 무료 배포를 위한 Dockerfile 작성"
- "최종 프로젝트 README.md 작성"
```

### 효율적인 AI 질문 패턴

**구체적 요청 예시:**
- "Member 엔티티 클래스를 JPA로 구현, 이메일/비밀번호/역할 필드 포함"
- "MemberService에 회원가입 로직 구현, BCrypt 암호화 적용"  
- "Spring Security 6.x로 JWT 기반 인증 설정 구현"
- "MemberController REST API 구현, OpenAPI 3.0 문서화 포함"
- "멀티모듈 구조로 member-module과 api-module 분리"
- "Gradle build.gradle.kts 파일 멀티모듈 설정 구현"

---

## 🏗️ 초기 개발부터 확장성 고려사항

### 모듈 간 의존성 관리

**의존성 방향 (Clean Architecture):**
```
api-module → [member, facility, job, review, diplomatic]-module → core-module
```

**금지된 의존성:**
- 도메인 모듈 간 직접 의존 (❌)
- core-module의 다른 모듈 의존 (❌)

### 확장 가능한 설계 원칙

#### 1. 도메인 주도 설계 (DDD)
```java
// member-module/src/main/java/com/globalcarelink/member/
├── domain/
│   ├── Member.java              # 도메인 엔티티
│   ├── MemberService.java       # 도메인 서비스
│   └── MemberRepository.java    # 리포지토리 인터페이스
├── application/
│   └── MemberApplicationService.java  # 애플리케이션 서비스
└── infrastructure/
    └── MemberJpaRepository.java       # JPA 구현체
```

#### 2. 이벤트 기반 아키텍처
```java
// 회원 가입 시 이벤트 발행
@Service
public class MemberService {
    public void register(Member member) {
        memberRepository.save(member);
        // 이벤트 발행 (이메일 발송, 로그 기록 등)
        applicationEventPublisher.publishEvent(new MemberRegisteredEvent(member));
    }
}
```

#### 3. API 계약 우선 개발 (Contract-First)
```yaml
# OpenAPI 스펙 먼저 정의
openapi: 3.0.3
info:
  title: Global CareLink API
  version: 1.0.0
paths:
  /api/v1/members:
    post:
      summary: 회원 가입
      operationId: registerMember
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MemberRegisterRequest'
```

### 성능 및 확장성 준비

#### 1. 캐싱 전략
```java
@Service
public class FacilityService {
    
    @Cacheable(value = "facilities", key = "#id")
    public Facility findById(Long id) {
        return facilityRepository.findById(id).orElse(null);
    }
    
    @CacheEvict(value = "facilities", key = "#facility.id")
    public Facility update(Facility facility) {
        return facilityRepository.save(facility);
    }
}
```

#### 2. 데이터베이스 최적화
```java
// JPA N+1 문제 방지
@EntityGraph(attributePaths = {"reviews", "images"})
List<Facility> findAllWithReviewsAndImages();

// 페이징 처리
Pageable pageable = PageRequest.of(0, 10, Sort.by("createdAt").descending());
Page<Facility> facilities = facilityRepository.findAll(pageable);
```

### 개발 환경 우선 집중

#### 1. 로컬 개발 설정 최적화
```yaml
# application-dev.yml (개발 전용)
spring:
  jpa:
    hibernate:
      ddl-auto: create-drop # 스키마 자동 생성/삭제
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  
  h2:
    console:
      enabled: true # H2 콘솔 활성화 (개발용)
  
  devtools:
    restart:
      enabled: true # 코드 변경 시 자동 재시작
    livereload:
      enabled: true # 브라우저 자동 새로고침

# 개발 편의성 설정
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    com.globalcarelink: DEBUG
```

#### 2. 개발 도구 활용
```bash
# 개발 중 자주 사용할 명령어
./gradlew bootRun --args='--spring.profiles.active=dev'
./gradlew test --continuous # 테스트 자동 실행
./gradlew :api-module:generateOpenApiDocs # API 문서 생성
```

**Docker/배포는 모든 기능 완성 후 마지막 단계에서 진행 (자본금 0원 고려)**

---

## 🌍 글로벌 확장 계획

### 재외동포 서비스 개요

* **서비스 대상**: 해외 거주 재외동포 및 그 가족
* **주요 기능**: 한국 요양원 정보 제공, 화상 상담, 다국어 지원
* **타겟 국가**: 미국, 중국, 일본, 캐나다, 호주 등
* **연동 API**: 외교부 재외국민영사서비스, 공공데이터포털

### 외교부 API 연동

**연동 예정 API 목록:**
```
1. 재외국민 현황 API
2. 영사관/총영사관 정보 API  
3. 재외동포 지원 정책 API
4. 국가별 의료 정보 API
```

**개발 시 고려사항:**
- 공공데이터포털 인증키 관리
- API 호출 제한 및 캐싱 전략
- 다국어 데이터 처리 및 변환
- 시간대별 데이터 동기화

### 다국어 지원 시스템

* **지원 언어**: 한국어, 영어, 중국어(간체), 일본어
* **국제화 구현**: Spring Boot MessageSource + i18n
* **프론트엔드**: Thymeleaf 다국어 템플릿
* **실시간 번역**: Google Translate API 연동 예정

### 화상 상담 시스템

* **기술 스택**: WebRTC, STOMP, WebSocket
* **기능**: 1:1 화상 상담, 화면 공유, 채팅
* **대상**: 재외동포-국내 요양원 상담자 매칭
* **보안**: HTTPS, JWT 토큰 인증

---

## 🎨 프론트엔드 메뉴 구성 & 사용자 경험

### 'elderberry' 사이트 구조

**메인 네비게이션 (드롭다운 방식)**:

#### 1. 요양 시설 찾기
- **시설 검색** (전체): 전국 요양 시설 검색 및 상세 정보
- **시설 리뷰** (일반 회원): 시설 이용 후기 작성 및 열람
- **우리 시설 관리** (시설 회원): 시설 정보 관리, 공지사항, 예약 현황

#### 2. 일자리 정보  
- **구인 공고** (전체): 요양 관련 구인 게시글 열람 및 지원
- **구직 공고** (전체): 요양 관련 구직 게시글 열람
- **구인글 작성** (시설 회원): 요양 인력 채용 공고 등록
- **구직글 작성** (일반 회원): 요양 관련 일자리 희망 글 등록

#### 3. 정보 마당
- 공지사항, 이벤트, FAQ
- 자료실 (요양 가이드, 서식)
- 요양 뉴스 & 칼럼

#### 4. 코디네이터 서비스
- **코디네이터 소개** (전체): 프로필 및 전문 분야 확인
- **상담 신청** (회원): 1:1 상담 예약
- **나의 매칭 현황** (회원): 매칭 진행 상황 확인
- **계약 관리** (회원): 서비스 계약 내역 확인

### 메인 화면 구성

**Hero Section**:
- **배경**: 요양원/노인 돌봄 관련 따뜻하고 평화로운 풀스크린 이미지
- **중앙 콘텐츠**: "챗봇 엘비와 함께 궁금증을 해결하세요!"
- **CTA 버튼**: "엘비에게 질문하기" / "챗봇 엘비 시작하기"

**스크롤 섹션** (각 섹션별 배경 이미지 + CTA):
1. **요양 시설 찾기**: "나에게 맞는 요양 시설을 찾아보세요"
2. **일자리 정보**: "요양 분야의 새로운 기회를 탐색하세요"  
3. **정보 마당**: "요양 관련 최신 정보와 유용한 지식을 얻으세요"
4. **코디네이터 서비스**: "전문 코디네이터와 1:1 맞춤 상담을 시작하세요"

### 챗봇 '엘비' 연동 (외부 개발)

* **개발 담당**: 별도 팀원 (Python + React)
* **연동 방식**: REST API + WebSocket 통신
* **위치**: 우측 하단 플로팅 버튼 (스크롤 시에도 고정)
* **디자인**: 친근한 챗봇 캐릭터 아이콘
* **기능**: 팝업/오버레이 형태로 실시간 챗봇 상담

### 사용자 권한 시스템 (국내/해외 구분)

#### 역할 구분 (5가지)
* **관리자** (ADMIN): 전체 시스템 관리 (국가 무관)
* **시설회원** (FACILITY): 국내 시설 관리자 (국내만)
* **코디네이터** (COORDINATOR): 글로벌 상담사 (다국어 지원)
* **국내 사용자** (DOMESTIC_USER): 일반 + 구직자 통합 (is_job_seeker 플래그)
* **해외 사용자** (OVERSEAS_USER): 재외동포 일반 + 구직자 통합 (is_job_seeker 플래그)

#### 권한별 기능 접근
* **비회원**: 시설 검색, 구인구직 열람, 정보 마당, 코디네이터 소개
* **국내 일반사용자**: + 리뷰 작성, 시설 즐겨찾기
* **국내 구직자**: + 구직 지원, 이력서 업로드, 매칭 관리
* **해외 일반사용자**: + 재외동포 서비스, 외교부 정보
* **해외 구직자**: + 화상 상담, 국제 매칭, 귀국 계획 관리
* **시설 회원**: + 시설 정보 관리, 구인공고 작성
* **코디네이터**: + 상담 관리, 다국어 서비스 제공
* **관리자**: 전체 시스템 관리

---

## 🏥 요양원 입주자 건강 상태 등급 관리 시스템

### 돌봄지수 체크 시스템 (KB라이프생명 참조)

#### **건강 상태 평가 항목 (4개 핵심 영역)**

**1. 걷기 활동 능력 (care_mobility)**
```yaml
등급 1 (독립): 혼자서 가능해요
등급 2 (부분도움): 부분적인 도움이 필요해요 (타인의 부축, 지팡이 이용 등)
등급 3 (완전도움): 혼자서는 보행이 어려워요 (휠체어 사용 등)
```

**2. 식사 활동 능력 (care_eating)**
```yaml
등급 1 (독립): 혼자서 가능해요
등급 2 (부분도움): 부분적인 도움이 필요해요 (반찬 집기, 자르기 등 일부 도움)
등급 3 (완전도움): 완전한 도움이 필요해요 (음식을 떠 먹여줌)
```

**3. 배변 활동 능력 (care_toilet)**
```yaml
등급 1 (독립): 혼자서 화장실을 이용할 수 있어요
등급 2 (부분도움): 화장실 이용 시 부분적인 도움이 필요해요
등급 3 (완전도움): 완전한 도움이 필요해요 (간이변기, 기저귀 착용 등)
```

**4. 의사소통 능력 (care_communication)**
```yaml
등급 1 (정상): 정상적으로 가능해요
등급 2 (부분제한): 때때로 어려워요 (화장실 이용의사 표현 가능)
등급 3 (심각제한): 소통이 어려워요 (화장실 이용의사 표현 잘 못함)
```

#### **종합 돌봄등급 산출 시스템**

**A. 장기요양보험 등급 기반**
```yaml
1등급: 가장 중증 (95점 이상)
2등급: 중증 (75점~94점)
3등급: 중등증 (60점~74점)
4등급: 경증 (51점~59점)
5등급: 경증 (45점~50점)
인지지원등급: 치매 특화 (45점 미만, 인지기능 저하)
```

**B. 돌봄대상자 상태 분류**
```yaml
상태 1: 6개월 이하의 기대수명 상태 (호스피스 케어)
상태 2: 질병이 회복하기 어려운 상황으로 수명이 얼마 남지 않음
상태 3: 완전히 타인 의존적인 상태이나 사망위험이 높지 않음
상태 4: 해당사항 없음 (일반 요양)
```

#### **요양 시설 등급 및 타입 분류 시스템**

**A. 시설 타입별 분류**
```yaml
주거복지시설:
  - 양로시설: 65세 이상 노인 공동생활 (등급 불필요)
  - 노인공동생활가정: 소규모 공동주택 (5-9명)
  - 노인복지주택: 독립주거 + 복지서비스

의료복지시설:
  - 노인요양시설: 장기요양 1-5등급 대상 (24시간 케어)
  - 노인요양공동생활가정: 소규모 요양시설 (5-9명)
  - 단기보호시설: 임시보호 서비스 (최대 15일)

의료기관:
  - 요양병원: 의료진 상주, 의료서비스 제공
  - 노인전문병원: 노인 특화 의료서비스
  - 노인요양병원: 장기입원 + 요양서비스

재가복지시설:
  - 방문요양서비스: 가정 방문 케어
  - 주야간보호서비스: 낮/밤 임시보호
  - 단기보호서비스: 가족 휴식 지원
```

**B. 시설 등급 분류 (건강보험심사평가원 기준)**
```yaml
A등급 (최우수):
  - 평가점수: 90점 이상
  - 특징: 최고 수준의 케어 품질, 의료진 우수, 시설 현대화
  - 대상: 1-2등급 중증환자 전문 케어

B등급 (우수):
  - 평가점수: 80-89점  
  - 특징: 양질의 케어 서비스, 안정적 운영
  - 대상: 2-3등급 중등도 환자 적합

C등급 (보통):
  - 평가점수: 70-79점
  - 특징: 기본 케어 서비스 제공, 표준적 운영
  - 대상: 3-5등급 경증환자 적합

D등급 (개선필요):
  - 평가점수: 60-69점
  - 특징: 케어 품질 개선 필요, 운영상 이슈
  - 주의: 매칭 시 신중 검토 필요

E등급 (부적합):
  - 평가점수: 60점 미만
  - 특징: 심각한 품질 문제, 행정처분 이력
  - 제외: 매칭 대상에서 제외 권장
```

**C. 전문 특화 시설 분류**
```yaml
치매 전문 시설:
  - 치매안심센터 연계 시설
  - 인지지원등급 전문 케어
  - 치매 행동증상 관리 프로그램

중증환자 전문 시설:
  - 1-2등급 전문 케어
  - 의료진 24시간 상주
  - 중환자실급 케어 시설

재활 전문 시설:
  - 물리치료, 작업치료 전문
  - 재활의학과 전문의 상주
  - 운동기능 개선 프로그램

호스피스 전문 시설:
  - 생애말기 케어 전문
  - 가족 상담 및 지원
  - 종교적/정신적 케어
```

**D. 시설 선택 매칭 알고리즘**
```java
@Entity
public class FacilityProfile {
    @Id
    private Long facilityId;
    
    // 기본 정보
    private String facilityName;
    private String facilityType;           // "양로시설", "노인요양시설", "요양병원" 등
    private String facilityGrade;          // "A", "B", "C", "D", "E"
    private Integer evaluationScore;       // 건강보험심사평가원 점수
    
    // 케어 가능 등급
    @ElementCollection
    private Set<Integer> acceptableCareGrades;  // [1,2,3,4,5,6]
    
    // 전문 분야
    @ElementCollection
    private Set<String> specializations;       // ["dementia", "medical", "rehabilitation"]
    
    // 시설 규모 및 정원
    private Integer totalCapacity;             // 총 정원
    private Integer currentOccupancy;          // 현재 입주자 수
    private Integer availableBeds;             // 가용 침대 수
    
    // 의료진 정보
    private Boolean hasDoctor;                 // 의사 상주 여부
    private Boolean hasNurse24h;               // 24시간 간호사 상주
    private Integer nurseCount;                // 간호사 수
    private Integer caregiverCount;            // 요양보호사 수
    
    // 시설 특징
    private Boolean hasElevator;               // 엘리베이터 보유
    private Boolean hasEmergencySystem;        // 응급시스템 구비
    private Boolean hasRehabilitationRoom;     // 재활실 보유
    private Boolean hasDementiaProgram;        // 치매 프로그램 운영
    
    // 위치 및 접근성
    private String region;                     // 지역 (시/도)
    private String district;                   // 구/군
    private Double latitude;                   // 위도
    private Double longitude;                  // 경도
    private Boolean nearSubway;                // 지하철 접근성
    private Boolean nearHospital;              // 병원 근접성
    
    // 비용 정보
    private Integer monthlyBasicFee;           // 월 기본료
    private Integer admissionFee;              // 입소금
    private Boolean acceptsLtci;               // 장기요양보험 적용
    
    private LocalDateTime lastUpdated;
}

@Service
public class FacilityMatchingService {
    
    public List<FacilityMatch> findCompatibleFacilities(HealthAssessment assessment, 
                                                       FacilityPreference preference) {
        
        CareGrade careGrade = assessment.getOverallCareGrade();
        
        return facilityRepository.findAll().stream()
            .filter(facility -> isBasicCompatible(facility, careGrade))
            .filter(facility -> hasAvailability(facility))
            .filter(facility -> meetsQualityStandard(facility))
            .map(facility -> calculateFacilityMatch(facility, assessment, preference))
            .sorted(Comparator.comparing(FacilityMatch::getMatchScore).reversed())
            .limit(20)
            .collect(Collectors.toList());
    }
    
    private boolean isBasicCompatible(FacilityProfile facility, CareGrade careGrade) {
        // 1. 케어 등급 호환성 체크
        boolean gradeCompatible = facility.getAcceptableCareGrades().contains(careGrade.getLevel());
        
        // 2. 시설 타입별 케어 등급 제한
        boolean typeCompatible = checkFacilityTypeCompatibility(facility.getFacilityType(), careGrade);
        
        // 3. 최소 품질 기준 (D등급 이상)
        boolean qualityAcceptable = !"E".equals(facility.getFacilityGrade());
        
        return gradeCompatible && typeCompatible && qualityAcceptable;
    }
    
    private boolean checkFacilityTypeCompatibility(String facilityType, CareGrade careGrade) {
        switch (facilityType) {
            case "양로시설":
                return careGrade.getLevel() >= 4; // 4-5등급만 가능
                
            case "노인요양시설":
                return true; // 모든 등급 가능
                
            case "요양병원":
                return careGrade.getLevel() <= 3; // 1-3등급 권장
                
            case "노인요양공동생활가정":
                return careGrade.getLevel() >= 3; // 3-5등급 적합
                
            case "치매전문시설":
                return careGrade.getLevel() == 6; // 인지지원등급
                
            default:
                return true;
        }
    }
    
    private FacilityMatch calculateFacilityMatch(FacilityProfile facility, 
                                               HealthAssessment assessment, 
                                               FacilityPreference preference) {
        double score = 0.0;
        
        // 1. 시설 등급 점수 (30%)
        score += calculateFacilityGradeScore(facility) * 0.3;
        
        // 2. 전문성 매칭 점수 (25%)
        score += calculateSpecializationScore(facility, assessment) * 0.25;
        
        // 3. 의료진 적합성 점수 (20%)
        score += calculateMedicalStaffScore(facility, assessment) * 0.2;
        
        // 4. 위치 접근성 점수 (15%)
        score += calculateLocationScore(facility, preference) * 0.15;
        
        // 5. 비용 적합성 점수 (10%)
        score += calculateCostScore(facility, preference) * 0.1;
        
        String explanation = generateFacilityMatchExplanation(facility, assessment, score);
        
        return new FacilityMatch(facility, score, explanation);
    }
    
    private double calculateFacilityGradeScore(FacilityProfile facility) {
        switch (facility.getFacilityGrade()) {
            case "A": return 5.0;
            case "B": return 4.0;
            case "C": return 3.0;
            case "D": return 2.0;
            case "E": return 0.0;
            default: return 2.5;
        }
    }
    
    private double calculateSpecializationScore(FacilityProfile facility, HealthAssessment assessment) {
        double score = 0.0;
        Set<String> specializations = facility.getSpecializations();
        
        // 치매 전문성
        if (assessment.getLtciGrade() == 6 && specializations.contains("dementia")) {
            score += 2.0;
        }
        
        // 의료 전문성 (1-2등급)
        if (assessment.getOverallCareGrade().getLevel() <= 2 && specializations.contains("medical")) {
            score += 2.0;
        }
        
        // 재활 전문성
        if (assessment.getMobilityLevel() >= 2 && specializations.contains("rehabilitation")) {
            score += 1.5;
        }
        
        // 호스피스 전문성
        if (assessment.getCareTargetStatus() <= 2 && specializations.contains("hospice")) {
            score += 1.5;
        }
        
        return Math.min(score, 5.0);
    }
    
    private double calculateMedicalStaffScore(FacilityProfile facility, HealthAssessment assessment) {
        double score = 2.5; // 기본 점수
        
        CareGrade careGrade = assessment.getOverallCareGrade();
        
        // 중증환자(1-2등급)는 의료진 필수
        if (careGrade.getLevel() <= 2) {
            if (facility.getHasDoctor()) score += 1.5;
            if (facility.getHasNurse24h()) score += 1.0;
        }
        
        // 간호사 대 환자 비율
        double nurseRatio = (double) facility.getNurseCount() / facility.getCurrentOccupancy();
        if (nurseRatio >= 0.1) score += 0.5; // 10:1 비율 이상
        
        return Math.min(score, 5.0);
    }
}
```

#### **코디네이터 시설 매칭 지원 시스템**

**코디네이터 역할: 시설 선택 컨설팅 및 입주 중개**
```yaml
코디네이터의 시설 관련 업무:
  - 고객 요구사항 분석 및 적합 시설 추천
  - 시설 견학 동행 및 전문적 평가
  - 시설-환자 매칭 적합성 판단  
  - 입주 계약 협상 및 행정 지원
  - 입주 후 적응 모니터링

시설 관리는 시설 내부 직원:
  - 요양보호사: 일상 케어 담당
  - 간호사: 의료 케어 담당
  - 시설장: 운영 관리 담당
```

**A. 코디네이터 시설 전문성 설정**
```java
@Entity
public class CoordinatorFacilityExpertise {
    @Id
    private Long id;
    private String coordinatorId;
    
    // 시설 타입별 전문성
    @ElementCollection
    private Set<String> expertFacilityTypes;     // ["노인요양시설", "요양병원", "치매전문시설"]
    
    // 시설 등급별 경험
    @ElementCollection
    private Map<String, Integer> facilityGradeExperience; // {"A": 5, "B": 12, "C": 8}
    
    // 지역별 시설 네트워크
    @ElementCollection
    private Set<String> familiarRegions;         // ["서울 강남구", "경기 성남시"]
    
    // 협력 시설 목록
    @ElementCollection
    private Set<Long> partnerFacilities;         // 협력 관계 시설 ID
    
    // 시설 평가 능력
    private Boolean canEvaluateMedicalCare;      // 의료 케어 평가 가능
    private Boolean canEvaluateFacilities;       // 시설 환경 평가 가능
    private Boolean canNegotiateContracts;       // 계약 협상 가능
    
    // 시설 매칭 성과
    private Integer successfulFacilityMatches;   // 성공한 시설 매칭 수
    private Double facilityMatchSatisfaction;    // 시설 매칭 만족도
    private Integer facilityVisitCount;          // 시설 방문 횟수
}
```

**B. 시설 추천 알고리즘 (코디네이터 관점)**
```java
@Service
public class CoordinatorFacilityRecommendationService {
    
    public List<FacilityRecommendation> recommendFacilities(
        String coordinatorId,
        HealthAssessment assessment, 
        FamilyPreference preference) {
        
        Coordinator coordinator = coordinatorRepository.findById(coordinatorId);
        CoordinatorFacilityExpertise expertise = coordinator.getFacilityExpertise();
        
        // 1. 코디네이터 전문 분야 기반 시설 필터링
        List<FacilityProfile> candidateFacilities = findFacilitiesInExpertise(expertise, assessment);
        
        // 2. 코디네이터 네트워크 시설 우선 추천
        List<FacilityRecommendation> recommendations = candidateFacilities.stream()
            .map(facility -> createRecommendation(coordinator, facility, assessment, preference))
            .sorted(Comparator.comparing(FacilityRecommendation::getRecommendationScore).reversed())
            .limit(10)
            .collect(Collectors.toList());
            
        return recommendations;
    }
    
    private FacilityRecommendation createRecommendation(
        Coordinator coordinator,
        FacilityProfile facility,
        HealthAssessment assessment,
        FamilyPreference preference) {
        
        double score = 0.0;
        
        // 1. 기본 시설-환자 매칭 점수 (40%)
        score += calculateBasicMatchScore(facility, assessment) * 0.4;
        
        // 2. 코디네이터 전문성 매칭 점수 (25%)
        score += calculateCoordinatorExpertiseScore(coordinator, facility) * 0.25;
        
        // 3. 과거 매칭 성공률 점수 (20%)
        score += calculateHistoricalSuccessScore(coordinator, facility) * 0.2;
        
        // 4. 가족 선호도 매칭 점수 (15%)
        score += calculateFamilyPreferenceScore(facility, preference) * 0.15;
        
        String reason = generateRecommendationReason(coordinator, facility, assessment, score);
        
        return new FacilityRecommendation(facility, score, reason, coordinator.getId());
    }
    
    private double calculateCoordinatorExpertiseScore(Coordinator coordinator, FacilityProfile facility) {
        CoordinatorFacilityExpertise expertise = coordinator.getFacilityExpertise();
        double score = 2.5; // 기본 점수
        
        // 시설 타입 전문성
        if (expertise.getExpertFacilityTypes().contains(facility.getFacilityType())) {
            score += 1.5;
        }
        
        // 시설 등급 경험
        Integer gradeExperience = expertise.getFacilityGradeExperience()
            .get(facility.getFacilityGrade());
        if (gradeExperience != null && gradeExperience > 0) {
            score += Math.min(gradeExperience * 0.1, 1.0); // 경험치 반영
        }
        
        // 지역 친숙도
        String facilityRegion = facility.getRegion() + " " + facility.getDistrict();
        if (expertise.getFamiliarRegions().contains(facilityRegion)) {
            score += 0.5;
        }
        
        // 협력 시설 여부
        if (expertise.getPartnerFacilities().contains(facility.getFacilityId())) {
            score += 0.5; // 협력 시설 가산점
        }
        
        return Math.min(score, 5.0);
    }
}
```

**C. 시설 견학 및 평가 지원**
```java
@Entity
public class FacilityVisitPlan {
    @Id
    private Long id;
    private String coordinatorId;
    private String clientId;
    
    // 견학 계획
    @ElementCollection
    private List<Long> plannedFacilities;        // 견학 예정 시설
    private LocalDateTime visitDate;
    private String visitPurpose;                  // "초기상담", "최종선택", "재평가"
    
    // 평가 체크리스트
    private String medicalCareEvaluation;         // 의료 케어 평가
    private String livingEnvironmentEvaluation;   // 생활 환경 평가
    private String staffQualityEvaluation;        // 직원 품질 평가
    private String costEvaluation;                // 비용 적정성 평가
    
    // 가족 피드백
    private String familyFeedback;
    private Integer familySatisfactionScore;      // 1-5점
    
    private LocalDateTime createdAt;
}

@Service
public class FacilityVisitSupportService {
    
    public FacilityVisitPlan planFacilityVisits(
        String coordinatorId,
        String clientId, 
        List<FacilityRecommendation> recommendations) {
        
        // 상위 3-5개 시설 선별
        List<Long> topFacilities = recommendations.stream()
            .limit(5)
            .map(rec -> rec.getFacility().getFacilityId())
            .collect(Collectors.toList());
            
        FacilityVisitPlan plan = new FacilityVisitPlan();
        plan.setCoordinatorId(coordinatorId);
        plan.setClientId(clientId);
        plan.setPlannedFacilities(topFacilities);
        plan.setVisitPurpose("초기상담");
        
        return facilityVisitPlanRepository.save(plan);
    }
    
    public FacilityEvaluationReport evaluateFacility(
        String coordinatorId,
        Long facilityId,
        HealthAssessment assessment) {
        
        FacilityProfile facility = facilityRepository.findById(facilityId);
        Coordinator coordinator = coordinatorRepository.findById(coordinatorId);
        
        FacilityEvaluationReport report = new FacilityEvaluationReport();
        
        // 1. 케어 적합성 평가
        report.setCareCompatibilityScore(
            evaluateCareCompatibility(facility, assessment));
        
        // 2. 시설 환경 평가
        report.setEnvironmentScore(
            evaluateEnvironment(facility, assessment));
            
        // 3. 비용 적정성 평가
        report.setCostEffectivenessScore(
            evaluateCostEffectiveness(facility, assessment));
            
        // 4. 종합 추천도
        report.setOverallRecommendation(
            calculateOverallRecommendation(report));
            
        return report;
    }
}
```

**D. 입주 중개 및 계약 지원**
```java
@Entity
public class FacilityAdmissionSupport {
    @Id
    private Long id;
    private String coordinatorId;
    private String clientId;
    private Long selectedFacilityId;
    
    // 입주 절차 진행 상황
    private String admissionStatus;               // "상담완료", "계약협상", "서류준비", "입주완료"
    
    // 계약 협상 내용
    private Integer negotiatedMonthlyFee;         // 협상된 월 이용료
    private Integer negotiatedAdmissionFee;       // 협상된 입소금
    private String specialTerms;                  // 특별 약정 사항
    
    // 필요 서류 체크리스트
    private Boolean healthCertificateReady;       // 건강진단서
    private Boolean ltciCertificateReady;         // 장기요양인정서
    private Boolean insuranceReady;               // 보험 가입 확인
    private Boolean emergencyContactReady;        // 응급연락처
    
    // 입주 준비 지원
    private String personalItemsList;             // 개인 물품 목록
    private LocalDateTime estimatedAdmissionDate; // 예상 입주일
    private String specialCareInstructions;       // 특별 케어 지시사항
    
    private LocalDateTime createdAt;
    private LocalDateTime lastUpdated;
}

@Component
public class AdmissionSupportWorkflow {
    
    public void initiateAdmissionProcess(
        String coordinatorId,
        String clientId,
        Long facilityId) {
        
        FacilityAdmissionSupport support = new FacilityAdmissionSupport();
        support.setCoordinatorId(coordinatorId);
        support.setClientId(clientId);
        support.setSelectedFacilityId(facilityId);
        support.setAdmissionStatus("상담완료");
        
        // 자동으로 필요 서류 체크리스트 생성
        initializeDocumentChecklist(support);
        
        // 시설과 초기 협상 일정 조율
        scheduleInitialNegotiation(support);
        
        admissionSupportRepository.save(support);
    }
    
    public void updateAdmissionProgress(Long supportId, String newStatus) {
        FacilityAdmissionSupport support = admissionSupportRepository.findById(supportId);
        support.setAdmissionStatus(newStatus);
        support.setLastUpdated(LocalDateTime.now());
        
        // 상태별 자동 작업 실행
        switch (newStatus) {
            case "계약협상":
                prepareNegotiationMaterials(support);
                break;
            case "서류준비":
                sendDocumentReminders(support);
                break;
            case "입주완료":
                scheduleFollowUpVisit(support);
                break;
        }
        
        admissionSupportRepository.save(support);
    }
}
```

**E. 입주 후 적응 모니터링**
```java
@Entity
public class PostAdmissionMonitoring {
    @Id
    private Long id;
    private String coordinatorId;
    private String clientId;
    private Long facilityId;
    
    // 모니터링 일정
    private LocalDateTime admissionDate;
    private LocalDateTime firstCheckDate;         // 1주 후
    private LocalDateTime monthlyCheckDate;       // 1개월 후
    private LocalDateTime quarterlyCheckDate;     // 3개월 후
    
    // 적응 상태 평가
    private Integer clientSatisfactionScore;      // 입주자 만족도 (1-5)
    private Integer familySatisfactionScore;      // 가족 만족도 (1-5)
    private Integer facilitySatisfactionScore;    // 시설 만족도 (1-5)
    
    // 이슈 및 개선사항
    private String identifiedIssues;             // 발견된 문제점
    private String improvementActions;           // 개선 조치사항
    private Boolean needsRemediation;            // 중재 필요 여부
    
    // 서비스 지속성
    private Boolean serviceCompleted;            // 서비스 완료 여부
    private LocalDateTime serviceEndDate;        // 서비스 종료일
    private String completionReason;             // 완료 사유
}
```

#### **AI 기반 종합 케어 등급 산출**

**케어 등급 계산 로직**
```java
public class CareGradeCalculator {
    
    public CareGrade calculateComprehensiveGrade(HealthAssessment assessment) {
        // 1. 기본 ADL 점수 계산 (일상생활수행능력)
        int adlScore = calculateADLScore(assessment);
        
        // 2. 장기요양보험 등급 반영
        int ltciGrade = assessment.getLtciGrade();
        
        // 3. 돌봄대상자 상태 반영
        int careTargetStatus = assessment.getCareTargetStatus();
        
        // 4. 종합 케어 등급 도출
        return determineOverallCareGrade(adlScore, ltciGrade, careTargetStatus);
    }
    
    private int calculateADLScore(HealthAssessment assessment) {
        int mobility = assessment.getMobilityLevel();    // 1-3
        int eating = assessment.getEatingLevel();        // 1-3  
        int toilet = assessment.getToiletLevel();        // 1-3
        int communication = assessment.getCommunicationLevel(); // 1-3
        
        // 각 영역별 가중치 적용
        return (mobility * 25) + (eating * 20) + (toilet * 30) + (communication * 25);
    }
}
```

#### **코디네이터 자기 설정 케어 등급 시스템**

**코디네이터 프로필 관리 (Self-Configuration)**
```yaml
기본 자격 등급 (시스템 자동 설정):
  - 자격증 기반 최소 케어 등급 자동 산출
  - 경력 연수별 등급 상한선 설정
  - 교육 이수 현황 반영

개인 설정 케어 등급 (코디네이터 직접 설정):
  - 희망 케어 등급 범위 선택 (복수 선택 가능)
  - 전문 분야별 세부 등급 설정
  - 케어 거부 등급 설정 (개인 사정으로 담당 불가)
  - 동시 담당 가능 케이스 수 설정

실제 매칭 등급 (AI 기반 최적화):
  - 기본 자격 + 개인 설정 + 성과 이력 종합
  - 고객 만족도 기반 등급 조정
  - 케이스 성공률 기반 신뢰도 점수
```

**코디네이터 등급 세분화 시스템**
```yaml
자격증 기반 기본 등급:
  Tier 1 (요양보호사): 
    - 기본 케어 등급: 4-5등급, 인지지원등급
    - 상한선: 3등급까지 가능 (경력 2년+ 시)
    
  Tier 2 (간호조무사, 사회복지사):
    - 기본 케어 등급: 2-5등급  
    - 상한선: 1등급까지 가능 (경력 5년+ 시)
    
  Tier 3 (간호사, 의료진):
    - 기본 케어 등급: 1-5등급 전체
    - 특수 케어: 호스피스, 의료진 협력 케어

경력별 등급 확장:
  신입 (0-1년): 기본 등급에서 -1단계
  경력자 (2-4년): 기본 등급 
  전문가 (5년+): 기본 등급에서 +1단계
  마스터 (10년+): 전체 등급 + 특수 케어
```

**코디네이터 개인 설정 시스템**
```java
@Entity
public class CoordinatorCareSettings {
    @Id
    private Long id;
    private String coordinatorId;
    
    // 시스템 자동 산출 등급
    private Integer baseCareLevel;           // 자격증 기반 기본 등급
    private Integer maxCareLevel;            // 경력 기반 최대 등급
    
    // 코디네이터 개인 설정
    @ElementCollection
    private Set<Integer> preferredCareGrades;    // 선호 케어 등급 [1,2,3,4,5,6]
    
    @ElementCollection  
    private Set<Integer> excludedCareGrades;     // 거부 케어 등급 [1,2]
    
    @ElementCollection
    private Set<String> specialtyAreas;         // 전문 분야 ["dementia", "medical"]
    
    // 업무량 설정
    private Integer maxSimultaneousCases;       // 동시 담당 가능 케이스 수
    private Integer preferredCasesPerMonth;     // 월 선호 케이스 수
    
    // 근무 조건 설정
    private Boolean availableWeekends;          // 주말 근무 가능 여부
    private Boolean availableEmergency;         // 응급 상황 대응 가능 여부
    private Set<String> workingRegions;         // 근무 가능 지역
    
    // 성과 기반 조정
    private Double performanceScore;            // 성과 점수 (0.0-5.0)
    private Double customerSatisfaction;        // 고객 만족도 (0.0-5.0)
    private Integer successfulCases;            // 성공 케이스 수
    private Integer totalCases;                 // 총 담당 케이스 수
    
    private LocalDateTime lastUpdated;
}
```

#### **AI 기반 최적화 매칭 알고리즘**

**1. 다층 매칭 시스템 (Multi-Layer Matching)**
```java
@Service
public class OptimizedCoordinatorMatchingService {
    
    public List<CoordinatorMatch> findOptimalMatches(HealthAssessment assessment, 
                                                   MatchingPreference preference) {
        
        // 1단계: 기본 자격 필터링
        List<Coordinator> eligibleCoordinators = filterByBasicQualifications(assessment);
        
        // 2단계: 코디네이터 설정 매칭
        List<Coordinator> settingsMatched = filterByCoordinatorSettings(eligibleCoordinators, assessment);
        
        // 3단계: AI 스코어링 및 최적화
        List<CoordinatorMatch> scoredMatches = calculateOptimalMatches(settingsMatched, assessment);
        
        // 4단계: 실시간 가용성 확인
        return filterByRealTimeAvailability(scoredMatches, preference);
    }
    
    private List<Coordinator> filterByBasicQualifications(HealthAssessment assessment) {
        CareGrade requiredGrade = assessment.getOverallCareGrade();
        
        return coordinatorRepository.findAll().stream()
            .filter(coordinator -> {
                CoordinatorCareSettings settings = coordinator.getCareSettings();
                
                // 기본 자격 체크
                boolean hasBasicQualification = settings.getBaseCareLevel() <= requiredGrade.getLevel();
                
                // 최대 등급 체크  
                boolean withinMaxLevel = settings.getMaxCareLevel() >= requiredGrade.getLevel();
                
                // 개인 설정 체크
                boolean inPreferredGrades = settings.getPreferredCareGrades().contains(requiredGrade.getLevel());
                boolean notExcluded = !settings.getExcludedCareGrades().contains(requiredGrade.getLevel());
                
                return hasBasicQualification && withinMaxLevel && inPreferredGrades && notExcluded;
            })
            .collect(Collectors.toList());
    }
    
    private List<CoordinatorMatch> calculateOptimalMatches(List<Coordinator> coordinators, 
                                                         HealthAssessment assessment) {
        return coordinators.stream()
            .map(coordinator -> {
                double matchScore = calculateComprehensiveMatchScore(coordinator, assessment);
                return new CoordinatorMatch(coordinator, matchScore, 
                    generateMatchReason(coordinator, assessment));
            })
            .sorted(Comparator.comparing(CoordinatorMatch::getMatchScore).reversed())
            .limit(10) // 상위 10명만 선별
            .collect(Collectors.toList());
    }
    
    private double calculateComprehensiveMatchScore(Coordinator coordinator, HealthAssessment assessment) {
        double score = 0.0;
        
        // 1. 전문성 매칭 점수 (40%)
        score += calculateSpecialtyMatchScore(coordinator, assessment) * 0.4;
        
        // 2. 경력 및 성과 점수 (25%)
        score += calculateExperienceScore(coordinator) * 0.25;
        
        // 3. 고객 만족도 점수 (20%)
        score += coordinator.getCareSettings().getCustomerSatisfaction() * 0.2;
        
        // 4. 지역 접근성 점수 (10%)
        score += calculateLocationScore(coordinator, assessment) * 0.1;
        
        // 5. 실시간 가용성 보너스 (5%)
        score += calculateAvailabilityBonus(coordinator) * 0.05;
        
        return Math.min(score, 5.0); // 최대 5점
    }
}
```

**2. 전문성 기반 스마트 매칭**
```java
private double calculateSpecialtyMatchScore(Coordinator coordinator, HealthAssessment assessment) {
    double specialtyScore = 0.0;
    Set<String> coordinatorSpecialties = coordinator.getCareSettings().getSpecialtyAreas();
    
    // 치매 전문성 매칭
    if (assessment.getLtciGrade() == 6 || assessment.getCommunicationLevel() == 3) {
        if (coordinatorSpecialties.contains("dementia")) {
            specialtyScore += 2.0;
        }
    }
    
    // 의료 전문성 매칭 (1-2등급, 상태1-2)
    if (assessment.getOverallCareGrade().getLevel() <= 2 || assessment.getCareTargetStatus() <= 2) {
        if (coordinatorSpecialties.contains("medical")) {
            specialtyScore += 2.0;
        }
    }
    
    // 재활 전문성 매칭
    if (assessment.getMobilityLevel() >= 2) {
        if (coordinatorSpecialties.contains("rehabilitation")) {
            specialtyScore += 1.5;
        }
    }
    
    // 영양 전문성 매칭
    if (assessment.getEatingLevel() >= 2) {
        if (coordinatorSpecialties.contains("nutrition")) {
            specialtyScore += 1.5;
        }
    }
    
    // 다국어 지원 (재외동포)
    if (assessment.isOverseasKorean()) {
        if (coordinatorSpecialties.contains("multilingual")) {
            specialtyScore += 1.0;
        }
    }
    
    return Math.min(specialtyScore, 5.0);
}
```

**3. 실시간 가용성 및 업무량 최적화**
```java
@Component
public class CoordinatorWorkloadOptimizer {
    
    public List<CoordinatorMatch> optimizeWorkloadDistribution(List<CoordinatorMatch> matches) {
        return matches.stream()
            .map(match -> {
                Coordinator coordinator = match.getCoordinator();
                double workloadScore = calculateWorkloadScore(coordinator);
                
                // 업무량이 적은 코디네이터에게 가산점
                double adjustedScore = match.getMatchScore() + (workloadScore * 0.3);
                
                return new CoordinatorMatch(coordinator, adjustedScore, 
                    match.getMatchReason() + generateWorkloadReason(workloadScore));
            })
            .sorted(Comparator.comparing(CoordinatorMatch::getMatchScore).reversed())
            .collect(Collectors.toList());
    }
    
    private double calculateWorkloadScore(Coordinator coordinator) {
        CoordinatorCareSettings settings = coordinator.getCareSettings();
        int currentCases = getCurrentActiveCases(coordinator.getId());
        int maxCases = settings.getMaxSimultaneousCases();
        
        // 업무량 비율 계산 (낮을수록 높은 점수)
        double workloadRatio = (double) currentCases / maxCases;
        
        if (workloadRatio >= 1.0) return 0.0;      // 포화 상태
        if (workloadRatio >= 0.8) return 1.0;      // 거의 포화
        if (workloadRatio >= 0.6) return 2.0;      // 적정 수준
        if (workloadRatio >= 0.4) return 3.0;      // 여유 있음
        return 4.0;                                // 매우 여유
    }
}
```

**4. 지능형 매칭 결과 설명**
```java
public class MatchingExplanationGenerator {
    
    public String generateMatchReason(Coordinator coordinator, HealthAssessment assessment) {
        StringBuilder reason = new StringBuilder();
        
        // 전문성 매칭 이유
        if (isSpecialtyMatch(coordinator, assessment)) {
            reason.append("🎯 전문 분야 완벽 매칭: ");
            reason.append(getSpecialtyDescription(coordinator, assessment));
            reason.append("\n");
        }
        
        // 경력 매칭 이유
        int experience = coordinator.getCareSettings().getExperienceYears();
        reason.append("📊 경력: ").append(experience).append("년 (");
        if (experience >= 10) reason.append("최고 전문가");
        else if (experience >= 5) reason.append("숙련 전문가");
        else if (experience >= 2) reason.append("경력자");
        else reason.append("신입");
        reason.append(")\n");
        
        // 성과 이유
        double satisfaction = coordinator.getCareSettings().getCustomerSatisfaction();
        reason.append("⭐ 고객 만족도: ").append(satisfaction).append("/5.0");
        if (satisfaction >= 4.5) reason.append(" (최우수)");
        else if (satisfaction >= 4.0) reason.append(" (우수)");
        else if (satisfaction >= 3.5) reason.append(" (양호)");
        reason.append("\n");
        
        // 가용성 이유
        int currentLoad = getCurrentActiveCases(coordinator.getId());
        int maxLoad = coordinator.getCareSettings().getMaxSimultaneousCases();
        reason.append("⏰ 현재 업무량: ").append(currentLoad).append("/").append(maxLoad);
        if (currentLoad < maxLoad * 0.6) reason.append(" (즉시 배정 가능)");
        else if (currentLoad < maxLoad * 0.8) reason.append(" (배정 가능)");
        else reason.append(" (일정 조율 필요)");
        
        return reason.toString();
    }
}
```

**5. 매칭 성능 모니터링**
```yaml
매칭 성공률 추적:
  - 초기 매칭 성공률: 매칭 후 계약 체결율
  - 장기 만족도: 3개월 후 고객 만족도  
  - 코디네이터 만족도: 업무 부하 적정성
  - 재매칭률: 코디네이터 변경 요청률

실시간 최적화:
  - A/B 테스트: 매칭 알고리즘 성능 비교
  - 머신러닝: 매칭 성공 패턴 학습
  - 피드백 루프: 결과 기반 알고리즘 개선
  - 계절별 조정: 시기별 수요 패턴 반영
```

#### **건강 상태 체크리스트 API**

**엔티티 설계**
```java
@Entity
public class HealthAssessment {
    @Id
    private Long id;
    
    // 기본 정보
    private String memberId;
    private String gender;
    private Integer birthYear;
    
    // ADL 평가 (1-3점)
    private Integer mobilityLevel;        // 걷기 활동
    private Integer eatingLevel;          // 식사 활동  
    private Integer toiletLevel;          // 배변 활동
    private Integer communicationLevel;   // 의사소통
    
    // 장기요양보험 정보
    private Integer ltciGrade;           // 1-5등급, 6(인지지원), 7(모름), 8(없음)
    
    // 돌봄대상자 상태
    private Integer careTargetStatus;    // 1-4 (생명예후 상태)
    
    // 계산된 결과
    private Integer adlScore;            // ADL 점수 (4-12점)
    private String overallCareGrade;     // 종합 케어 등급
    private LocalDateTime assessmentDate;
}

@Entity  
public class CoordinatorProfile {
    @Id
    private Long id;
    private String coordinatorId;
    
    // 전문성 레벨
    private Integer professionalLevel;   // 1(초급), 2(중급), 3(고급)
    
    // 케어 가능 등급 (JSON 배열)
    private String compatibleCareGrades; // ["1", "2", "3"]
    
    // 전문 분야 (JSON 배열)  
    private String specialties;          // ["dementia", "medical", "rehabilitation"]
    
    // 자격증 정보
    private String certifications;       // ["nurse", "social_worker_1"]
    
    // 경력 정보
    private Integer experienceYears;
    private Integer totalCases;
    private Double satisfactionScore;
}
```

#### **코디네이터 프로필 관리 시스템**

**API 엔드포인트 설계**
```java
@RestController
@RequestMapping("/api/coordinators")
public class CoordinatorProfileController {
    
    @GetMapping("/{coordinatorId}/care-settings")
    public ResponseEntity<CoordinatorCareSettings> getCareSettings(@PathVariable String coordinatorId) {
        // 코디네이터 케어 설정 조회
    }
    
    @PutMapping("/{coordinatorId}/care-settings")
    public ResponseEntity<CoordinatorCareSettings> updateCareSettings(
        @PathVariable String coordinatorId,
        @RequestBody @Valid CoordinatorCareSettingsRequest request) {
        // 케어 설정 업데이트
    }
    
    @PostMapping("/{coordinatorId}/care-grades/preferences")
    public ResponseEntity<Void> updateCareGradePreferences(
        @PathVariable String coordinatorId,
        @RequestBody CareGradePreferencesRequest request) {
        // 선호/거부 케어 등급 설정
    }
    
    @GetMapping("/{coordinatorId}/matching-statistics")
    public ResponseEntity<MatchingStatistics> getMatchingStatistics(@PathVariable String coordinatorId) {
        // 매칭 성과 통계 조회
    }
    
    @PostMapping("/{coordinatorId}/availability")
    public ResponseEntity<Void> updateAvailability(
        @PathVariable String coordinatorId,
        @RequestBody AvailabilityRequest request) {
        // 실시간 가용성 업데이트
    }
}
```

**React 컴포넌트 - 코디네이터 프로필 관리**
```typescript
// 코디네이터 케어 설정 관리 컴포넌트
export const CoordinatorCareSettingsForm: React.FC = () => {
  const [settings, setSettings] = useState<CoordinatorCareSettings>({
    preferredCareGrades: [],
    excludedCareGrades: [],
    specialtyAreas: [],
    maxSimultaneousCases: 3,
    preferredCasesPerMonth: 10,
    availableWeekends: false,
    availableEmergency: false,
    workingRegions: []
  });

  const careGradeOptions = [
    { value: 1, label: "1등급 (최중증)", description: "24시간 전문 케어 필요" },
    { value: 2, label: "2등급 (중증)", description: "집중적인 의료 지원 필요" },
    { value: 3, label: "3등급 (중등증)", description: "일상 활동 상당한 도움 필요" },
    { value: 4, label: "4등급 (경증)", description: "부분적인 도움 필요" },
    { value: 5, label: "5등급 (경증)", description: "기본적인 지원 필요" },
    { value: 6, label: "인지지원등급", description: "치매 전문 케어" }
  ];

  const specialtyOptions = [
    { value: "dementia", label: "치매 전문", icon: "🧠" },
    { value: "medical", label: "의료 전문", icon: "🏥" },
    { value: "rehabilitation", label: "재활 전문", icon: "💪" },
    { value: "nutrition", label: "영양 전문", icon: "🥗" },
    { value: "multilingual", label: "다국어 지원", icon: "🌐" },
    { value: "hospice", label: "호스피스 케어", icon: "🕊️" }
  ];

  const handleSaveSettings = async () => {
    try {
      await coordinatorApi.updateCareSettings(coordinatorId, settings);
      toast.success("케어 설정이 성공적으로 업데이트되었습니다.");
    } catch (error) {
      toast.error("설정 업데이트에 실패했습니다.");
    }
  };

  return (
    <div className="coordinator-care-settings">
      <div className="settings-section">
        <h3>선호 케어 등급 설정</h3>
        <p className="description">담당하고 싶은 케어 등급을 선택하세요. (복수 선택 가능)</p>
        
        <div className="care-grade-selection">
          {careGradeOptions.map(option => (
            <div key={option.value} className="grade-option">
              <Checkbox
                checked={settings.preferredCareGrades.includes(option.value)}
                onChange={(checked) => handleGradeToggle('preferred', option.value, checked)}
              />
              <div className="grade-info">
                <span className="grade-label">{option.label}</span>
                <span className="grade-description">{option.description}</span>
              </div>
            </div>
          ))}
        </div>
      </div>

      <div className="settings-section">
        <h3>케어 거부 등급 설정</h3>
        <p className="description">개인 사정으로 담당하기 어려운 등급을 선택하세요.</p>
        
        <div className="excluded-grades">
          {careGradeOptions.map(option => (
            <div key={option.value} className="grade-option">
              <Checkbox
                checked={settings.excludedCareGrades.includes(option.value)}
                onChange={(checked) => handleGradeToggle('excluded', option.value, checked)}
              />
              <span>{option.label}</span>
            </div>
          ))}
        </div>
      </div>

      <div className="settings-section">
        <h3>전문 분야 설정</h3>
        <div className="specialty-selection">
          {specialtyOptions.map(specialty => (
            <div key={specialty.value} className="specialty-card">
              <input
                type="checkbox"
                checked={settings.specialtyAreas.includes(specialty.value)}
                onChange={(e) => handleSpecialtyToggle(specialty.value, e.target.checked)}
              />
              <div className="specialty-info">
                <span className="specialty-icon">{specialty.icon}</span>
                <span className="specialty-label">{specialty.label}</span>
              </div>
            </div>
          ))}
        </div>
      </div>

      <div className="settings-section">
        <h3>업무량 설정</h3>
        <div className="workload-settings">
          <div className="input-group">
            <label>동시 담당 가능 케이스 수</label>
            <input
              type="number"
              min="1"
              max="10"
              value={settings.maxSimultaneousCases}
              onChange={(e) => setSettings({...settings, maxSimultaneousCases: parseInt(e.target.value)})}
            />
          </div>
          
          <div className="input-group">
            <label>월 선호 케이스 수</label>
            <input
              type="number"
              min="1"
              max="30"
              value={settings.preferredCasesPerMonth}
              onChange={(e) => setSettings({...settings, preferredCasesPerMonth: parseInt(e.target.value)})}
            />
          </div>
        </div>
      </div>

      <div className="settings-section">
        <h3>근무 조건 설정</h3>
        <div className="work-conditions">
          <div className="condition-item">
            <Checkbox
              checked={settings.availableWeekends}
              onChange={(checked) => setSettings({...settings, availableWeekends: checked})}
            />
            <span>주말 근무 가능</span>
          </div>
          
          <div className="condition-item">
            <Checkbox
              checked={settings.availableEmergency}
              onChange={(checked) => setSettings({...settings, availableEmergency: checked})}
            />
            <span>응급 상황 대응 가능</span>
          </div>
        </div>
      </div>

      <div className="settings-actions">
        <button onClick={handleSaveSettings} className="save-button">
          설정 저장
        </button>
        <button onClick={handlePreviewMatching} className="preview-button">
          매칭 미리보기
        </button>
      </div>
    </div>
  );
};
```

**매칭 미리보기 컴포넌트**
```typescript
export const MatchingPreview: React.FC<{coordinatorId: string}> = ({coordinatorId}) => {
  const [matchingPreview, setMatchingPreview] = useState<MatchingPreviewData | null>(null);
  
  const loadMatchingPreview = async () => {
    const preview = await coordinatorApi.getMatchingPreview(coordinatorId);
    setMatchingPreview(preview);
  };

  return (
    <div className="matching-preview">
      <h3>🎯 매칭 미리보기</h3>
      <p>현재 설정으로 매칭 가능한 케이스들을 확인해보세요.</p>
      
      {matchingPreview && (
        <div className="preview-results">
          <div className="preview-stats">
            <div className="stat-item">
              <span className="stat-number">{matchingPreview.totalEligibleCases}</span>
              <span className="stat-label">매칭 가능 케이스</span>
            </div>
            
            <div className="stat-item">
              <span className="stat-number">{matchingPreview.averageMatchScore.toFixed(1)}</span>
              <span className="stat-label">평균 매칭 점수</span>
            </div>
            
            <div className="stat-item">
              <span className="stat-number">{matchingPreview.weeklyExpectedCases}</span>
              <span className="stat-label">주간 예상 배정</span>
            </div>
          </div>

          <div className="preview-recommendations">
            <h4>💡 설정 개선 제안</h4>
            {matchingPreview.recommendations.map((rec, index) => (
              <div key={index} className="recommendation-item">
                <span className="rec-icon">💡</span>
                <span className="rec-text">{rec.message}</span>
                {rec.actionable && (
                  <button 
                    className="apply-recommendation"
                    onClick={() => applyRecommendation(rec)}
                  >
                    적용
                  </button>
                )}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

**실시간 가용성 관리**
```typescript
export const CoordinatorAvailabilityWidget: React.FC = () => {
  const [availability, setAvailability] = useState({
    status: 'available', // available, busy, offline
    currentCases: 2,
    maxCases: 5,
    nextAvailable: null as Date | null
  });

  const updateAvailability = async (newStatus: string) => {
    await coordinatorApi.updateAvailability(coordinatorId, {
      status: newStatus,
      timestamp: new Date()
    });
    setAvailability({...availability, status: newStatus});
  };

  return (
    <div className="availability-widget">
      <h4>📊 실시간 가용성</h4>
      
      <div className="current-status">
        <div className={`status-indicator ${availability.status}`}>
          <span className="status-dot"></span>
          <span className="status-text">
            {availability.status === 'available' && '매칭 가능'}
            {availability.status === 'busy' && '업무 중'}
            {availability.status === 'offline' && '오프라인'}
          </span>
        </div>
      </div>

      <div className="workload-indicator">
        <div className="workload-bar">
          <div 
            className="workload-fill"
            style={{width: `${(availability.currentCases / availability.maxCases) * 100}%`}}
          ></div>
        </div>
        <span className="workload-text">
          {availability.currentCases}/{availability.maxCases} 케이스 담당 중
        </span>
      </div>

      <div className="status-controls">
        <button 
          onClick={() => updateAvailability('available')}
          className={availability.status === 'available' ? 'active' : ''}
        >
          매칭 가능
        </button>
        <button 
          onClick={() => updateAvailability('busy')}
          className={availability.status === 'busy' ? 'active' : ''}
        >
          업무 중
        </button>
        <button 
          onClick={() => updateAvailability('offline')}
          className={availability.status === 'offline' ? 'active' : ''}
        >
          오프라인
        </button>
      </div>
    </div>
  );
};
```

#### **체크리스트 UI 컴포넌트**

**React 컴포넌트 구조**
```typescript
// 건강 상태 체크리스트 컴포넌트
export const HealthAssessmentForm: React.FC = () => {
  const [assessment, setAssessment] = useState<HealthAssessmentData>({
    mobility: null,
    eating: null, 
    toilet: null,
    communication: null,
    ltciGrade: null,
    careTargetStatus: null
  });

  const assessmentQuestions = {
    mobility: {
      title: "걷기 활동 능력",
      options: [
        { value: 1, label: "혼자서 가능해요" },
        { value: 2, label: "부분적인 도움이 필요해요\n(타인의 부축, 지팡이 이용 등)" },
        { value: 3, label: "혼자서는 보행이 어려워요\n(휠체어 사용 등)" }
      ]
    },
    // ... 다른 항목들
  };

  const handleSubmit = async () => {
    const result = await healthAssessmentApi.calculate(assessment);
    // 결과 처리 및 코디네이터 추천
  };
};
```

---

## 🤖 챗봇 '엘비' 자동화 시스템 (AI-Powered Process Automation)

### 챗봇 자동화의 핵심 가치

**재외동포를 위한 한국 행정 절차 자동화**
```yaml
자동화 목표:
  - 복잡한 한국 행정 절차를 단계별 대화로 단순화
  - 반복적인 서류 작성 작업을 AI가 대신 처리
  - 24시간 다국어 지원으로 시차 문제 해결
  - 실시간 진행 상황 추적 및 알림

대상 사용자:
  - 재외동포: 한국 시스템에 익숙하지 않은 해외 거주자
  - 고령자: 복잡한 온라인 양식 작성이 어려운 사용자
  - 가족: 부모님 대신 서류를 준비하는 자녀들
```

#### **A. 챗봇 기반 서류 작성 자동화**

**1. 건강 관련 서류 자동화**
```java
@Component
public class HealthDocumentAutomation {
    
    public class HealthCertificateBot {
        
        public ChatResponse processHealthCertificate(String userId, ChatMessage message) {
            HealthDocumentSession session = getOrCreateSession(userId, "health_certificate");
            
            switch (session.getCurrentStep()) {
                case "GREETING":
                    return askBasicInfo();
                    
                case "BASIC_INFO":
                    session.setBasicInfo(extractBasicInfo(message));
                    return askMedicalHistory();
                    
                case "MEDICAL_HISTORY":
                    session.setMedicalHistory(extractMedicalHistory(message));
                    return askCurrentSymptoms();
                    
                case "CURRENT_SYMPTOMS":
                    session.setCurrentSymptoms(extractSymptoms(message));
                    return askPreferredHospital();
                    
                case "HOSPITAL_SELECTION":
                    session.setPreferredHospital(extractHospital(message));
                    return generateHealthCertificateForm(session);
                    
                case "FORM_REVIEW":
                    if (message.getContent().contains("확인") || message.getContent().contains("제출")) {
                        return submitHealthCertificateApplication(session);
                    }
                    return askForCorrections(message);
            }
        }
        
        private ChatResponse askBasicInfo() {
            return ChatResponse.builder()
                .message("안녕하세요! 건강진단서 신청을 도와드리겠습니다. 먼저 기본 정보를 알려주세요.\n\n" +
                        "📋 필요한 정보:\n" +
                        "• 성명 (한글)\n" +
                        "• 생년월일 (예: 1950년 3월 15일)\n" +
                        "• 주민등록번호 앞 6자리\n\n" +
                        "예시: 홍길동, 1950년 3월 15일, 500315")
                .type(ChatMessageType.FORM_INPUT)
                .expectedInput(Arrays.asList("name", "birthDate", "residentNumber"))
                .build();
        }
        
        private ChatResponse generateHealthCertificateForm(HealthDocumentSession session) {
            // AI가 수집된 정보로 건강진단서 신청서 자동 작성
            HealthCertificateForm form = HealthCertificateForm.builder()
                .name(session.getBasicInfo().getName())
                .birthDate(session.getBasicInfo().getBirthDate())
                .residentNumber(session.getBasicInfo().getResidentNumber())
                .medicalHistory(session.getMedicalHistory())
                .currentSymptoms(session.getCurrentSymptoms())
                .preferredHospital(session.getPreferredHospital())
                .applicationDate(LocalDateTime.now())
                .build();
                
            String formPreview = generateFormPreview(form);
            
            return ChatResponse.builder()
                .message("✅ 건강진단서 신청서가 완성되었습니다!\n\n" + formPreview + 
                        "\n\n내용을 확인하시고 '제출'이라고 말씀해주세요. 수정이 필요하면 '수정'이라고 해주세요.")
                .type(ChatMessageType.FORM_PREVIEW)
                .attachments(Arrays.asList(generatePdfForm(form)))
                .build();
        }
    }
}
```

**2. 장기요양인정서 신청 자동화**
```java
@Component
public class LtciApplicationBot {
    
    public ChatResponse processLtciApplication(String userId, ChatMessage message) {
        LtciApplicationSession session = getOrCreateSession(userId, "ltci_application");
        
        switch (session.getCurrentStep()) {
            case "GREETING":
                return explainLtciProcess();
                
            case "CARE_ASSESSMENT":
                return conductCareAssessment(message);
                
            case "FAMILY_INFO":
                return collectFamilyInformation(message);
                
            case "PREFERRED_SERVICES":
                return askPreferredServices(message);
                
            case "DOCUMENT_PREPARATION":
                return prepareRequiredDocuments(session);
                
            case "FINAL_REVIEW":
                return submitLtciApplication(session);
        }
    }
    
    private ChatResponse explainLtciProcess() {
        return ChatResponse.builder()
            .message("🏥 장기요양인정 신청 절차를 안내해드리겠습니다.\n\n" +
                    "📝 필요한 단계:\n" +
                    "1️⃣ 건강 상태 평가 (5분)\n" +
                    "2️⃣ 가족 정보 입력 (3분)\n" +
                    "3️⃣ 희망 서비스 선택 (2분)\n" +
                    "4️⃣ 서류 자동 생성 및 제출\n\n" +
                    "총 소요시간: 약 10분\n\n" +
                    "시작하시려면 '시작'이라고 말씀해주세요!")
            .type(ChatMessageType.PROCESS_GUIDE)
            .quickReplies(Arrays.asList("시작", "더 자세한 설명"))
            .build();
    }
    
    private ChatResponse conductCareAssessment(ChatMessage message) {
        // 기존 건강 상태 체크리스트를 대화형으로 진행
        return HealthAssessmentChatbot.processCareAssessment(message);
    }
}
```

#### **B. 체크리스트 자동화 시스템**

**1. 대화형 건강 상태 체크리스트**
```java
@Component
public class InteractiveCareAssessment {
    
    public class CareAssessmentChatbot {
        
        public ChatResponse processCareAssessment(ChatMessage message) {
            AssessmentSession session = getOrCreateSession(message.getUserId(), "care_assessment");
            
            switch (session.getCurrentQuestion()) {
                case "MOBILITY":
                    return askMobilityLevel();
                    
                case "EATING":
                    return askEatingLevel(session);
                    
                case "TOILET":
                    return askToiletLevel(session);
                    
                case "COMMUNICATION":
                    return askCommunicationLevel(session);
                    
                case "LTCI_GRADE":
                    return askLtciGrade(session);
                    
                case "ASSESSMENT_COMPLETE":
                    return generateAssessmentResult(session);
            }
        }
        
        private ChatResponse askMobilityLevel() {
            return ChatResponse.builder()
                .message("🚶‍♂️ **걷기 활동 능력**에 대해 질문드리겠습니다.\n\n" +
                        "다음 중 어느 것이 가장 가까우신가요?\n\n" +
                        "1️⃣ 혼자서 걸을 수 있어요\n" +
                        "2️⃣ 지팡이나 부축이 필요해요\n" +
                        "3️⃣ 휠체어를 사용해요\n\n" +
                        "번호나 설명으로 답변해주세요.")
                .type(ChatMessageType.MULTIPLE_CHOICE)
                .quickReplies(Arrays.asList("1", "2", "3", "혼자서 가능", "부축 필요", "휠체어 사용"))
                .build();
        }
        
        private ChatResponse generateAssessmentResult(AssessmentSession session) {
            HealthAssessment assessment = calculateAssessment(session);
            
            String resultMessage = String.format(
                "✅ **건강 상태 평가 완료**\n\n" +
                "📊 **평가 결과:**\n" +
                "• ADL 점수: %d점\n" +
                "• 종합 케어 등급: %s\n" +
                "• 추천 시설 타입: %s\n\n" +
                "🎯 **매칭된 코디네이터:** %d명\n" +
                "🏥 **추천 요양시설:** %d곳\n\n" +
                "다음 단계로 진행하시겠습니까?",
                assessment.getAdlScore(),
                assessment.getOverallCareGrade(),
                getRecommendedFacilityTypes(assessment),
                getMatchedCoordinatorCount(assessment),
                getRecommendedFacilityCount(assessment)
            );
            
            return ChatResponse.builder()
                .message(resultMessage)
                .type(ChatMessageType.ASSESSMENT_RESULT)
                .quickReplies(Arrays.asList("코디네이터 매칭", "시설 둘러보기", "결과 저장"))
                .data(assessment)
                .build();
        }
    }
}
```

**2. 시설 견학 체크리스트 자동화**
```java
@Component
public class FacilityVisitChecklistBot {
    
    public ChatResponse processFacilityVisit(String userId, Long facilityId, ChatMessage message) {
        VisitSession session = getOrCreateSession(userId, facilityId);
        
        switch (session.getCurrentStep()) {
            case "PRE_VISIT":
                return providePreVisitGuidance();
                
            case "DURING_VISIT":
                return guideDuringVisit(message);
                
            case "POST_VISIT":
                return collectPostVisitFeedback(message);
                
            case "EVALUATION_COMPLETE":
                return generateVisitReport(session);
        }
    }
    
    private ChatResponse providePreVisitGuidance() {
        return ChatResponse.builder()
            .message("🏥 **시설 견학 준비가 완료되었습니다!**\n\n" +
                    "📋 **견학 시 확인할 항목들:**\n\n" +
                    "🔍 **시설 환경**\n" +
                    "• 청결도 및 냄새\n" +
                    "• 안전시설 (난간, 응급벨)\n" +
                    "• 공용공간 활용도\n\n" +
                    "👥 **직원 서비스**\n" +
                    "• 직원 친절도\n" +
                    "• 전문성 및 경험\n" +
                    "• 입주자와의 소통 방식\n\n" +
                    "💰 **비용 및 계약**\n" +
                    "• 월 이용료 및 추가 비용\n" +
                    "• 계약 조건 및 환불 정책\n\n" +
                    "견학을 시작하시면 '견학 시작'이라고 알려주세요!")
            .type(ChatMessageType.VISIT_GUIDE)
            .quickReplies(Arrays.asList("견학 시작", "체크리스트 받기", "질문 목록"))
            .build();
    }
    
    private ChatResponse guideDuringVisit(ChatMessage message) {
        if (message.getContent().contains("견학 시작")) {
            return startInteractiveChecklist();
        }
        
        // 음성/텍스트로 실시간 체크리스트 진행
        return processChecklistItem(message);
    }
    
    private ChatResponse startInteractiveChecklist() {
        return ChatResponse.builder()
            .message("📱 **실시간 견학 가이드를 시작합니다!**\n\n" +
                    "🎤 음성으로 답변하시거나 텍스트로 입력해주세요.\n\n" +
                    "**첫 번째 질문:**\n" +
                    "시설에 들어서자마자 느껴지는 첫인상은 어떠신가요?\n" +
                    "(청결도, 냄새, 분위기 등)")
            .type(ChatMessageType.VOICE_INPUT_ENABLED)
            .expectedInput(Arrays.asList("cleanliness", "smell", "atmosphere"))
            .build();
    }
}
```

#### **C. 일정 관리 및 예약 자동화**

**1. 병원 예약 자동화**
```java
@Component
public class HospitalBookingBot {
    
    public ChatResponse processHospitalBooking(String userId, ChatMessage message) {
        BookingSession session = getOrCreateSession(userId, "hospital_booking");
        
        switch (session.getCurrentStep()) {
            case "HOSPITAL_SELECTION":
                return recommendHospitals(session);
                
            case "APPOINTMENT_TYPE":
                return askAppointmentType(message);
                
            case "PREFERRED_TIME":
                return askPreferredTime(message);
                
            case "BOOKING_CONFIRMATION":
                return confirmAndBook(session);
        }
    }
    
    private ChatResponse recommendHospitals(BookingSession session) {
        // 건강 상태 기반 병원 추천
        List<Hospital> recommendedHospitals = hospitalRecommendationService
            .recommend(session.getHealthAssessment());
            
        String hospitalList = recommendedHospitals.stream()
            .map(hospital -> String.format(
                "🏥 **%s**\n" +
                "📍 %s\n" +
                "⭐ %s (%d개 리뷰)\n" +
                "🚗 거리: %s\n" +
                "💰 진료비: %s\n",
                hospital.getName(),
                hospital.getAddress(),
                hospital.getRating(),
                hospital.getReviewCount(),
                hospital.getDistance(),
                hospital.getEstimatedCost()
            ))
            .collect(Collectors.joining("\n"));
            
        return ChatResponse.builder()
            .message("🏥 **건강검진 가능한 병원을 추천해드립니다:**\n\n" + hospitalList +
                    "\n어느 병원에서 검진받으시겠어요?")
            .type(ChatMessageType.HOSPITAL_SELECTION)
            .quickReplies(recommendedHospitals.stream()
                .map(Hospital::getName)
                .collect(Collectors.toList()))
            .build();
    }
}
```

#### **D. 다국어 지원 및 음성 인식**

**1. 다국어 대화 시스템**
```java
@Component
public class MultilingualChatbot {
    
    public ChatResponse processMessage(ChatMessage message) {
        String detectedLanguage = languageDetectionService.detect(message.getContent());
        String userId = message.getUserId();
        
        // 사용자 언어 설정 저장
        userPreferenceService.setLanguage(userId, detectedLanguage);
        
        // 메시지를 한국어로 번역 (처리용)
        String translatedMessage = translationService.translate(message.getContent(), detectedLanguage, "ko");
        
        // 챗봇 로직 처리
        ChatResponse response = chatbotEngine.process(translatedMessage, userId);
        
        // 응답을 사용자 언어로 번역
        String localizedResponse = translationService.translate(response.getMessage(), "ko", detectedLanguage);
        response.setMessage(localizedResponse);
        
        return response;
    }
    
    @Service
    public class VoiceInteractionService {
        
        public ChatResponse processVoiceInput(String userId, AudioData audioData) {
            // 음성을 텍스트로 변환
            String recognizedText = speechToTextService.recognize(audioData);
            
            // 언어 감지 및 번역
            ChatMessage textMessage = ChatMessage.builder()
                .userId(userId)
                .content(recognizedText)
                .type(MessageType.VOICE)
                .build();
                
            ChatResponse response = processMessage(textMessage);
            
            // 응답을 음성으로 변환
            AudioData responseAudio = textToSpeechService.synthesize(
                response.getMessage(), 
                userPreferenceService.getLanguage(userId)
            );
            
            response.setAudioResponse(responseAudio);
            return response;
        }
    }
}
```

#### **E. 진행 상황 추적 및 알림**

**1. 프로세스 추적 시스템**
```java
@Entity
public class ChatbotProcessTracker {
    @Id
    private Long id;
    private String userId;
    private String processType;              // "health_certificate", "ltci_application"
    private String currentStep;
    private Integer totalSteps;
    private Integer completedSteps;
    private Double progressPercentage;
    
    // 수집된 데이터
    @Column(columnDefinition = "TEXT")
    private String collectedData;            // JSON 형태로 저장
    
    // 생성된 문서들
    @ElementCollection
    private List<String> generatedDocuments;
    
    // 다음 액션
    private String nextAction;
    private LocalDateTime nextActionDate;
    
    private LocalDateTime createdAt;
    private LocalDateTime lastUpdated;
}

@Service
public class ProcessNotificationService {
    
    public void sendProgressUpdate(String userId, String processType) {
        ChatbotProcessTracker tracker = processTrackerRepository
            .findByUserIdAndProcessType(userId, processType);
            
        String progressMessage = String.format(
            "📋 **%s 진행 상황**\n\n" +
            "✅ 완료: %d/%d 단계 (%.0f%%)\n" +
            "📝 현재 단계: %s\n" +
            "⏰ 다음 할일: %s\n" +
            "📅 예정일: %s",
            getProcessDisplayName(processType),
            tracker.getCompletedSteps(),
            tracker.getTotalSteps(),
            tracker.getProgressPercentage(),
            getCurrentStepName(tracker.getCurrentStep()),
            tracker.getNextAction(),
            tracker.getNextActionDate()
        );
        
        notificationService.sendChatbotMessage(userId, progressMessage);
    }
    
    @Scheduled(cron = "0 0 9 * * *") // 매일 오전 9시
    public void sendDailyReminders() {
        List<ChatbotProcessTracker> pendingProcesses = processTrackerRepository
            .findPendingProcesses();
            
        pendingProcesses.forEach(tracker -> {
            if (needsReminder(tracker)) {
                sendReminderMessage(tracker);
            }
        });
    }
}
```

#### **F. 챗봇 시스템 호환성 및 확장성 검토**

**1. 기존 시스템과의 API 호환성**
```yaml
호환 가능한 기존 API:
  - HealthAssessment API: 건강 상태 체크리스트 결과 연동
  - CoordinatorMatching API: 챗봇 → 매칭 시스템 자동 연계
  - FacilityRecommendation API: 시설 추천 결과 활용
  - DocumentGeneration API: 서류 자동 생성 연동

데이터 구조 호환성:
  - 기존 HealthAssessment 엔티티와 100% 호환
  - ChatbotProcessTracker가 기존 프로세스 추적과 연계
  - 생성된 문서는 기존 파일 관리 시스템 활용
```

**2. 확장 가능한 아키텍처**
```java
// 새로운 프로세스 추가 시 확장 예시
@Component
public class InsuranceApplicationBot extends BaseDocumentBot {
    
    @Override
    protected List<String> getRequiredSteps() {
        return Arrays.asList(
            "INSURANCE_TYPE_SELECTION",
            "BENEFICIARY_INFO", 
            "COVERAGE_SELECTION",
            "DOCUMENT_GENERATION"
        );
    }
    
    @Override
    protected String getProcessType() {
        return "insurance_application";
    }
}

// 다국어 확장
@Component
public class LanguageExpansionService {
    
    public void addNewLanguage(String languageCode, Map<String, String> translations) {
        // 새로운 언어 동적 추가 지원
        translationService.addLanguageSupport(languageCode, translations);
        voiceService.addTTSSupport(languageCode);
    }
}
```

**3. 외부 시스템 연동 확장성**
```yaml
확장 가능한 연동:
  - 외교부 API: 재외국민 정보 자동 조회
  - 보건복지부 API: 장기요양보험 신청 자동 제출
  - 국민건강보험공단 API: 건강보험 정보 연동
  - 전자정부 API: 각종 민원 서류 자동 제출

모듈화된 확장:
  - 새로운 서류 타입 플러그인 방식 추가
  - 새로운 체크리스트 템플릿 동적 로딩
  - 새로운 언어팩 런타임 추가
  - 새로운 음성 엔진 연동
```

**4. 성능 및 확장성 고려사항**
```yaml
성능 최적화:
  - 세션 관리: Redis 기반 분산 세션 지원
  - 병렬 처리: 다중 사용자 동시 대화 지원
  - 캐싱: 자주 사용되는 템플릿 메모리 캐시
  - 로드밸런싱: 다중 챗봇 인스턴스 지원

모니터링:
  - 대화 성공률 추적
  - 프로세스 완료율 모니터링
  - 사용자 만족도 수집
  - 시스템 응답 시간 측정
```

---

## 🤝 코디네이터 원스톱 서비스 (핵심 비즈니스 모델)

### 서비스 개요

코디네이터는 **해외 재외동포**를 대상으로 **입국 절차부터 요양원 입주까지** 전 과정을 원스톱으로 지원하는 전문 서비스입니다.

### 4단계 원스톱 서비스 프로세스

#### **1단계: 입국 전 준비 지원 (Pre-Arrival)**
```yaml
서비스 기간: 1-2개월
주요 업무:
  - 🛂 비자 상담 및 서류 준비 지원 (방문동반비자, 관광비자 등)
  - ✈️ 항공편 예약 및 교통편 안내
  - 🏨 임시 숙소 예약 (단기 렌탈, 게스트하우스)
  - 📋 사전 상담 (화상통화로 가족 상황, 요구사항 파악)
  - 💰 예산 계획 수립 (요양원 비용, 생활비, 서비스 비용)
  - 📱 한국 생활 필수 정보 제공 (통신, 교통, 의료 등)
```

#### **2단계: 입국 및 정착 지원 (Arrival & Settlement)**  
```yaml
서비스 기간: 1-2주
주요 업무:
  - 🚗 공항 픽업 서비스 (인천공항 → 임시 숙소)
  - 🏪 생활 필수 업무 동행 지원:
    * 은행 계좌 개설 (외국인 전용 계좌)
    * 휴대폰 개통 (선불/후불 요금제 선택)
    * 건강보험 가입 절차 (국민건강보험, 외국인 보험)
    * 교통카드 발급 (T-money, Wowpass)
  - 🛍️ 생활용품 구매 동행 (마트, 약국, 생필품)
  - 🗣️ 언어 장벽 해결 (실시간 통번역 지원)
  - 📍 주변 환경 안내 (병원, 약국, 마트, 관공서 위치)
```

#### **3단계: 요양원 매칭 및 선택 지원 (Care Facility Matching)**
```yaml
서비스 기간: 2-4주  
주요 업무:
  - 🏥 부모님 건강상태 종합 평가:
    * 전문의 건강검진 동행
    * 요양등급 신청 도움 (장기요양보험)
    * 의료진 소견 번역 및 설명
  - 🎯 맞춤형 요양원 추천:
    * 건강상태/예산/위치 기반 매칭
    * AI 매칭 시스템 활용 (거리, 비용, 평점, 특화서비스)
    * 3-5개 후보 요양원 선별
  - 👀 요양원 견학 및 상담 동행:
    * 시설 투어 가이드 (각 시설 특징 설명)
    * 원장/간호사와 상담 통역
    * 계약서 및 이용약관 검토
    * 비용 산정 및 협상 대행
  - 📄 입주 준비 및 행정 지원:
    * 입주 서류 작성 도움
    * 입주 준비물 리스트 제공
    * 입주일 조정 및 이사 준비
```

#### **4단계: 사후 관리 및 지속 지원 (Ongoing Support)**
```yaml
서비스 기간: 계약에 따라 (6개월~2년)
주요 업무:
  - 📅 정기 방문 및 모니터링:
    * 월 2-4회 요양원 방문
    * 부모님 건강상태 및 만족도 체크
    * 요양원과의 소통 및 개선사항 논의
  - 👨‍👩‍👧‍👦 가족 소통 지원:
    * 정기 화상통화 주선 (해외 가족과 부모님)
    * 건강상태 리포트 번역 및 전달
    * 응급상황 시 즉시 연락 및 대응
  - 🏥 의료 연계 서비스:
    * 병원 진료 동행 (응급실, 외래진료)
    * 의료진과의 소통 및 통역
    * 처방전 및 치료계획 설명
  - 🎉 특별 행사 지원:
    * 생일, 명절 등 기념일 챙김
    * 가족 방문 시 공항 픽업 및 안내
    * 문화 체험 프로그램 기획
```

### 코디네이터 전문 분야 및 자격 요건

#### **전문 분야별 코디네이터**
```yaml
의료 전문 코디네이터:
  - 간호사, 사회복지사, 요양보호사 자격 보유
  - 의료진과의 전문적 소통 능력
  - 치매, 뇌졸중 등 특정 질환 전문성

법무/행정 전문 코디네이터:  
  - 행정사, 법무사 등 자격 보유
  - 비자, 보험, 행정절차 전문 지식
  - 외국인 관련 법령 숙지

언어 전문 코디네이터:
  - 다국어 구사 능력 (영어, 중국어, 일본어)
  - 번역/통역 자격증 보유
  - 문화적 차이 이해 및 중재 능력

심리 상담 전문 코디네이터:
  - 심리상담사, 사회복지사 자격
  - 가족 갈등 중재 및 심리적 지원
  - 치매 환자 및 가족 상담 전문성
```

### 수익 모델 및 서비스 요금

#### **서비스 패키지별 요금**
```yaml
기본 패키지 (Essential):
  - 기간: 3개월 (입국~입주 완료)
  - 서비스: 1-3단계 포함
  - 요금: 300-500만원
  - 대상: 기본적인 지원만 필요한 경우

프리미엄 패키지 (Premium):
  - 기간: 6개월 (입국~사후관리 6개월)
  - 서비스: 전 단계 포함 + 집중 사후관리
  - 요금: 800-1200만원  
  - 대상: 전문적 케어가 필요한 경우

VIP 패키지 (Concierge):
  - 기간: 1-2년 (장기 사후관리)
  - 서비스: 맞춤형 프리미엄 서비스
  - 요금: 1500-3000만원
  - 대상: 고소득층, 복잡한 상황 케이스
```

### 부가 서비스 (추가 수익원)

#### **전문 상담 서비스**
```yaml
법무 상담:
  - 상속, 재산 관리, 세무 문제
  - 해외 거주자 특화 법적 이슈
  - 시간당 10-20만원

금융 상담:  
  - 해외 송금, 환전, 투자 상담
  - 보험 가입 및 클레임 처리
  - 건별 50-200만원

의료 코디네이션:
  - 전문의 소개 및 예약 대행
  - 건강검진 패키지 기획
  - 건별 30-100만원

부동산 서비스:
  - 임시 거주지 임대차 계약
  - 장기 거주 시 부동산 투자 상담
  - 중개수수료 수익 분배
```

#### **기업 및 기관 연계 서비스**
```yaml
보험회사 연계:
  - 외국인 전용 보험 상품 판매
  - 보험금 청구 대행 서비스
  - 수수료 수익

항공사/여행사 연계:
  - 항공권 예약 대행
  - 가족 방문 시 여행 패키지
  - 수수료 수익

의료기관 연계:
  - 건강검진 패키지 기획
  - 의료관광 서비스 연계
  - 수수료 수익

요양원 연계:
  - 요양원 입주 중개 수수료
  - 시설 개선 컨설팅
  - 매칭 성공 수수료
```

### 코디네이터 품질 관리 시스템

#### **고객 만족도 관리**
```yaml
실시간 피드백 시스템:
  - 서비스 단계별 만족도 조사
  - 모바일 앱을 통한 즉시 피드백
  - 불만 사항 즉시 대응 체계

정기 평가 시스템:
  - 월별 서비스 품질 평가
  - 고객 추천도 조사 (NPS)
  - 코디네이터 성과 평가

개선 시스템:
  - 고객 의견 반영 프로세스
  - 서비스 표준화 및 매뉴얼 업데이트
  - 코디네이터 교육 및 트레이닝
```

### 🔑 실제 공공데이터 API 활용 (발급받은 인증키 기반)

#### **발급받은 API 목록 및 활용 방안**
```yaml
인증키: CCXHQiSSQ0J+RRaadSjmmS7ltxG/tlSVOYMjh45MmGne68ptgGAaAJVJti8nBazSjLemTAyb5gAuj43xq7fTog==
활용기간: 2025-07-16 ~ 2027-07-18

🏥 국민건강보험공단_장기요양기관 검색 서비스:
  활용단계: "3단계 - 요양원 매칭"
  기능: 맞춤형 요양원 추천 (지역/예산/특성별)
  URL: https://apis.data.go.kr/B550928/searchLtcInsttService01

📋 국민건강보험공단_장기요양기관 시설별 상세조회 서비스:
  활용단계: "3단계 - 요양원 상세 정보"
  기능: 시설 규모, 서비스, 요금 상세 조회
  URL: https://apis.data.go.kr/B550928/getLtcInsttDetailInfoService02

⚕️ 건강보험심사평가원_병원정보서비스:
  활용단계: "2단계 - 건강검진", "4단계 - 의료 연계"
  기능: 건강검진 병원 추천, 응급 의료진 연결
  URL: https://apis.data.go.kr/B551182/hospInfoServicev2

💊 국립중앙의료원_전국 약국 정보 조회 서비스:
  활용단계: "2단계 - 생활 정착", "4단계 - 의료 지원"
  기능: 처방전 처리 가능 약국 안내
  URL: https://apis.data.go.kr/B552657/ErmctInsttInfoInqireService

🔍 건강보험심사평가원_요양기관개폐업정보조회서비스:
  활용단계: "3단계 - 신뢰성 검증"
  기능: 요양기관 운영 상태 실시간 확인
  URL: https://apis.data.go.kr/B551182/yadmOpCloInfoService2

🛂 외교부_국가·지역별 입국허가요건:
  활용단계: "1단계 - 입국 전 준비"
  기능: 국가별 비자 요건, 필수 서류 안내
  URL: https://apis.data.go.kr/1262000/EntranceVisaService2
```

#### **단계별 API 연동 활용**

**1단계: 입국 전 준비**
```java
// 외교부 API 활용 - 국가별 입국 요건 조회
public KoreaEntryRequirementResponse getKoreaEntryRequirements(String overseasCountry) {
    // 재외동포 거주국 → 한국 입국 요건 자동 조회
    // 비자 종류, 필수 서류, 체류 기간 정보 제공
    // 대사관/영사관 연락처 자동 매칭
}

// 코디네이터 서비스: 맞춤형 입국 가이드 생성
public PreArrivalGuideResponse createPreArrivalGuide(String country, String purpose) {
    KoreaEntryRequirementResponse requirements = mofaApiService.getKoreaEntryRequirements(country);
    return buildCustomizedGuide(requirements, purpose);
}
```

**2단계: 입국 및 정착 + 건강검진**
```java
// 병원 정보 API 활용 - 건강검진 병원 추천
public List<HospitalInfo> findHealthCheckupHospitals(String region, String language) {
    // 지역 기반 병원 검색
    List<HospitalInfo> hospitals = hospitalApiService.getHospitalsByLocation(sido, sigungu);
    
    // 재외동포 친화적 병원 필터링 (다국어 지원, 국제진료센터 보유)
    return hospitals.stream()
        .filter(h -> h.hasInternationalCenter())
        .filter(h -> h.supportsLanguage(language))
        .collect(Collectors.toList());
}

// 약국 정보 API 활용 - 생활권 내 약국 안내
public List<PharmacyInfo> findNearbyPharmacies(String address) {
    // 임시 거주지 주변 약국 검색
    // 24시간 운영, 다국어 처방전 처리 가능 약국 우선 추천
    return pharmacyApiService.getPharmaciesByLocation(sido, sigungu)
        .stream()
        .sorted(Comparator.comparing(PharmacyInfo::getDistance))
        .collect(Collectors.toList());
}
```

**3단계: 요양원 매칭 (핵심 기능)**
```java
// 장기요양기관 검색 API 활용 - 재외동포 맞춤 추천
public OverseasKoreanNursingFacilityResponse searchForOverseasKoreans(
    OverseasKoreanNursingSearchRequest request) {
    
    // 1. 기본 검색 (지역, 유형별)
    NursingFacilitySearchResponse basicResults = nursingSearchApiService
        .searchNursingFacilities(request.getSidoName(), request.getSigunguName());
    
    // 2. 재외동포 친화성 점수 계산
    List<EnhancedFacilityInfo> enhanced = basicResults.getFacilities().stream()
        .map(facility -> {
            // 공항 접근성, 다국어 지원, 의료진 수준 등 평가
            int score = calculateOverseasFriendlyScore(facility, request);
            
            // 신뢰성 검증 (개폐업 정보 API 활용)
            FacilityReliabilityResponse reliability = facilityStatusApiService
                .validateFacilityReliability(facility.getFacilityCode());
            
            return EnhancedFacilityInfo.builder()
                .basicInfo(facility)
                .overseasFriendlyScore(score)
                .reliabilityInfo(reliability)
                .build();
        })
        .filter(f -> f.getReliabilityInfo().getRiskLevel() != RiskLevel.HIGH)
        .sorted(Comparator.comparing(EnhancedFacilityInfo::getOverseasFriendlyScore).reversed())
        .collect(Collectors.toList());
    
    // 3. 상세 정보 조회 (상위 10개 시설)
    List<CompleteNursingFacilityInfo> completeFacilities = enhanced.stream()
        .limit(10)
        .map(facility -> {
            NursingFacilityDetailResponse detail = nursingDetailApiService
                .getNursingFacilityDetail(facility.getFacilityCode());
            
            return CompleteNursingFacilityInfo.builder()
                .enhancedInfo(facility)
                .detailInfo(detail)
                .countrySpecificAdvice(generateAdvice(request.getOverseasCountry()))
                .build();
        })
        .collect(Collectors.toList());
    
    return OverseasKoreanNursingFacilityResponse.builder()
        .facilities(completeFacilities)
        .totalCount(enhanced.size())
        .searchCriteria(request)
        .build();
}

// 신뢰성 점수 계산 (개폐업 정보 기반)
private int calculateReliabilityScore(FacilityStatusResponse status) {
    int score = 50; // 기본 점수
    
    // 운영 상태별 점수
    switch (status.getBusinessStatus()) {
        case "정상", "운영중": score += 40; break;
        case "휴업": score += 10; break;
        case "폐업", "말소": score = 0; break;
    }
    
    // 운영 기간별 추가 점수 (신뢰성 지표)
    if (status.getOpeningDate() != null) {
        long years = ChronoUnit.YEARS.between(status.getOpeningDate(), LocalDate.now());
        score += Math.min(years * 2, 10);
    }
    
    return Math.min(score, 100);
}
```

**4단계: 사후 관리**
```java
// 통합 의료 네트워크 서비스
public MedicalNetworkResponse buildMedicalNetwork(String facilityCode, String region) {
    // 요양원 정보
    NursingFacilityDetailResponse facility = nursingDetailApiService
        .getNursingFacilityDetail(facilityCode);
    
    // 주변 병원 네트워크
    List<HospitalInfo> nearbyHospitals = hospitalApiService
        .getHospitalsByLocation(region);
    
    // 주변 약국 네트워크  
    List<PharmacyInfo> nearbyPharmacies = pharmacyApiService
        .getPharmaciesByLocation(region);
    
    return MedicalNetworkResponse.builder()
        .centerFacility(facility)
        .partnerHospitals(nearbyHospitals)
        .nearbyPharmacies(nearbyPharmacies)
        .emergencyContacts(buildEmergencyContacts(region))
        .build();
}
```

#### **기술적 우위 및 차별화 요소**
```yaml
✅ 실제 정부 데이터 기반:
  - 가짜 정보 없는 신뢰할 수 있는 데이터
  - 실시간 업데이트되는 운영 상태
  - 정부 인증 시설만 추천

✅ AI 기반 맞춤형 매칭:
  - 재외동포별 특성 고려한 추천 알고리즘
  - 국가별/언어별/문화적 차이 반영
  - 신뢰성 점수 기반 필터링

✅ 원스톱 의료 생태계:
  - 요양원 + 병원 + 약국 통합 정보
  - 응급상황 대응 네트워크 구축
  - 의료진 간 소통 지원

✅ 실시간 신뢰성 검증:
  - 개폐업 상태 자동 확인
  - 위험 시설 사전 필터링
  - 지속적인 모니터링 시스템
```

---

## 📋 API 문서화 전략

### OpenAPI 3.0 기반 문서화

**API 문서화 도구 스택:**
```yaml
OpenAPI Spec: 3.0.3 (최신 버전)
문서 UI: Swagger UI + Redoc (다중 뷰)
코드 생성: OpenAPI Generator
문서 호스팅: GitHub Pages (자동 배포)
API 테스트: Postman + Newman (자동화)
```

### API 문서화 구조

#### 1. OpenAPI 설정 (api-module)
```yaml
# api-module/src/main/resources/application.yml
springdoc:
  api-docs:
    enabled: true
    path: /api-docs
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
    operationsSorter: method
    tagsSorter: alpha
  group-configs:
    - group: 'member-api'
      paths-to-match: '/api/members/**'
    - group: 'facility-api'  
      paths-to-match: '/api/facilities/**'
    - group: 'job-api'
      paths-to-match: '/api/jobs/**'
```

#### 2. API 그룹별 문서화
- **회원 API** (`/api/members/**`)
  - 회원가입, 로그인, 프로필 관리
  - 권한 관리, 탈퇴 처리
  
- **시설 API** (`/api/facilities/**`)
  - 시설 검색, 상세 조회, 등록/수정
  - 지도 연동, 이미지 업로드
  
- **구인구직 API** (`/api/jobs/**`)
  - 구인/구직 공고 CRUD
  - 지원/매칭 관리
  
- **리뷰 API** (`/api/reviews/**`)
  - 리뷰 작성/수정/삭제
  - 평점 집계, 추천 시스템

#### 3. 코드 레벨 문서화
```java
@RestController
@RequestMapping("/api/members")
@Tag(name = "회원 관리", description = "회원 가입, 로그인, 프로필 관리 API")
public class MemberController {

    @Operation(
        summary = "회원 가입",
        description = "새로운 회원을 등록합니다. 이메일 중복 체크를 포함합니다.",
        responses = {
            @ApiResponse(responseCode = "201", description = "회원 가입 성공"),
            @ApiResponse(responseCode = "409", description = "이메일 중복")
        }
    )
    @PostMapping("/register")
    public ResponseEntity<MemberResponse> register(
        @RequestBody @Valid 
        @Schema(description = "회원 가입 요청 정보")
        MemberRegisterRequest request
    ) {
        // 구현 로직
    }
}
```

### API 버저닝 전략

**URL 기반 버저닝:**
```
/api/v1/members/**  (현재 버전)
/api/v2/members/**  (향후 버전)
```

**헤더 기반 버저닝 (선택사항):**
```
Accept: application/vnd.globalcarelink.v1+json
Accept: application/vnd.globalcarelink.v2+json
```

---

## 💰 **자본금 0원 개발 전략**

### **완전 무료 기술 스택 활용**

#### **데이터베이스 & 저장소**
```yaml
개발/운영:
  - SQLite (무제한 무료, 파일 기반)
  - GitHub Repository (파일 저장소, 무료 CDN)
  - 메모리 캐시 (Caffeine, Redis 대신)
  
장점:
  - 설정 간단, 별도 서버 불필요
  - 백업 = 파일 복사
  - 동시 접속 1000명까지 충분
```

#### **무료 배포 서비스**
```yaml
백엔드 배포 옵션:
  1. Railway (월 500시간 무료, 추천)
  2. Render.com (무료 플랜)
  3. fly.io (무료 플랜)
  4. Oracle Cloud Always Free (평생 무료)

프론트엔드 배포:
  1. GitHub Pages (무제한 무료, CDN 포함)
  2. Netlify (월 100GB 무료)
  3. Vercel (무제한 무료)
```

#### **외부 서비스 무료 플랜**
```yaml
이메일: Gmail SMTP (일일 500통)
지도: OpenStreetMap + Leaflet.js (완전 무료)
      카카오맵 (월 30만건 무료)
인증: Google OAuth, 카카오 로그인 (무료)
이미지: 자체 처리 (Java BufferedImage)
SMS: 이메일 인증으로 대체 (비용 절약)
```

### **단계별 확장 계획**

#### **Phase 1: 완전 무료 MVP (0원)**
```yaml
사용자: 100명 이하
기술: SQLite + 메모리 캐시 + 무료 호스팅
비용: $0/월
```

#### **Phase 2: 부분 유료 ($10-20/월)**  
```yaml
조건: 사용자 500명 이상, 수익 발생 시작
업그레이드: PostgreSQL, 안정적 VPS
비용: $10-20/월
```

#### **Phase 3: 본격 확장 ($100+/월)**
```yaml
조건: 월 수익 $500 이상  
업그레이드: Redis, CDN, 전문 모니터링
비용: $100+/월
```

### **개발 우선순위 (무료 중심)**

#### **즉시 개발 (자본금 0원)**
1. SQLite 기반 로컬 개발
2. 핵심 CRUD 기능 구현
3. OpenStreetMap 지도 연동
4. Gmail 이메일 발송
5. GitHub Pages 배포

#### **수익 발생 후 업그레이드**  
1. PostgreSQL 전환
2. Redis 캐시 도입
3. 구글맵 API 추가
4. 전문 호스팅 서비스
5. SMS 알림 서비스
</file>

<file path=".github/workflows/auto-commit.yml">
name: Auto Commit on Development

on:
  workflow_dispatch:  # 수동 트리거
  push:
    branches: [ master, main, develop ]
    paths-ignore:
      - '.github/**'
      - 'README.md'
      - 'docs/**'

jobs:
  auto-commit:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Setup Git
      run: |
        git config --global user.name "Claude Assistant"
        git config --global user.email "claude@anthropic.com"
        
    - name: Check for changes
      id: verify-changes
      run: |
        if [ -n "$(git status --porcelain)" ]; then
          echo "changes=true" >> $GITHUB_OUTPUT
        else
          echo "changes=false" >> $GITHUB_OUTPUT
        fi

    - name: Auto commit development progress
      if: steps.verify-changes.outputs.changes == 'true'
      run: |
        git add .
        git commit -m "🤖 Auto-commit: Development progress update

        - Automated commit from development workflow
        - Files updated during Phase development
        - Generated by Claude Code assistant

        🤖 Generated with [Claude Code](https://claude.ai/code)

        Co-Authored-By: Claude <noreply@anthropic.com>" || echo "No changes to commit"
        
    - name: Push changes
      if: steps.verify-changes.outputs.changes == 'true'
      run: |
        git push origin HEAD:${{ github.ref_name }}
</file>

<file path="docs/phases/phase-1.md">
# Phase 1: 핵심 인프라 구축

## 🎯 개요
**소요기간**: 1-2일  
**예상 토큰**: ~14,000 토큰  
**목표**: Spring Boot 3.3.5 + JDK 21 기반 프로젝트 인프라 완성

---

## 📌 Phase 1-A: 프로젝트 초기 설정

### 구현 대상
- ✅ Gradle 멀티모듈 프로젝트 구조 생성
- ✅ Spring Boot 3.3.5 기본 설정  
- ✅ SQLite 데이터베이스 연결
- ✅ 기본 패키지 구조 생성

### 핵심 파일
```
build.gradle.kts
settings.gradle.kts  
src/main/resources/application.yml
src/main/java/com/globalcarelink/GlobalCareLinkApplication.java
```

### 기술 스택
- **언어**: Java 21 LTS
- **프레임워크**: Spring Boot 3.3.5  
- **빌드**: Gradle 8.x + Kotlin DSL
- **데이터베이스**: SQLite (무료)
- **패키지 구조**: 기능별 단일 모듈

---

## 📌 Phase 1-B: 기본 보안 설정

### 구현 대상  
- ✅ Spring Security 6.x 설정
- ✅ JWT 토큰 기반 인증
- ✅ CORS 설정
- ✅ 기본 예외 처리

### 핵심 파일
```
SecurityConfig.java
JwtTokenProvider.java
GlobalExceptionHandler.java
CustomException.java
```

### 보안 기능
- **인증**: JWT 토큰 기반
- **인가**: 역할별 접근 제어 (5가지 역할)
- **CORS**: React 프론트엔드 연동
- **예외처리**: 통합 에러 응답

---

## 🛠 개발 명령어

### 빌드 및 실행
```bash
# JDK 21 확인
java -version

# 프로젝트 빌드  
./gradlew build

# 개발 서버 실행
./gradlew bootRun --args='--spring.profiles.active=dev'

# 테스트 실행
./gradlew test
```

### 데이터베이스 설정
```bash
# SQLite 데이터베이스 디렉토리 생성
mkdir data

# JPA 자동 DDL로 스키마 생성
# application.yml: spring.jpa.hibernate.ddl-auto=create-drop
```

---

## 📋 확인 사항

### Phase 1-A 완료 체크리스트
- [ ] `./gradlew build` 성공
- [ ] `./gradlew bootRun` 성공  
- [ ] Swagger UI 접속 가능 (`http://localhost:8080/swagger-ui.html`)
- [ ] SQLite 데이터베이스 파일 생성 확인

### Phase 1-B 완료 체크리스트  
- [ ] JWT 토큰 생성/검증 테스트
- [ ] CORS 헤더 응답 확인
- [ ] 401/403 에러 응답 확인
- [ ] 전역 예외 처리 동작 확인

---

## 🎯 다음 단계

**Phase 2-A**: 기본 회원 기능 구현
- Member 엔티티 (5가지 역할)
- 회원가입/로그인 API  
- 비밀번호 암호화
- 기본 CRUD 기능

**체크포인트**: Phase 1 완료 후 Phase 2 진행
</file>

<file path="docs/phases/phase-2.md">
# Phase 2: 회원 관리 시스템

## 🎯 개요
**소요기간**: 2-3일  
**예상 토큰**: ~18,000 토큰  
**목표**: 5가지 역할 기반 회원 관리 시스템 + 국내/해외 사용자 구분

---

## 📌 Phase 2-A: 기본 회원 기능

### 구현 대상
- ✅ Member 엔티티 (5가지 역할 지원)
- ✅ 회원가입/로그인 API
- ✅ 비밀번호 암호화 (BCrypt)
- ✅ 기본 CRUD 기능
- ✅ JWT 토큰 인증 통합

### 엔티티 설계
```java
@Entity
@Table(name = "members")
public class Member extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @Column(nullable = false)
    private String password;
    
    @Column(nullable = false)
    private String name;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private MemberRole role;
    
    @Column(name = "is_job_seeker")
    private Boolean isJobSeeker = false;
    
    private String phoneNumber;
    private String language;      // 언어 선호도
    private String region;        // 지역 정보
    private Boolean isActive = true;
}
```

### 역할 정의 (MemberRole)
```java
public enum MemberRole {
    ADMIN,          // 시스템 관리자
    FACILITY,       // 시설 관리자  
    COORDINATOR,    // 코디네이터
    DOMESTIC_USER,  // 국내 사용자
    OVERSEAS_USER   // 해외 사용자 (재외동포)
}
```

### API 엔드포인트
```
POST /api/auth/register     - 회원가입
POST /api/auth/login        - 로그인  
GET  /api/members/{id}      - 회원 조회
PUT  /api/members/{id}      - 회원 정보 수정
DELETE /api/members/{id}    - 회원 탈퇴
GET  /api/members           - 회원 목록 (관리자)
```

---

## 📌 Phase 2-B: 국내/해외 사용자 구분

### 구현 대상
- ✅ DomesticProfile 엔티티 (국내 사용자 전용)
- ✅ OverseasProfile 엔티티 (해외 사용자 전용)  
- ✅ ProfileService (프로필 관리 로직)
- ✅ 다국어 기본 설정 준비
- ✅ 역할별 프로필 생성 제한

### DomesticProfile 구조
```java
@Entity
@Table(name = "domestic_profiles")
public class DomesticProfile extends BaseEntity {
    @OneToOne(fetch = FetchType.LAZY)
    private Member member;
    
    // 기본 정보
    private LocalDate birthDate;
    private String gender;
    private String address;
    private String postalCode;
    
    // 응급 연락처  
    private String emergencyContactName;
    private String emergencyContactPhone;
    private String emergencyContactRelation;
    
    // 건강 정보
    private String healthInsuranceNumber;
    private Integer ltciGrade;              // 장기요양등급
    private String ltciCertificateNumber;
    
    // 케어 정보
    private String preferredRegion;
    private String careLevel;
    private String specialNeeds;
    private String budgetRange;
    
    // 완성도 추적
    private Integer profileCompletionPercentage = 0;
}
```

### OverseasProfile 구조  
```java
@Entity
@Table(name = "overseas_profiles")
public class OverseasProfile extends BaseEntity {
    @OneToOne(fetch = FetchType.LAZY)
    private Member member;
    
    // 기본 정보
    private LocalDate birthDate;
    private String gender;
    private String overseasAddress;
    private String residenceCountry;        // 필수
    private String residenceCity;
    
    // 여권/비자 정보
    private String passportNumber;
    private LocalDate passportExpiryDate;
    private String visaStatus;
    private LocalDate visaExpiryDate;
    
    // 연락처 (해외/한국)
    private String overseasContactName;
    private String overseasContactPhone;
    private String koreaContactName;
    private String koreaContactPhone;
    
    // 입국 관련
    private String entryPurpose;
    private String expectedStayDuration;
    private String preferredCommunicationMethod;
    private String timeZonePreference;
    
    // 코디네이터 서비스
    private Boolean coordinatorRequired = true;
    
    // 완성도 추적
    private Integer profileCompletionPercentage = 0;
}
```

### 프로필 API 엔드포인트
```
POST /api/profiles/domestic/{memberId}    - 국내 프로필 생성
GET  /api/profiles/domestic/{memberId}    - 국내 프로필 조회  
PUT  /api/profiles/domestic/{memberId}    - 국내 프로필 수정

POST /api/profiles/overseas/{memberId}    - 해외 프로필 생성
GET  /api/profiles/overseas/{memberId}    - 해외 프로필 조회
PUT  /api/profiles/overseas/{memberId}    - 해외 프로필 수정

GET  /api/profiles/domestic?minCompletion=80         - 완성도별 조회
GET  /api/profiles/overseas?country=미국              - 국가별 조회  
GET  /api/profiles/overseas/coordinator-required     - 코디네이터 필요 대상
GET  /api/profiles/overseas/expiring-documents       - 서류 만료 예정자
```

---

## 🔒 보안 기능

### 입력 검증 및 보안
- **입력 Sanitization**: XSS 방지
- **SQL 인젝션 방지**: 패턴 검사  
- **개인정보 마스킹**: 이메일, 전화번호, 여권번호
- **비밀번호 정책**: 8자 이상, 대소문자+숫자+특수문자
- **역할별 접근 제어**: DOMESTIC_USER ↔ OVERSEAS_USER 분리

### 프로필 생성 제한
```java
// 국내 사용자는 해외 프로필 생성 불가
if (member.getRole() == MemberRole.DOMESTIC_USER) {
    throw new CustomException.BadRequest("국내 사용자는 해외 프로필을 생성할 수 없습니다");
}

// 해외 사용자는 국내 프로필 생성 불가
if (member.getRole() == MemberRole.OVERSEAS_USER) {  
    throw new CustomException.BadRequest("해외 사용자는 국내 프로필을 생성할 수 없습니다");
}
```

---

## 📊 프로필 완성도 시스템

### 자동 완성도 계산
- **국내 프로필**: 15개 필드 기준 (기본정보 5개, 연락처 3개, 건강정보 3개, 케어정보 4개)
- **해외 프로필**: 25개 필드 기준 (여권정보, 연락처 분리, 입국정보 추가)
- **완성도 임계값**: 국내 80%, 해외 70%

### 단계별 정보 수집
1. **기본 정보**: 생년월일, 성별, 주소
2. **연락처**: 응급연락처 (해외의 경우 해외+한국 분리)  
3. **건강 정보**: 보험, 장기요양등급
4. **케어 정보**: 선호지역, 예산, 특별 요구사항

---

## 🛠 개발 도구

### 테스트 명령어
```bash
# 회원 기능 테스트
./gradlew :test --tests "*MemberServiceTest"

# 프로필 기능 테스트  
./gradlew :test --tests "*ProfileServiceTest"

# API 통합 테스트
./gradlew :test --tests "*ControllerTest"
```

### API 문서 확인
```bash
# Swagger UI 접속
http://localhost:8080/swagger-ui.html

# OpenAPI 스펙 확인
http://localhost:8080/api-docs
```

---

## 📋 확인 사항

### Phase 2-A 완료 체크리스트
- [ ] 5가지 역할로 회원가입 성공
- [ ] JWT 토큰으로 로그인 성공  
- [ ] 비밀번호 BCrypt 암호화 확인
- [ ] 역할별 권한 접근 제어 동작
- [ ] Swagger API 문서 생성 확인

### Phase 2-B 완료 체크리스트
- [ ] 국내/해외 프로필 생성 분리 동작
- [ ] 프로필 완성도 자동 계산
- [ ] 개인정보 마스킹 처리 확인
- [ ] 서류 만료 예정자 조회 기능
- [ ] 코디네이터 필요 대상 자동 식별

---

## 🎯 다음 단계

**Phase 3-A**: 돌봄지수 체크 시스템
- HealthAssessment 엔티티
- 4개 영역 평가 로직 (걷기, 식사, 배변, 의사소통)  
- ADL 점수 계산
- 종합 케어 등급 산출

**중간 체크포인트**: Phase 2 완료 후 Phase 3 진행
</file>

<file path="docs/phases/phase-3.md">
# Phase 3: 건강 상태 평가 시스템

## 🎯 개요
**소요기간**: 3-4일  
**예상 토큰**: ~22,000 토큰  
**목표**: KB라이프생명 기반 돌봄지수 체크 시스템 + React UI 구현

---

## 📌 Phase 3-A: 돌봄지수 체크 시스템

### 구현 대상
- [ ] HealthAssessment 엔티티
- [ ] 4개 영역 평가 로직 (걷기, 식사, 배변, 의사소통)
- [ ] ADL 점수 계산 알고리즘
- [ ] 종합 케어 등급 산출
- [ ] 장기요양보험 등급 연동

### 엔티티 설계
```java
@Entity
@Table(name = "health_assessments")
public class HealthAssessment extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "member_id", nullable = false)
    private String memberId;
    
    // 기본 정보
    private String gender;
    private Integer birthYear;
    
    // ADL 평가 (1-3점)
    @Column(name = "mobility_level", nullable = false)
    private Integer mobilityLevel;        // 걷기 활동
    
    @Column(name = "eating_level", nullable = false) 
    private Integer eatingLevel;          // 식사 활동
    
    @Column(name = "toilet_level", nullable = false)
    private Integer toiletLevel;          // 배변 활동
    
    @Column(name = "communication_level", nullable = false)
    private Integer communicationLevel;   // 의사소통
    
    // 장기요양보험 정보
    @Column(name = "ltci_grade")
    private Integer ltciGrade;           // 1-5등급, 6(인지지원), 7(모름), 8(없음)
    
    // 돌봄대상자 상태  
    @Column(name = "care_target_status")
    private Integer careTargetStatus;    // 1-4 (생명예후 상태)
    
    // 계산된 결과
    @Column(name = "adl_score")
    private Integer adlScore;            // ADL 점수 (4-12점)
    
    @Column(name = "overall_care_grade")
    private String overallCareGrade;     // 종합 케어 등급
    
    @Column(name = "assessment_date")
    private LocalDateTime assessmentDate;
}
```

### 돌봄지수 평가 기준 (KB라이프생명 기반)

#### 1. 걷기 활동 능력 (care_mobility)
```yaml
등급 1 (독립): 혼자서 가능해요
등급 2 (부분도움): 부분적인 도움이 필요해요 (타인의 부축, 지팡이 이용 등)  
등급 3 (완전도움): 혼자서는 보행이 어려워요 (휠체어 사용 등)
```

#### 2. 식사 활동 능력 (care_eating)
```yaml
등급 1 (독립): 혼자서 가능해요
등급 2 (부분도움): 부분적인 도움이 필요해요 (반찬 집기, 자르기 등 일부 도움)
등급 3 (완전도움): 완전한 도움이 필요해요 (음식을 떠 먹여줌)
```

#### 3. 배변 활동 능력 (care_toilet)  
```yaml
등급 1 (독립): 혼자서 화장실을 이용할 수 있어요
등급 2 (부분도움): 화장실 이용 시 부분적인 도움이 필요해요
등급 3 (완전도움): 완전한 도움이 필요해요 (간이변기, 기저귀 착용 등)
```

#### 4. 의사소통 능력 (care_communication)
```yaml
등급 1 (정상): 정상적으로 가능해요  
등급 2 (부분제한): 때때로 어려워요 (화장실 이용의사 표현 가능)
등급 3 (심각제한): 소통이 어려워요 (화장실 이용의사 표현 잘 못함)
```

### 케어 등급 계산 로직
```java
@Service
public class CareGradeCalculator {
    
    public CareGrade calculateComprehensiveGrade(HealthAssessment assessment) {
        // 1. 기본 ADL 점수 계산 (일상생활수행능력)
        int adlScore = calculateADLScore(assessment);
        
        // 2. 장기요양보험 등급 반영
        int ltciGrade = assessment.getLtciGrade();
        
        // 3. 돌봄대상자 상태 반영  
        int careTargetStatus = assessment.getCareTargetStatus();
        
        // 4. 종합 케어 등급 도출
        return determineOverallCareGrade(adlScore, ltciGrade, careTargetStatus);
    }
    
    private int calculateADLScore(HealthAssessment assessment) {
        int mobility = assessment.getMobilityLevel();    // 1-3
        int eating = assessment.getEatingLevel();        // 1-3  
        int toilet = assessment.getToiletLevel();        // 1-3
        int communication = assessment.getCommunicationLevel(); // 1-3
        
        // 각 영역별 가중치 적용
        return (mobility * 25) + (eating * 20) + (toilet * 30) + (communication * 25);
    }
}
```

### API 엔드포인트
```
POST /api/health-assessments                    - 건강 평가 생성
GET  /api/health-assessments/{memberId}         - 회원별 평가 조회
PUT  /api/health-assessments/{id}               - 평가 정보 수정
POST /api/health-assessments/calculate          - 케어 등급 계산
GET  /api/health-assessments/statistics         - 통계 조회 (관리자)
```

---

## 📌 Phase 3-B: React 체크리스트 UI

### 구현 대상
- [ ] React 18 + TypeScript 프로젝트 설정 확장
- [ ] 건강 상태 체크리스트 폼 컴포넌트
- [ ] 단계별 진행 UI (Step Wizard)
- [ ] 결과 표시 컴포넌트
- [ ] 반응형 모바일 최적화

### 컴포넌트 구조
```typescript
// 건강 상태 체크리스트 컴포넌트
export const HealthAssessmentForm: React.FC = () => {
  const [assessment, setAssessment] = useState<HealthAssessmentData>({
    mobility: null,
    eating: null, 
    toilet: null,
    communication: null,
    ltciGrade: null,
    careTargetStatus: null
  });

  const assessmentQuestions = {
    mobility: {
      title: "걷기 활동 능력",
      options: [
        { value: 1, label: "혼자서 가능해요" },
        { value: 2, label: "부분적인 도움이 필요해요\n(타인의 부축, 지팡이 이용 등)" },
        { value: 3, label: "혼자서는 보행이 어려워요\n(휠체어 사용 등)" }
      ]
    },
    // ... 다른 항목들
  };

  const handleSubmit = async () => {
    const result = await healthAssessmentApi.calculate(assessment);
    // 결과 처리 및 코디네이터 추천
  };
};
```

### UI/UX 기능
- **단계별 진행**: 4단계 Step Wizard (걷기→식사→배변→의사소통)
- **실시간 미리보기**: 선택할 때마다 예상 등급 표시  
- **접근성**: 시각장애인 스크린리더 지원
- **모바일 최적화**: Touch-friendly 버튼 크기
- **다국어 지원**: 한/영/중/일 언어 전환

### 결과 표시 화면
```typescript
export const AssessmentResult: React.FC<{result: CareGradeResult}> = ({result}) => {
  return (
    <div className="assessment-result">
      <div className="result-summary">
        <h2>건강 상태 평가 결과</h2>
        <div className="care-grade-badge">
          <span className="grade">{result.overallCareGrade}</span>
          <span className="score">ADL 점수: {result.adlScore}점</span>
        </div>
      </div>
      
      <div className="recommendations">
        <h3>🎯 매칭된 코디네이터: {result.matchedCoordinators.length}명</h3>
        <h3>🏥 추천 요양시설: {result.recommendedFacilities.length}곳</h3>
        
        <div className="next-steps">
          <button onClick={() => navigate('/coordinator-matching')}>
            코디네이터 매칭 시작
          </button>
          <button onClick={() => navigate('/facility-search')}>
            시설 둘러보기  
          </button>
        </div>
      </div>
    </div>
  );
};
```

---

## 🔗 외부 연동 준비

### 장기요양기관 평가 API 연동
```java
@Component
public class LtciEvaluationApiClient {
    
    @Value("${ltci.evaluation.api.key}")
    private String apiKey;
    
    @Value("${ltci.evaluation.base.url}")  
    private String baseUrl;
    
    public List<FacilityEvaluation> getFacilityEvaluations(String region) {
        // 공공데이터 API 호출
        // 인증키: CCXHQiSSQ0J+RRaadSjmmS7ltxG/tlSVOYMjh45MmGne68ptgGAaAJVJti8nBazSjLemTAyb5gAuj43xq7fTog==
    }
}
```

---

## 📊 통계 및 분석

### 평가 결과 통계
- **케어 등급별 분포**: 1등급(최중증) ~ 6등급(인지지원) 비율
- **지역별 평가 현황**: 시/도별 평가 완료율
- **연령대별 케어 등급**: 60대, 70대, 80대+ 등급 분포  
- **성별 케어 패턴**: 남/여 케어 등급 차이 분석

### 관리자 대시보드 데이터
```java
@RestController
@RequestMapping("/api/admin/health-assessments")
public class HealthAssessmentAdminController {
    
    @GetMapping("/statistics")
    public ResponseEntity<AssessmentStatistics> getStatistics() {
        return ResponseEntity.ok(assessmentStatisticsService.getOverallStatistics());
    }
    
    @GetMapping("/grade-distribution") 
    public ResponseEntity<Map<String, Long>> getCareGradeDistribution() {
        return ResponseEntity.ok(assessmentStatisticsService.getCareGradeDistribution());
    }
}
```

---

## 🛠 개발 도구

### 테스트 명령어
```bash
# 백엔드 건강평가 테스트
./gradlew :test --tests "*HealthAssessmentTest"

# 케어등급 계산 테스트  
./gradlew :test --tests "*CareGradeCalculatorTest"

# 프론트엔드 테스트
cd frontend && npm test HealthAssessmentForm
```

### API 테스트
```bash
# 건강 평가 생성
curl -X POST http://localhost:8080/api/health-assessments \
  -H "Content-Type: application/json" \
  -d '{"memberId":"user123","mobilityLevel":2,"eatingLevel":1,"toiletLevel":2,"communicationLevel":1}'

# 케어 등급 계산
curl -X POST http://localhost:8080/api/health-assessments/calculate \
  -H "Content-Type: application/json"  
  -d '{"adlScore":80,"ltciGrade":3,"careTargetStatus":4}'
```

---

## 📋 확인 사항

### Phase 3-A 완료 체크리스트
- [ ] 4개 영역 건강 평가 로직 구현
- [ ] ADL 점수 계산 알고리즘 검증
- [ ] 장기요양보험 등급 연동 확인
- [ ] 종합 케어 등급 산출 정확성 테스트
- [ ] API 엔드포인트 정상 동작 확인

### Phase 3-B 완료 체크리스트  
- [ ] React 체크리스트 폼 완성
- [ ] 단계별 진행 UI 동작 확인
- [ ] 모바일 반응형 레이아웃 검증
- [ ] 백엔드 API 연동 성공
- [ ] 결과 화면 표시 완료

---

## 🎯 다음 단계

**Phase 4-A**: 코디네이터 프로필 관리  
- CoordinatorProfile 엔티티
- 자기 설정 케어 등급 시스템
- 전문성 및 경력 관리  
- 실시간 가용성 관리

**중간 체크포인트**: Phase 3 완료 후 코디네이터 매칭 시스템 구축
</file>

<file path="docs/phases/phase-4.md">
# Phase 4: 코디네이터 매칭 시스템

## 🎯 개요
**소요기간**: 4-5일  
**예상 토큰**: ~27,000 토큰  
**목표**: AI 기반 코디네이터 자동 매칭 시스템 + 자기 설정 케어 등급 관리

---

## 📌 Phase 4-A: 코디네이터 프로필 관리

### 구현 대상
- [ ] CoordinatorProfile 엔티티
- [ ] 자기 설정 케어 등급 시스템  
- [ ] 전문성 및 경력 관리
- [ ] 실시간 가용성 관리
- [ ] 성과 기반 신뢰도 점수

### 코디네이터 전문 분야별 분류
```yaml
의료 전문 코디네이터:
  - 간호사, 사회복지사, 요양보호사 자격 보유
  - 의료진과의 전문적 소통 능력
  - 치매, 뇌졸중 등 특정 질환 전문성

법무/행정 전문 코디네이터:  
  - 행정사, 법무사 등 자격 보유
  - 비자, 보험, 행정절차 전문 지식
  - 외국인 관련 법령 숙지

언어 전문 코디네이터:
  - 다국어 구사 능력 (영어, 중국어, 일본어)
  - 번역/통역 자격증 보유
  - 문화적 차이 이해 및 중재 능력

심리 상담 전문 코디네이터:
  - 심리상담사, 사회복지사 자격
  - 가족 갈등 중재 및 심리적 지원
  - 치매 환자 및 가족 상담 전문성
```

### 엔티티 설계
```java
@Entity
@Table(name = "coordinator_care_settings")
public class CoordinatorCareSettings extends BaseEntity {
    @Id
    private Long id;
    private String coordinatorId;
    
    // 시스템 자동 산출 등급
    private Integer baseCareLevel;           // 자격증 기반 기본 등급
    private Integer maxCareLevel;            // 경력 기반 최대 등급
    
    // 코디네이터 개인 설정
    @ElementCollection
    private Set<Integer> preferredCareGrades;    // 선호 케어 등급 [1,2,3,4,5,6]
    
    @ElementCollection  
    private Set<Integer> excludedCareGrades;     // 거부 케어 등급 [1,2]
    
    @ElementCollection
    private Set<String> specialtyAreas;         // 전문 분야 ["dementia", "medical"]
    
    // 업무량 설정
    private Integer maxSimultaneousCases;       // 동시 담당 가능 케이스 수
    private Integer preferredCasesPerMonth;     // 월 선호 케이스 수
    
    // 근무 조건 설정
    private Boolean availableWeekends;          // 주말 근무 가능 여부
    private Boolean availableEmergency;         // 응급 상황 대응 가능 여부
    private Set<String> workingRegions;         // 근무 가능 지역
    
    // 성과 기반 조정
    private Double performanceScore;            // 성과 점수 (0.0-5.0)
    private Double customerSatisfaction;        // 고객 만족도 (0.0-5.0)
    private Integer successfulCases;            // 성공 케이스 수
    private Integer totalCases;                 // 총 담당 케이스 수
    
    private LocalDateTime lastUpdated;
}
```

### 자격증 기반 기본 등급 시스템
```yaml
Tier 1 (요양보호사): 
  - 기본 케어 등급: 4-5등급, 인지지원등급
  - 상한선: 3등급까지 가능 (경력 2년+ 시)
  
Tier 2 (간호조무사, 사회복지사):
  - 기본 케어 등급: 2-5등급  
  - 상한선: 1등급까지 가능 (경력 5년+ 시)
  
Tier 3 (간호사, 의료진):
  - 기본 케어 등급: 1-5등급 전체
  - 특수 케어: 호스피스, 의료진 협력 케어
```

### API 엔드포인트
```
GET  /api/coordinators/{coordinatorId}/care-settings       - 케어 설정 조회
PUT  /api/coordinators/{coordinatorId}/care-settings       - 케어 설정 업데이트
POST /api/coordinators/{coordinatorId}/care-grades/preferences  - 선호/거부 등급 설정
GET  /api/coordinators/{coordinatorId}/matching-statistics     - 매칭 성과 통계
POST /api/coordinators/{coordinatorId}/availability            - 실시간 가용성 업데이트
```

---

## 📌 Phase 4-B: AI 기반 매칭 알고리즘

### 구현 대상  
- [ ] 다층 매칭 시스템 (Multi-Layer Matching)
- [ ] 종합 점수 계산 로직
- [ ] 업무량 최적화 분배
- [ ] 매칭 결과 설명 생성
- [ ] 실시간 가용성 반영

### 매칭 알고리즘 구조
```java
@Service
public class OptimizedCoordinatorMatchingService {
    
    public List<CoordinatorMatch> findOptimalMatches(HealthAssessment assessment, 
                                                   MatchingPreference preference) {
        
        // 1단계: 기본 자격 필터링
        List<Coordinator> eligibleCoordinators = filterByBasicQualifications(assessment);
        
        // 2단계: 코디네이터 설정 매칭
        List<Coordinator> settingsMatched = filterByCoordinatorSettings(eligibleCoordinators, assessment);
        
        // 3단계: AI 스코어링 및 최적화
        List<CoordinatorMatch> scoredMatches = calculateOptimalMatches(settingsMatched, assessment);
        
        // 4단계: 실시간 가용성 확인
        return filterByRealTimeAvailability(scoredMatches, preference);
    }
}
```

### 종합 점수 계산 (5.0 만점)
```java
private double calculateComprehensiveMatchScore(Coordinator coordinator, HealthAssessment assessment) {
    double score = 0.0;
    
    // 1. 전문성 매칭 점수 (40%)
    score += calculateSpecialtyMatchScore(coordinator, assessment) * 0.4;
    
    // 2. 경력 및 성과 점수 (25%)
    score += calculateExperienceScore(coordinator) * 0.25;
    
    // 3. 고객 만족도 점수 (20%)
    score += coordinator.getCareSettings().getCustomerSatisfaction() * 0.2;
    
    // 4. 지역 접근성 점수 (10%)
    score += calculateLocationScore(coordinator, assessment) * 0.1;
    
    // 5. 실시간 가용성 보너스 (5%)
    score += calculateAvailabilityBonus(coordinator) * 0.05;
    
    return Math.min(score, 5.0); // 최대 5점
}
```

### 전문성 기반 스마트 매칭
```java
private double calculateSpecialtyMatchScore(Coordinator coordinator, HealthAssessment assessment) {
    double specialtyScore = 0.0;
    Set<String> coordinatorSpecialties = coordinator.getCareSettings().getSpecialtyAreas();
    
    // 치매 전문성 매칭
    if (assessment.getLtciGrade() == 6 || assessment.getCommunicationLevel() == 3) {
        if (coordinatorSpecialties.contains("dementia")) {
            specialtyScore += 2.0;
        }
    }
    
    // 의료 전문성 매칭 (1-2등급, 상태1-2)
    if (assessment.getOverallCareGrade().getLevel() <= 2 || assessment.getCareTargetStatus() <= 2) {
        if (coordinatorSpecialties.contains("medical")) {
            specialtyScore += 2.0;
        }
    }
    
    // 재활 전문성 매칭
    if (assessment.getMobilityLevel() >= 2) {
        if (coordinatorSpecialties.contains("rehabilitation")) {
            specialtyScore += 1.5;
        }
    }
    
    // 다국어 지원 (재외동포)
    if (assessment.isOverseasKorean()) {
        if (coordinatorSpecialties.contains("multilingual")) {
            specialtyScore += 1.0;
        }
    }
    
    return Math.min(specialtyScore, 5.0);
}
```

### 업무량 최적화 분배
```java
@Component
public class CoordinatorWorkloadOptimizer {
    
    public List<CoordinatorMatch> optimizeWorkloadDistribution(List<CoordinatorMatch> matches) {
        return matches.stream()
            .map(match -> {
                Coordinator coordinator = match.getCoordinator();
                double workloadScore = calculateWorkloadScore(coordinator);
                
                // 업무량이 적은 코디네이터에게 가산점
                double adjustedScore = match.getMatchScore() + (workloadScore * 0.3);
                
                return new CoordinatorMatch(coordinator, adjustedScore, 
                    match.getMatchReason() + generateWorkloadReason(workloadScore));
            })
            .sorted(Comparator.comparing(CoordinatorMatch::getMatchScore).reversed())
            .collect(Collectors.toList());
    }
    
    private double calculateWorkloadScore(Coordinator coordinator) {
        CoordinatorCareSettings settings = coordinator.getCareSettings();
        int currentCases = getCurrentActiveCases(coordinator.getId());
        int maxCases = settings.getMaxSimultaneousCases();
        
        // 업무량 비율 계산 (낮을수록 높은 점수)
        double workloadRatio = (double) currentCases / maxCases;
        
        if (workloadRatio >= 1.0) return 0.0;      // 포화 상태
        if (workloadRatio >= 0.8) return 1.0;      // 거의 포화
        if (workloadRatio >= 0.6) return 2.0;      // 적정 수준
        if (workloadRatio >= 0.4) return 3.0;      // 여유 있음
        return 4.0;                                // 매우 여유
    }
}
```

### 지능형 매칭 결과 설명
```java
public class MatchingExplanationGenerator {
    
    public String generateMatchReason(Coordinator coordinator, HealthAssessment assessment) {
        StringBuilder reason = new StringBuilder();
        
        // 전문성 매칭 이유
        if (isSpecialtyMatch(coordinator, assessment)) {
            reason.append("🎯 전문 분야 완벽 매칭: ");
            reason.append(getSpecialtyDescription(coordinator, assessment));
            reason.append("\n");
        }
        
        // 경력 매칭 이유
        int experience = coordinator.getCareSettings().getExperienceYears();
        reason.append("📊 경력: ").append(experience).append("년 (");
        if (experience >= 10) reason.append("최고 전문가");
        else if (experience >= 5) reason.append("숙련 전문가");
        else if (experience >= 2) reason.append("경력자");
        else reason.append("신입");
        reason.append(")\n");
        
        // 성과 이유
        double satisfaction = coordinator.getCareSettings().getCustomerSatisfaction();
        reason.append("⭐ 고객 만족도: ").append(satisfaction).append("/5.0");
        if (satisfaction >= 4.5) reason.append(" (최우수)");
        else if (satisfaction >= 4.0) reason.append(" (우수)");
        else if (satisfaction >= 3.5) reason.append(" (양호)");
        reason.append("\n");
        
        // 가용성 이유
        int currentLoad = getCurrentActiveCases(coordinator.getId());
        int maxLoad = coordinator.getCareSettings().getMaxSimultaneousCases();
        reason.append("⏰ 현재 업무량: ").append(currentLoad).append("/").append(maxLoad);
        if (currentLoad < maxLoad * 0.6) reason.append(" (즉시 배정 가능)");
        else if (currentLoad < maxLoad * 0.8) reason.append(" (배정 가능)");
        else reason.append(" (일정 조율 필요)");
        
        return reason.toString();
    }
}
```

---

## 🎨 React 매칭 결과 UI

### 매칭 결과 컴포넌트
```typescript
export const CoordinatorMatchingResult: React.FC<{matches: CoordinatorMatch[]}> = ({matches}) => {
  const [selectedCoordinator, setSelectedCoordinator] = useState<CoordinatorMatch | null>(null);

  return (
    <div className="coordinator-matching-result">
      <h2>🎯 매칭된 코디네이터 ({matches.length}명)</h2>
      
      <div className="matching-summary">
        <div className="best-match">
          <h3>🏆 최고 매칭 (매칭도: {matches[0].matchScore.toFixed(1)}/5.0)</h3>
          <CoordinatorCard coordinator={matches[0]} />
        </div>
        
        <div className="alternative-matches">
          <h3>📋 다른 추천 코디네이터</h3>
          {matches.slice(1, 4).map((match, index) => (
            <CoordinatorCard key={index} coordinator={match} compact />
          ))}
        </div>
      </div>
      
      <div className="matching-actions">
        <button 
          className="primary-button"
          onClick={() => requestConsultation(matches[0])}
        >
          최고 매칭 코디네이터와 상담 신청
        </button>
        <button 
          className="secondary-button"
          onClick={() => viewAllMatches()}
        >
          전체 매칭 결과 보기 ({matches.length}명)
        </button>
      </div>
    </div>
  );
};

const CoordinatorCard: React.FC<{coordinator: CoordinatorMatch, compact?: boolean}> = ({coordinator, compact = false}) => {
  return (
    <div className={`coordinator-card ${compact ? 'compact' : ''}`}>
      <div className="coordinator-header">
        <div className="coordinator-info">
          <h4>{coordinator.name}</h4>
          <span className="specialties">
            {coordinator.specialtyAreas.map(area => (
              <span key={area} className="specialty-badge">{area}</span>
            ))}
          </span>
        </div>
        <div className="match-score">
          <span className="score">{coordinator.matchScore.toFixed(1)}</span>
          <span className="max-score">/5.0</span>
        </div>
      </div>
      
      {!compact && (
        <div className="coordinator-details">
          <div className="match-reason">
            <h5>🎯 매칭 이유</h5>
            <p>{coordinator.matchReason}</p>
          </div>
          
          <div className="coordinator-stats">
            <div className="stat">
              <span className="stat-label">경력</span>
              <span className="stat-value">{coordinator.experienceYears}년</span>
            </div>
            <div className="stat">
              <span className="stat-label">성공 케이스</span>
              <span className="stat-value">{coordinator.successfulCases}건</span>
            </div>
            <div className="stat">
              <span className="stat-label">만족도</span>
              <span className="stat-value">{coordinator.customerSatisfaction.toFixed(1)}/5.0</span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
```

---

## 📊 성능 모니터링

### 매칭 성공률 추적
```yaml
매칭 성공률 추적:
  - 초기 매칭 성공률: 매칭 후 계약 체결율
  - 장기 만족도: 3개월 후 고객 만족도  
  - 코디네이터 만족도: 업무 부하 적정성
  - 재매칭률: 코디네이터 변경 요청률

실시간 최적화:
  - A/B 테스트: 매칭 알고리즘 성능 비교
  - 머신러닝: 매칭 성공 패턴 학습
  - 피드백 루프: 결과 기반 알고리즘 개선
  - 계절별 조정: 시기별 수요 패턴 반영
```

### 관리자 매칭 통계 API
```java
@RestController
@RequestMapping("/api/admin/coordinator-matching")
public class CoordinatorMatchingAdminController {
    
    @GetMapping("/statistics")
    public ResponseEntity<MatchingStatistics> getMatchingStatistics() {
        return ResponseEntity.ok(matchingStatisticsService.getOverallStatistics());
    }
    
    @GetMapping("/success-rate")
    public ResponseEntity<Map<String, Double>> getMatchingSuccessRate() {
        return ResponseEntity.ok(matchingStatisticsService.getSuccessRateBySpecialty());
    }
    
    @GetMapping("/coordinator-workload")
    public ResponseEntity<List<CoordinatorWorkloadReport>> getCoordinatorWorkload() {
        return ResponseEntity.ok(matchingStatisticsService.getWorkloadReports());
    }
}
```

---

## 🛠 개발 도구

### 테스트 명령어
```bash
# 매칭 알고리즘 테스트
./gradlew :test --tests "*CoordinatorMatchingServiceTest"

# 업무량 최적화 테스트  
./gradlew :test --tests "*WorkloadOptimizerTest"

# 전문성 매칭 테스트
./gradlew :test --tests "*SpecialtyMatchingTest"
```

### 매칭 시뮬레이션 테스트
```bash
# 대량 매칭 테스트
curl -X POST http://localhost:8080/api/coordinator-matching/simulate \
  -H "Content-Type: application/json" \
  -d '{"healthAssessmentId":123,"coordinatorCount":100}'

# 성능 테스트  
./gradlew :test --tests "*MatchingPerformanceTest"
```

---

## 📋 확인 사항

### Phase 4-A 완료 체크리스트
- [ ] 코디네이터 자기 설정 케어 등급 시스템 구현
- [ ] 전문성 및 자격증 기반 등급 자동 산출
- [ ] 실시간 가용성 관리 기능
- [ ] 성과 기반 신뢰도 점수 계산
- [ ] API 엔드포인트 정상 동작 확인

### Phase 4-B 완료 체크리스트  
- [ ] AI 기반 다층 매칭 알고리즘 구현
- [ ] 종합 점수 계산 로직 정확성 검증
- [ ] 업무량 최적화 분배 기능
- [ ] 매칭 결과 설명 생성
- [ ] React 매칭 결과 UI 완성

---

## 🎯 다음 단계

**Phase 5-A**: 시설 등급 및 분류 시스템
- FacilityProfile 엔티티
- 시설 타입별 분류 (양로시설, 요양병원 등)  
- A-E 등급 시스템
- 장기요양기관 평가 API 연동

**중간 체크포인트**: Phase 4 완료 후 시설 관리 시스템 구축
</file>

<file path="docs/phases/phase-5.md">
# Phase 5: 시설 관리 시스템

## 🎯 개요
**소요기간**: 5-6일  
**예상 토큰**: ~26,000 토큰  
**목표**: 장기요양기관 평가 API 연동 + AI 기반 시설-환자 매칭 시스템

---

## 📌 Phase 5-A: 시설 등급 및 분류

### 구현 대상
- [ ] FacilityProfile 엔티티
- [ ] 시설 타입별 분류 (양로시설, 요양병원 등)
- [ ] A-E 등급 시스템 (건강보험심사평가원 기준)
- [ ] 전문 특화 시설 관리
- [ ] 장기요양기관 평가 API 연동

### 시설 타입별 분류 시스템
```yaml
주거복지시설:
  - 양로시설: 65세 이상 노인 공동생활 (등급 불필요)
  - 노인공동생활가정: 소규모 공동주택 (5-9명)
  - 노인복지주택: 독립주거 + 복지서비스

의료복지시설:
  - 노인요양시설: 장기요양 1-5등급 대상 (24시간 케어)
  - 노인요양공동생활가정: 소규모 요양시설 (5-9명)
  - 단기보호시설: 임시보호 서비스 (최대 15일)

의료기관:
  - 요양병원: 의료진 상주, 의료서비스 제공
  - 노인전문병원: 노인 특화 의료서비스
  - 노인요양병원: 장기입원 + 요양서비스

재가복지시설:
  - 방문요양서비스: 가정 방문 케어
  - 주야간보호서비스: 낮/밤 임시보호
  - 단기보호서비스: 가족 휴식 지원
```

### 시설 등급 분류 (건강보험심사평가원 기준)
```yaml
A등급 (최우수):
  - 평가점수: 90점 이상
  - 특징: 최고 수준의 케어 품질, 의료진 우수, 시설 현대화
  - 대상: 1-2등급 중증환자 전문 케어

B등급 (우수):
  - 평가점수: 80-89점  
  - 특징: 양질의 케어 서비스, 안정적 운영
  - 대상: 2-3등급 중등도 환자 적합

C등급 (보통):
  - 평가점수: 70-79점
  - 특징: 기본 케어 서비스 제공, 표준적 운영
  - 대상: 3-5등급 경증환자 적합

D등급 (개선필요):
  - 평가점수: 60-69점
  - 특징: 케어 품질 개선 필요, 운영상 이슈
  - 주의: 매칭 시 신중 검토 필요

E등급 (부적합):
  - 평가점수: 60점 미만
  - 특징: 심각한 품질 문제, 행정처분 이력
  - 제외: 매칭 대상에서 제외 권장
```

### 엔티티 설계
```java
@Entity
@Table(name = "facility_profiles")
public class FacilityProfile extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // 기본 정보
    private String facilityName;
    private String facilityType;           // "양로시설", "노인요양시설", "요양병원" 등
    private String facilityGrade;          // "A", "B", "C", "D", "E"
    private Integer evaluationScore;       // 건강보험심사평가원 점수
    
    // 케어 가능 등급
    @ElementCollection
    private Set<Integer> acceptableCareGrades;  // [1,2,3,4,5,6]
    
    // 전문 분야
    @ElementCollection
    private Set<String> specializations;       // ["dementia", "medical", "rehabilitation"]
    
    // 시설 규모 및 정원
    private Integer totalCapacity;             // 총 정원
    private Integer currentOccupancy;          // 현재 입주자 수
    private Integer availableBeds;             // 가용 침대 수
    
    // 의료진 정보
    private Boolean hasDoctor;                 // 의사 상주 여부
    private Boolean hasNurse24h;               // 24시간 간호사 상주
    private Integer nurseCount;                // 간호사 수
    private Integer caregiverCount;            // 요양보호사 수
    
    // 시설 특징
    private Boolean hasElevator;               // 엘리베이터 보유
    private Boolean hasEmergencySystem;        // 응급시스템 구비
    private Boolean hasRehabilitationRoom;     // 재활실 보유
    private Boolean hasDementiaProgram;        // 치매 프로그램 운영
    
    // 위치 및 접근성
    private String region;                     // 지역 (시/도)
    private String district;                   // 구/군
    private Double latitude;                   // 위도
    private Double longitude;                  // 경도
    private Boolean nearSubway;                // 지하철 접근성
    private Boolean nearHospital;              // 병원 근접성
    
    // 비용 정보
    private Integer monthlyBasicFee;           // 월 기본료
    private Integer admissionFee;              // 입소금
    private Boolean acceptsLtci;               // 장기요양보험 적용
    
    private LocalDateTime lastUpdated;
}
```

### 장기요양기관 평가 API 연동
```java
@Component
public class LtciEvaluationApiClient {
    
    @Value("${ltci.evaluation.api.key}")
    private String apiKey;
    
    @Value("${ltci.evaluation.base.url}")  
    private String baseUrl;
    
    public List<FacilityEvaluationData> getFacilityEvaluations(String region) {
        try {
            String url = baseUrl + "/ltci-evaluations";
            
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "Bearer " + apiKey);
            headers.setContentType(MediaType.APPLICATION_JSON);
            
            UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url)
                    .queryParam("serviceKey", apiKey)
                    .queryParam("region", region)
                    .queryParam("numOfRows", 1000);
            
            ResponseEntity<LtciApiResponse> response = restTemplate.exchange(
                    builder.toUriString(), 
                    HttpMethod.GET, 
                    new HttpEntity<>(headers), 
                    LtciApiResponse.class
            );
            
            return response.getBody().getItems();
            
        } catch (Exception e) {
            log.error("장기요양기관 평가 API 호출 실패: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
}
```

---

## 📌 Phase 5-B: 시설 매칭 및 추천

### 구현 대상  
- [ ] 시설-환자 매칭 로직
- [ ] 코디네이터 시설 전문성 연동
- [ ] 견학 계획 및 평가 시스템
- [ ] 재외동포 맞춤 시설 추천
- [ ] 신뢰성 점수 기반 필터링

### 재외동포 맞춤 시설 매칭
```java
@Service
public class OverseasKoreanFacilityMatchingService {
    
    public OverseasKoreanNursingFacilityResponse searchForOverseasKoreans(
        OverseasKoreanNursingSearchRequest request) {
        
        // 1. 기본 검색 (지역, 유형별)
        List<FacilityProfile> basicResults = facilityRepository
            .findByRegionAndFacilityType(request.getRegion(), request.getFacilityType());
        
        // 2. 재외동포 친화성 점수 계산
        List<EnhancedFacilityInfo> enhanced = basicResults.stream()
            .map(facility -> {
                // 공항 접근성, 다국어 지원, 의료진 수준 등 평가
                int score = calculateOverseasFriendlyScore(facility, request);
                
                // 신뢰성 검증 (개폐업 정보 API 활용)
                FacilityReliabilityResponse reliability = validateFacilityReliability(facility.getId());
                
                return EnhancedFacilityInfo.builder()
                    .basicInfo(facility)
                    .overseasFriendlyScore(score)
                    .reliabilityInfo(reliability)
                    .build();
            })
            .filter(f -> f.getReliabilityInfo().getRiskLevel() != RiskLevel.HIGH)
            .sorted(Comparator.comparing(EnhancedFacilityInfo::getOverseasFriendlyScore).reversed())
            .collect(Collectors.toList());
        
        // 3. 상세 정보 조회 (상위 10개 시설)
        List<CompleteFacilityInfo> completeFacilities = enhanced.stream()
            .limit(10)
            .map(this::enrichWithDetailInfo)
            .collect(Collectors.toList());
        
        return OverseasKoreanNursingFacilityResponse.builder()
            .facilities(completeFacilities)
            .totalCount(enhanced.size())
            .searchCriteria(request)
            .build();
    }
}
```

### 시설 매칭 알고리즘
```java
@Service
public class FacilityMatchingService {
    
    public List<FacilityMatch> findCompatibleFacilities(HealthAssessment assessment, 
                                                       FacilityPreference preference) {
        
        CareGrade careGrade = assessment.getOverallCareGrade();
        
        return facilityRepository.findAll().stream()
            .filter(facility -> isBasicCompatible(facility, careGrade))
            .filter(facility -> hasAvailability(facility))
            .filter(facility -> meetsQualityStandard(facility))
            .map(facility -> calculateFacilityMatch(facility, assessment, preference))
            .sorted(Comparator.comparing(FacilityMatch::getMatchScore).reversed())
            .limit(20)
            .collect(Collectors.toList());
    }
    
    private FacilityMatch calculateFacilityMatch(FacilityProfile facility, 
                                               HealthAssessment assessment, 
                                               FacilityPreference preference) {
        double score = 0.0;
        
        // 1. 시설 등급 점수 (30%)
        score += calculateFacilityGradeScore(facility) * 0.3;
        
        // 2. 전문성 매칭 점수 (25%)
        score += calculateSpecializationScore(facility, assessment) * 0.25;
        
        // 3. 의료진 적합성 점수 (20%)
        score += calculateMedicalStaffScore(facility, assessment) * 0.2;
        
        // 4. 위치 접근성 점수 (15%)
        score += calculateLocationScore(facility, preference) * 0.15;
        
        // 5. 비용 적합성 점수 (10%)
        score += calculateCostScore(facility, preference) * 0.1;
        
        String explanation = generateFacilityMatchExplanation(facility, assessment, score);
        
        return new FacilityMatch(facility, score, explanation);
    }
}
```

### 코디네이터 시설 전문성 연동
```java
@Entity
public class CoordinatorFacilityExpertise {
    @Id
    private Long id;
    private String coordinatorId;
    
    // 시설 타입별 전문성
    @ElementCollection
    private Set<String> expertFacilityTypes;     // ["노인요양시설", "요양병원", "치매전문시설"]
    
    // 시설 등급별 경험
    @ElementCollection
    private Map<String, Integer> facilityGradeExperience; // {"A": 5, "B": 12, "C": 8}
    
    // 지역별 시설 네트워크
    @ElementCollection
    private Set<String> familiarRegions;         // ["서울 강남구", "경기 성남시"]
    
    // 협력 시설 목록
    @ElementCollection
    private Set<Long> partnerFacilities;         // 협력 관계 시설 ID
}
```

---

## 🎨 React 시설 검색 UI

### 시설 검색 컴포넌트
```typescript
export const FacilitySearchPage: React.FC = () => {
  const [searchCriteria, setSearchCriteria] = useState<FacilitySearchCriteria>({
    region: '',
    facilityType: '',
    careGrade: '',
    budget: '',
    specializations: []
  });
  
  const [facilities, setFacilities] = useState<FacilityMatch[]>([]);
  const [loading, setLoading] = useState(false);

  const handleSearch = async () => {
    setLoading(true);
    try {
      const results = await facilityApi.searchFacilities(searchCriteria);
      setFacilities(results);
    } catch (error) {
      toast.error('시설 검색에 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="facility-search-page">
      <div className="search-filters">
        <FacilitySearchFilters 
          criteria={searchCriteria}
          onChange={setSearchCriteria}
          onSearch={handleSearch}
        />
      </div>
      
      <div className="search-results">
        {loading ? (
          <FacilitySearchSkeleton />
        ) : (
          <FacilitySearchResults facilities={facilities} />
        )}
      </div>
    </div>
  );
};

const FacilityCard: React.FC<{facility: FacilityMatch}> = ({facility}) => {
  return (
    <div className="facility-card">
      <div className="facility-header">
        <h3>{facility.facilityName}</h3>
        <div className="facility-grade">
          <span className={`grade-badge grade-${facility.facilityGrade.toLowerCase()}`}>
            {facility.facilityGrade}등급
          </span>
          <span className="match-score">매칭도: {facility.matchScore.toFixed(1)}/5.0</span>
        </div>
      </div>
      
      <div className="facility-info">
        <div className="location">
          <span className="icon">📍</span>
          <span>{facility.region} {facility.district}</span>
        </div>
        <div className="capacity">
          <span className="icon">🏠</span>
          <span>입주 가능: {facility.availableBeds}자리</span>
        </div>
        <div className="cost">
          <span className="icon">💰</span>
          <span>월 이용료: {facility.monthlyBasicFee.toLocaleString()}만원</span>
        </div>
      </div>
      
      <div className="facility-specializations">
        {facility.specializations.map(spec => (
          <span key={spec} className="specialization-badge">{spec}</span>
        ))}
      </div>
      
      <div className="facility-actions">
        <button 
          className="primary-button"
          onClick={() => viewFacilityDetail(facility.id)}
        >
          상세 정보
        </button>
        <button 
          className="secondary-button"
          onClick={() => requestVisit(facility.id)}
        >
          견학 신청
        </button>
      </div>
    </div>
  );
};
```

---

## 📊 시설 평가 및 통계

### 시설 신뢰성 점수 계산
```java
private int calculateReliabilityScore(FacilityProfile facility) {
    int score = 50; // 기본 점수
    
    // 운영 상태별 점수
    switch (facility.getBusinessStatus()) {
        case "정상", "운영중": score += 40; break;
        case "휴업": score += 10; break;
        case "폐업", "말소": score = 0; break;
    }
    
    // 운영 기간별 추가 점수 (신뢰성 지표)
    if (facility.getOpeningDate() != null) {
        long years = ChronoUnit.YEARS.between(facility.getOpeningDate(), LocalDate.now());
        score += Math.min(years * 2, 10);
    }
    
    // 평가 등급별 추가 점수
    switch (facility.getFacilityGrade()) {
        case "A": score += 10; break;
        case "B": score += 5; break;
        case "C": score += 0; break;
        case "D": score -= 5; break;
        case "E": score -= 15; break;
    }
    
    return Math.min(score, 100);
}
```

### API 엔드포인트
```
GET  /api/facilities/search                     - 시설 검색
GET  /api/facilities/{id}                       - 시설 상세 조회
POST /api/facilities/{id}/visit-request         - 견학 신청
GET  /api/facilities/overseas-friendly          - 재외동포 친화 시설
GET  /api/facilities/statistics                 - 시설 통계 (관리자)
POST /api/facilities/batch-update               - 평가 데이터 일괄 업데이트
```

---

## 🛠 개발 도구

### 테스트 명령어
```bash
# 시설 매칭 테스트
./gradlew :test --tests "*FacilityMatchingServiceTest"

# API 연동 테스트  
./gradlew :test --tests "*LtciEvaluationApiClientTest"

# 신뢰성 점수 테스트
./gradlew :test --tests "*FacilityReliabilityTest"
```

### API 데이터 동기화
```bash
# 장기요양기관 평가 데이터 동기화
curl -X POST http://localhost:8080/api/facilities/sync-evaluation-data \
  -H "Authorization: Bearer {admin-token}"

# 개폐업 정보 확인
curl -X POST http://localhost:8080/api/facilities/validate-business-status
```

---

## 📋 확인 사항

### Phase 5-A 완료 체크리스트
- [ ] 시설 타입별 분류 시스템 구현
- [ ] A-E 등급 시스템 적용
- [ ] 장기요양기관 평가 API 연동 성공
- [ ] 전문 특화 시설 관리 기능
- [ ] 신뢰성 점수 계산 로직 검증

### Phase 5-B 완료 체크리스트  
- [ ] 시설-환자 매칭 알고리즘 구현
- [ ] 재외동포 맞춤 시설 추천 기능
- [ ] React 시설 검색 UI 완성
- [ ] 견학 신청 및 평가 시스템
- [ ] 코디네이터 시설 전문성 연동

---

## 🎯 다음 단계

**Phase 6-A**: 공공데이터 API 통합 연동
- 국민건강보험공단 장기요양기관 API
- 건강보험심사평가원 병원정보 API
- 외교부 재외국민 서비스 API
- API 클라이언트 통합 구성

**중간 체크포인트**: Phase 5 완료 후 공공데이터 연동 시스템 구축
</file>

<file path="docs/phases/phase-6.md">
# Phase 6: 공공데이터 API 연동

## 🎯 개요
**소요기간**: 6-7일  
**예상 토큰**: ~18,000 토큰  
**목표**: 정부 공공데이터 API 통합 연동 + 외교부 재외동포 서비스 연계

---

## 📌 Phase 6-A: 기본 API 연동

### 구현 대상
- [ ] 국민건강보험공단 장기요양기관 API
- [ ] 건강보험심사평가원 병원정보 API  
- [ ] 국립중앙의료원 전국 약국 정보 API
- [ ] 요양기관개폐업정보조회 API
- [ ] API 클라이언트 통합 구성

### 발급받은 인증키 목록
```yaml
공통 인증키: CCXHQiSSQ0J+RRaadSjmmS7ltxG/tlSVOYMjh45MmGne68ptgGAaAJVJti8nBazSjLemTAyb5gAuj43xq7fTog==
활용기간: 2025-07-16 ~ 2027-07-18

연동 API 목록:
1. 국민건강보험공단_장기요양기관 검색 서비스
   - URL: https://apis.data.go.kr/B550928/searchLtcInsttService01
   - 기능: 맞춤형 요양원 추천 (지역/예산/특성별)

2. 국민건강보험공단_장기요양기관 시설별 상세조회 서비스  
   - URL: https://apis.data.go.kr/B550928/getLtcInsttDetailInfoService02
   - 기능: 시설 규모, 서비스, 요금 상세 조회

3. 건강보험심사평가원_병원정보서비스
   - URL: https://apis.data.go.kr/B551182/hospInfoServicev2
   - 기능: 건강검진 병원 추천, 응급 의료진 연결

4. 국립중앙의료원_전국 약국 정보 조회 서비스
   - URL: https://apis.data.go.kr/B552657/ErmctInsttInfoInqireService
   - 기능: 처방전 처리 가능 약국 안내

5. 건강보험심사평가원_요양기관개폐업정보조회서비스
   - URL: https://apis.data.go.kr/B551182/yadmOpCloInfoService2
   - 기능: 요양기관 운영 상태 실시간 확인
```

### 통합 API 클라이언트 구조
```java
@Component
public class PublicDataApiClient {
    
    @Value("${public.data.api.key}")
    private String apiKey;
    
    private final RestTemplate restTemplate;
    
    // 장기요양기관 검색
    public List<LtcInstitution> searchLtcInstitutions(LtcSearchRequest request) {
        String url = "https://apis.data.go.kr/B550928/searchLtcInsttService01";
        
        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url)
                .queryParam("serviceKey", apiKey)
                .queryParam("sidoName", request.getSidoName())
                .queryParam("sigunguName", request.getSigunguName())
                .queryParam("facilityType", request.getFacilityType())
                .queryParam("numOfRows", 1000)
                .queryParam("pageNo", 1)
                .queryParam("resultType", "json");
        
        try {
            ResponseEntity<LtcApiResponse> response = restTemplate.exchange(
                    builder.toUriString(), 
                    HttpMethod.GET, 
                    null, 
                    LtcApiResponse.class
            );
            
            return response.getBody().getBody().getItems();
            
        } catch (Exception e) {
            log.error("장기요양기관 검색 API 호출 실패: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    // 장기요양기관 상세 조회
    public LtcInstitutionDetail getLtcInstitutionDetail(String institutionCode) {
        String url = "https://apis.data.go.kr/B550928/getLtcInsttDetailInfoService02";
        
        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url)
                .queryParam("serviceKey", apiKey)
                .queryParam("instCd", institutionCode)
                .queryParam("resultType", "json");
        
        try {
            ResponseEntity<LtcDetailApiResponse> response = restTemplate.exchange(
                    builder.toUriString(), 
                    HttpMethod.GET, 
                    null, 
                    LtcDetailApiResponse.class
            );
            
            return response.getBody().getBody().getItems().get(0);
            
        } catch (Exception e) {
            log.error("장기요양기관 상세 조회 API 호출 실패: {}", e.getMessage(), e);
            return null;
        }
    }
    
    // 병원 정보 조회
    public List<HospitalInfo> searchHospitals(HospitalSearchRequest request) {
        String url = "https://apis.data.go.kr/B551182/hospInfoServicev2/getHospBasisList";
        
        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url)
                .queryParam("serviceKey", apiKey)
                .queryParam("sidoCd", request.getSidoCode())
                .queryParam("sgguCd", request.getSigunguCode())
                .queryParam("numOfRows", 100)
                .queryParam("pageNo", 1)
                .queryParam("_type", "json");
        
        try {
            ResponseEntity<HospitalApiResponse> response = restTemplate.exchange(
                    builder.toUriString(), 
                    HttpMethod.GET, 
                    null, 
                    HospitalApiResponse.class
            );
            
            return response.getBody().getBody().getItems();
            
        } catch (Exception e) {
            log.error("병원 정보 API 호출 실패: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
}
```

### API 응답 데이터 모델
```java
@Data
public class LtcInstitution {
    private String instCd;              // 기관코드
    private String instNm;              // 기관명
    private String sidoNm;              // 시도명
    private String sigunguNm;           // 시군구명
    private String roadAddr;            // 도로명주소
    private String lotnoAddr;           // 지번주소
    private String instDiv;             // 기관구분
    private String instType;            // 기관유형
    private String telno;               // 전화번호
    private String faxno;               // 팩스번호
    private String totCapcty;           // 정원
    private String curCapcty;           // 현원
    private String latitude;            // 위도
    private String longitude;           // 경도
}

@Data
public class LtcInstitutionDetail {
    private String instCd;              // 기관코드
    private String instNm;              // 기관명
    private String estbDt;              // 설립일
    private String adminNm;             // 관리자명
    private String adminTelno;          // 관리자전화번호
    private String medicalStaffCnt;     // 의료진수
    private String nurseStaffCnt;       // 간호인력수
    private String careStaffCnt;        // 요양보호사수
    private String socialWorkerCnt;     // 사회복지사수
    private String facilityGrade;       // 평가등급
    private String evaluationDate;      // 평가일자
    private String monthlyFee;          // 월이용료
    private String admissionFee;        // 입소료
}
```

---

## 📌 Phase 6-B: 외교부 API 연동

### 구현 대상
- [ ] 재외국민 현황 API
- [ ] 영사관/총영사관 정보 API  
- [ ] 재외동포 지원 정책 API
- [ ] 국가별 의료 정보 API
- [ ] 다국어 데이터 처리

### 외교부 API 연동
```java
@Component
public class MofaApiClient {
    
    @Value("${mofa.api.key}")
    private String apiKey;
    
    @Value("${mofa.api.base.url}")
    private String baseUrl;
    
    // 국가별 입국 요건 조회
    public KoreaEntryRequirementResponse getKoreaEntryRequirements(String overseasCountry) {
        String url = baseUrl + "/EntranceVisaService2/getEntryVisaList";
        
        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url)
                .queryParam("serviceKey", apiKey)
                .queryParam("cond[country_nm::]", overseasCountry)
                .queryParam("numOfRows", 10)
                .queryParam("pageNo", 1)
                .queryParam("type", "json");
        
        try {
            ResponseEntity<MofaApiResponse> response = restTemplate.exchange(
                    builder.toUriString(), 
                    HttpMethod.GET, 
                    null, 
                    MofaApiResponse.class
            );
            
            return processEntryRequirements(response.getBody());
            
        } catch (Exception e) {
            log.error("외교부 입국요건 API 호출 실패: {}", e.getMessage(), e);
            return null;
        }
    }
    
    // 재외동포 지원 서비스 조회
    public List<OverseasKoreanSupport> getOverseasKoreanSupports(String country) {
        // 재외동포 대상 지원 정책 및 서비스 조회
        // 의료, 복지, 교육 등 카테고리별 지원 내용
    }
    
    // 영사관 정보 조회  
    public List<ConsulateInfo> getConsulatesByCountry(String country) {
        // 해당 국가 내 한국 영사관/총영사관 정보
        // 연락처, 주소, 업무시간, 제공 서비스
    }
}
```

### 재외동포 서비스 통합
```java
@Service
public class OverseasKoreanService {
    
    private final MofaApiClient mofaApiClient;
    private final PublicDataApiClient publicDataApiClient;
    
    public OverseasKoreanServicePackage createServicePackage(OverseasProfile profile) {
        String country = profile.getResidenceCountry();
        String city = profile.getResidenceCity();
        
        // 1. 입국 요건 조회
        KoreaEntryRequirementResponse entryReq = mofaApiClient.getKoreaEntryRequirements(country);
        
        // 2. 현지 영사관 정보
        List<ConsulateInfo> consulates = mofaApiClient.getConsulatesByCountry(country);
        
        // 3. 재외동포 지원 서비스
        List<OverseasKoreanSupport> supports = mofaApiClient.getOverseasKoreanSupports(country);
        
        // 4. 한국 내 의료 네트워크  
        List<HospitalInfo> koreanHospitals = publicDataApiClient.searchHospitals(
            HospitalSearchRequest.forOverseasKoreans(profile.getPreferredRegionInKorea())
        );
        
        return OverseasKoreanServicePackage.builder()
                .profile(profile)
                .entryRequirements(entryReq)
                .nearbyConsulates(consulates)
                .supportServices(supports)
                .koreanMedicalNetwork(koreanHospitals)
                .build();
    }
}
```

---

## 🔄 데이터 동기화 시스템

### 배치 작업 스케줄러
```java
@Component
public class PublicDataSyncScheduler {
    
    @Scheduled(cron = "0 0 2 * * ?") // 매일 새벽 2시
    public void syncLtcInstitutionData() {
        log.info("장기요양기관 데이터 동기화 시작");
        
        try {
            // 전국 시도별 데이터 수집
            List<String> sidoList = Arrays.asList(
                "서울특별시", "부산광역시", "대구광역시", "인천광역시",
                "광주광역시", "대전광역시", "울산광역시", "세종특별자치시",
                "경기도", "강원특별자치도", "충청북도", "충청남도",
                "전북특별자치도", "전라남도", "경상북도", "경상남도", "제주특별자치도"
            );
            
            int totalSynced = 0;
            for (String sido : sidoList) {
                List<LtcInstitution> institutions = publicDataApiClient.searchLtcInstitutions(
                    LtcSearchRequest.builder().sidoName(sido).build()
                );
                
                for (LtcInstitution inst : institutions) {
                    syncSingleInstitution(inst);
                    totalSynced++;
                }
                
                // API 호출 제한 고려 (1초 대기)
                Thread.sleep(1000);
            }
            
            log.info("장기요양기관 데이터 동기화 완료: {}개 기관", totalSynced);
            
        } catch (Exception e) {
            log.error("데이터 동기화 실패: {}", e.getMessage(), e);
        }
    }
    
    @Scheduled(cron = "0 0 6 * * MON") // 매주 월요일 새벽 6시
    public void syncHospitalData() {
        // 병원 정보 주간 동기화
    }
    
    @Scheduled(cron = "0 0 4 1 * ?") // 매월 1일 새벽 4시
    public void syncOverseasKoreanData() {
        // 재외동포 지원 정책 월간 동기화
    }
}
```

### 데이터 검증 및 품질 관리
```java
@Service
public class PublicDataValidationService {
    
    public DataQualityReport validateLtcInstitutionData() {
        List<FacilityProfile> allFacilities = facilityRepository.findAll();
        
        DataQualityReport report = DataQualityReport.builder()
            .totalRecords(allFacilities.size())
            .build();
        
        for (FacilityProfile facility : allFacilities) {
            // 1. 필수 필드 검증
            if (!StringUtils.hasText(facility.getFacilityName())) {
                report.addError("시설명 누락: " + facility.getId());
            }
            
            // 2. 좌표 유효성 검증
            if (facility.getLatitude() == null || facility.getLongitude() == null) {
                report.addWarning("좌표 정보 누락: " + facility.getFacilityName());
            }
            
            // 3. 연락처 형식 검증
            if (facility.getTelno() != null && !isValidPhoneNumber(facility.getTelno())) {
                report.addError("잘못된 전화번호: " + facility.getFacilityName());
            }
            
            // 4. 중복 데이터 검증
            List<FacilityProfile> duplicates = facilityRepository
                .findByFacilityNameAndRoadAddr(facility.getFacilityName(), facility.getRoadAddr());
            if (duplicates.size() > 1) {
                report.addWarning("중복 시설: " + facility.getFacilityName());
            }
        }
        
        return report;
    }
}
```

---

## 📊 API 통계 및 모니터링

### API 호출 통계 수집
```java
@Component
public class ApiUsageMonitor {
    
    private final MeterRegistry meterRegistry;
    
    public void recordApiCall(String apiName, boolean success, long responseTime) {
        // Micrometer를 통한 메트릭 수집
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("public_data_api_calls")
                .tag("api", apiName)
                .tag("success", String.valueOf(success))
                .register(meterRegistry));
        
        // 성공/실패 카운터
        Counter.builder("public_data_api_calls_total")
                .tag("api", apiName)
                .tag("result", success ? "success" : "failure")
                .register(meterRegistry)
                .increment();
    }
    
    public ApiUsageStatistics getUsageStatistics() {
        return ApiUsageStatistics.builder()
                .ltcApiCalls(getLtcApiCallCount())
                .hospitalApiCalls(getHospitalApiCallCount())
                .mofaApiCalls(getMofaApiCallCount())
                .totalApiCalls(getTotalApiCallCount())
                .successRate(calculateSuccessRate())
                .averageResponseTime(getAverageResponseTime())
                .build();
    }
}
```

### API 엔드포인트
```
GET  /api/public-data/ltc-institutions/search        - 장기요양기관 검색
GET  /api/public-data/ltc-institutions/{code}        - 장기요양기관 상세
GET  /api/public-data/hospitals/search               - 병원 검색
GET  /api/public-data/pharmacies/search              - 약국 검색
POST /api/public-data/sync/ltc-institutions          - 장기요양기관 데이터 동기화
GET  /api/overseas-korean/entry-requirements/{country} - 입국 요건 조회
GET  /api/overseas-korean/consulates/{country}       - 영사관 정보
GET  /api/admin/api-usage/statistics                 - API 사용 통계 (관리자)
```

---

## 🛠 개발 도구

### 테스트 명령어
```bash
# API 클라이언트 테스트
./gradlew :test --tests "*PublicDataApiClientTest"

# 데이터 동기화 테스트  
./gradlew :test --tests "*PublicDataSyncTest"

# 외교부 API 연동 테스트
./gradlew :test --tests "*MofaApiClientTest"
```

### API 테스트 스크립트
```bash
# 장기요양기관 검색 테스트
curl -X GET "http://localhost:8080/api/public-data/ltc-institutions/search?sidoName=서울특별시&sigunguName=강남구" \
  -H "Authorization: Bearer {token}"

# 외교부 API 테스트  
curl -X GET "http://localhost:8080/api/overseas-korean/entry-requirements/미국" \
  -H "Authorization: Bearer {token}"

# 데이터 동기화 실행
curl -X POST "http://localhost:8080/api/public-data/sync/ltc-institutions" \
  -H "Authorization: Bearer {admin-token}"
```

---

## 📋 확인 사항

### Phase 6-A 완료 체크리스트
- [ ] 장기요양기관 검색/상세 API 연동 성공
- [ ] 병원정보 및 약국정보 API 연동 성공
- [ ] 요양기관 개폐업 정보 실시간 연동
- [ ] API 호출 통계 및 모니터링 시스템
- [ ] 데이터 검증 및 품질 관리 체계

### Phase 6-B 완료 체크리스트  
- [ ] 외교부 입국요건 API 연동 성공
- [ ] 재외동포 지원 서비스 정보 연동
- [ ] 영사관 정보 자동 매칭 기능
- [ ] 다국어 데이터 처리 시스템
- [ ] 배치 작업 스케줄러 정상 동작

---

## 🎯 다음 단계

**Phase 7-A**: 챗봇 연동 인터페이스
- 챗봇 호환성 API 엔드포인트
- 세션 관리 시스템
- 프로세스 추적 연동

**중간 체크포인트**: Phase 6 완료 후 챗봇 시스템 연동 준비
</file>

<file path="docs/phases/phase-overview.md">
# LightCare 개발 단계 개요

## 🎯 전체 Phase 요약

| Phase | 제목 | 기간 | 토큰 | 상태 | 주요 기능 |
|-------|------|------|------|------|-----------|
| **Phase 1** | 핵심 인프라 구축 | 1-2일 | 14,000 | ✅ 완료 | Spring Boot + Security + SQLite |
| **Phase 2** | 회원 관리 시스템 | 2-3일 | 18,000 | ✅ 완료 | 5역할 회원 + 국내/해외 프로필 |
| **Phase 3** | 건강 상태 평가 | 3-4일 | 22,000 | 🚧 진행예정 | 돌봄지수 + React 체크리스트 |
| **Phase 4** | 코디네이터 매칭 | 4-5일 | 27,000 | 📋 계획중 | AI 매칭 + 자기설정 시스템 |
| **Phase 5** | 시설 관리 시스템 | 5-6일 | 26,000 | 📋 계획중 | 장기요양기관 API + 시설 매칭 |
| **Phase 6** | 공공데이터 API | 6-7일 | 18,000 | 📋 계획중 | 정부API 연동 + 외교부 API |
| **Phase 7** | 챗봇 연동 | 7일 | 8,000 | 📋 계획중 | 챗봇 인터페이스 |
| **Phase 8** | 프론트엔드 통합 | 8-10일 | 33,000 | 📋 계획중 | React UI + elderberry 디자인 |
| **Phase 9** | 테스트 & 배포 | 11-12일 | 18,000 | 📋 계획중 | 테스트 + CI/CD |

**총 예상 토큰**: ~184,000 토큰  
**개발 기간**: 12일 (2주)

---

## 📌 현재 진행 상황

### ✅ 완료된 Phase

#### Phase 1: 핵심 인프라 구축
- **1-A**: Spring Boot 3.3.5 + JDK 21 프로젝트 설정
- **1-B**: Spring Security 6.x + JWT 인증 시스템

#### Phase 2: 회원 관리 시스템  
- **2-A**: Member 엔티티 + 5가지 역할 (ADMIN, FACILITY, COORDINATOR, DOMESTIC_USER, OVERSEAS_USER)
- **2-B**: DomesticProfile/OverseasProfile + 완성도 추적 시스템

### 🚧 다음 진행 예정

#### Phase 3: 건강 상태 평가 시스템
**핵심 목표**: KB라이프생명 기반 돌봄지수 체크 + React UI
- HealthAssessment 엔티티 (걷기/식사/배변/의사소통 4개 영역)
- ADL 점수 계산 + 종합 케어 등급 산출
- React 체크리스트 폼 + 결과 표시 컴포넌트

---

## 🎯 개발 우선순위

### P0 (Critical) - 반드시 완료
- ✅ Phase 1: 인프라 (완료)
- ✅ Phase 2: 회원 관리 (완료)  
- 🚧 Phase 3: 건강 평가 (진행중)
- 📋 Phase 4: 코디네이터 매칭 (중요)

### P1 (High) - 핵심 기능
- 📋 Phase 5: 시설 관리
- 📋 Phase 6: 공공데이터 API

### P2 (Medium) - 확장 기능  
- 📋 Phase 7: 챗봇 연동
- 📋 Phase 8: 프론트엔드

### P3 (Low) - 품질 향상
- 📋 Phase 9: 테스트 & 배포

---

## 📊 토큰 사용 전략

### 단계별 토큰 배분
```
Phase 1-2 (완료): 32,000 토큰 (17.4%)
Phase 3-4 (핵심): 49,000 토큰 (26.6%) 
Phase 5-6 (확장): 44,000 토큰 (23.9%)
Phase 7-9 (완성): 59,000 토큰 (32.1%)
```

### 일일 권장 사용량
- **1-6일차**: 평균 15,000 토큰/일
- **7-10일차**: 평균 12,000 토큰/일  
- **11-12일차**: 평균 9,000 토큰/일

---

## 🚨 리스크 관리

### 주요 리스크 요소
1. **토큰 초과 사용**: 복잡한 로직 단순화 필요
2. **API 연동 실패**: Mock 데이터로 우선 개발  
3. **시간 부족**: P2/P3 기능 축소 고려
4. **기술적 복잡도**: AI 매칭 알고리즘 단순화

### 완화 전략
- **MVP 우선**: 핵심 기능만 완벽 구현
- **점진적 확장**: Phase별 완료 후 다음 단계
- **백업 플랜**: 각 Phase별 최소 기능 정의
- **실시간 모니터링**: 토큰 사용량 일일 체크

---

## 📁 Phase별 상세 문서

각 Phase별 상세 구현 계획은 별도 문서 참조:

- [📖 Phase 1: 핵심 인프라 구축](./phase-1.md)
- [📖 Phase 2: 회원 관리 시스템](./phase-2.md)  
- [📖 Phase 3: 건강 상태 평가 시스템](./phase-3.md)
- [📖 Phase 4: 코디네이터 매칭 시스템](./phase-4.md)
- [📖 Phase 5: 시설 관리 시스템](./phase-5.md)
- [📖 Phase 6: 공공데이터 API 연동](./phase-6.md)

---

## 🎯 성공 지표

### 기술적 완성도
- [ ] 모든 API 엔드포인트 정상 동작
- [ ] JWT 인증 시스템 완전 구현
- [ ] 5가지 역할별 권한 제어
- [ ] 공공데이터 API 연동 성공
- [ ] React UI 기본 기능 완성

### 비즈니스 로직 완성도  
- [ ] 건강 상태 평가 → 케어 등급 산출
- [ ] 케어 등급 → 코디네이터 매칭  
- [ ] 코디네이터 → 시설 추천
- [ ] 전체 매칭 플로우 연결
- [ ] 재외동포 특화 서비스

### 품질 지표
- [ ] 단위 테스트 커버리지 80% 이상  
- [ ] API 응답 시간 500ms 이하
- [ ] 데이터베이스 정규화 완료
- [ ] 보안 취약점 0개
- [ ] 공공데이터 동기화 자동화

---

## 📅 다음 액션

1. **즉시 시작**: Phase 3-A (건강 상태 평가 시스템)
2. **토큰 모니터링**: 일일 사용량 추적
3. **중간 체크포인트**: Phase 3 완료 후 Phase 4 시작 여부 결정

이 문서를 기반으로 체계적인 개발을 진행하시기 바랍니다.
</file>

<file path="docs/DEVELOPMENT_PLAN.md">
# LightCare 개발 계획서 (토큰 제한 고려)

## 📋 개요

이 문서는 LightCare 프로젝트를 토큰 제한을 고려하여 체계적으로 개발하기 위한 단계별 계획서입니다.

**프로젝트 특성:**
- **개발팀**: 4명 (AI 의존도 100%)
- **기술스택**: JDK 21 + Spring Boot 3.3.5 + React 18
- **개발기간**: 2주 완성 목표
- **예산**: 자본금 0원 (무료 서비스 활용)

---

## 🎯 Phase 1: 핵심 인프라 구축 (1-2일)

### 📌 Phase 1-A: 프로젝트 초기 설정
**예상 토큰**: ~8,000 토큰  
**소요시간**: 반나절

#### 구현 대상
- [ ] Gradle 멀티모듈 프로젝트 구조 생성
- [ ] Spring Boot 3.3.5 기본 설정
- [ ] SQLite 데이터베이스 연결
- [ ] 기본 패키지 구조 생성

#### 핵심 파일
```
build.gradle.kts
settings.gradle.kts
src/main/resources/application.yml
src/main/java/com/example/carelink/CareLinkApplication.java
```

#### AI 프롬프트 예시
```
"JDK 21 + Spring Boot 3.3.5 기반 멀티모듈 Gradle 프로젝트를 생성해주세요. 
모듈 구성: api-module, member-module, facility-module
SQLite 데이터베이스 설정 포함"
```

---

### 📌 Phase 1-B: 기본 보안 설정
**예상 토큰**: ~6,000 토큰  
**소요시간**: 반나절

#### 구현 대상
- [ ] Spring Security 6.x 설정
- [ ] JWT 토큰 기반 인증
- [ ] CORS 설정
- [ ] 기본 예외 처리

#### 핵심 파일
```
SecurityConfig.java
JwtTokenProvider.java
GlobalExceptionHandler.java
```

---

## 🎯 Phase 2: 회원 관리 시스템 (2-3일)

### 📌 Phase 2-A: 기본 회원 기능
**예상 토큰**: ~10,000 토큰  
**소요시간**: 1일

#### 구현 대상
- [ ] Member 엔티티 (5가지 역할 지원)
- [ ] 회원가입/로그인 API
- [ ] 비밀번호 암호화
- [ ] 기본 CRUD 기능

#### 엔티티 설계
```java
@Entity
public class Member {
    private Long id;
    private String email;
    private String password;
    private String name;
    private MemberRole role; // ADMIN, FACILITY, COORDINATOR, DOMESTIC_USER, OVERSEAS_USER
    private Boolean isJobSeeker;
    // 기본 필드들...
}
```

---

### 📌 Phase 2-B: 국내/해외 사용자 구분
**예상 토큰**: ~8,000 토큰  
**소요시간**: 반나절

#### 구현 대상
- [ ] 프로필 엔티티 (국내/해외 구분)
- [ ] 다국어 기본 설정
- [ ] 지역별 접근 권한

---

## 🎯 Phase 3: 건강 상태 평가 시스템 (3-4일)

### 📌 Phase 3-A: 돌봄지수 체크 시스템
**예상 토큰**: ~12,000 토큰  
**소요시간**: 1.5일

#### 구현 대상
- [ ] HealthAssessment 엔티티
- [ ] 4개 영역 평가 로직 (걷기, 식사, 배변, 의사소통)
- [ ] ADL 점수 계산
- [ ] 종합 케어 등급 산출

#### 핵심 클래스
```java
@Entity
public class HealthAssessment {
    private Integer mobilityLevel;      // 1-3
    private Integer eatingLevel;        // 1-3
    private Integer toiletLevel;        // 1-3
    private Integer communicationLevel; // 1-3
    private Integer ltciGrade;          // 장기요양보험 등급
    private String overallCareGrade;    // 종합 케어 등급
}

@Service
public class CareGradeCalculator {
    public CareGrade calculateComprehensiveGrade(HealthAssessment assessment);
}
```

---

### 📌 Phase 3-B: React 체크리스트 UI
**예상 토큰**: ~10,000 토큰  
**소요시간**: 1일

#### 구현 대상
- [ ] React 18 + TypeScript 프로젝트 설정
- [ ] 건강 상태 체크리스트 폼
- [ ] 단계별 진행 UI
- [ ] 결과 표시 컴포넌트

---

## 🎯 Phase 4: 코디네이터 매칭 시스템 (4-5일)

### 📌 Phase 4-A: 코디네이터 프로필 관리
**예상 토큰**: ~15,000 토큰  
**소요시간**: 2일

#### 구현 대상
- [ ] CoordinatorProfile 엔티티
- [ ] 자기 설정 케어 등급 시스템
- [ ] 전문성 및 경력 관리
- [ ] 실시간 가용성 관리

#### 핵심 기능
```java
@Entity
public class CoordinatorCareSettings {
    private Set<Integer> preferredCareGrades;    // 선호 케어 등급
    private Set<Integer> excludedCareGrades;     // 거부 케어 등급
    private Set<String> specialtyAreas;         // 전문 분야
    private Integer maxSimultaneousCases;       // 동시 담당 가능 케이스
}
```

---

### 📌 Phase 4-B: AI 기반 매칭 알고리즘
**예상 토큰**: ~12,000 토큰  
**소요시간**: 1.5일

#### 구현 대상
- [ ] 다층 매칭 시스템
- [ ] 종합 점수 계산 로직
- [ ] 업무량 최적화
- [ ] 매칭 결과 설명 생성

#### 매칭 로직
```java
@Service
public class OptimizedCoordinatorMatchingService {
    // 1. 기본 자격 필터링 (40%)
    // 2. 전문성 매칭 (25%)  
    // 3. 경력 및 성과 (20%)
    // 4. 위치 접근성 (10%)
    // 5. 실시간 가용성 (5%)
}
```

---

## 🎯 Phase 5: 시설 관리 시스템 (5-6일)

### 📌 Phase 5-A: 시설 등급 및 분류
**예상 토큰**: ~14,000 토큰  
**소요시간**: 1.5일

#### 구현 대상
- [ ] FacilityProfile 엔티티
- [ ] 시설 타입별 분류 (양로시설, 요양병원 등)
- [ ] A-E 등급 시스템
- [ ] 전문 특화 시설 관리

---

### 📌 Phase 5-B: 시설 매칭 및 추천
**예상 토큰**: ~12,000 토큰  
**소요시간**: 1일

#### 구현 대상
- [ ] 시설-환자 매칭 로직
- [ ] 코디네이터 시설 전문성 연동
- [ ] 견학 계획 및 평가 시스템

---

## 🎯 Phase 6: 공공데이터 API 연동 (6-7일)

### 📌 Phase 6-A: 기본 API 연동
**예상 토큰**: ~10,000 토큰  
**소요시간**: 1일

#### 구현 대상
- [ ] 국민건강보험공단 장기요양기관 API
- [ ] 건강보험심사평가원 병원정보 API
- [ ] API 클라이언트 구성

#### 인증키 활용
```
CCXHQiSSQ0J+RRaadSjmmS7ltxG/tlSVOYMjh45MmGne68ptgGAaAJVJti8nBazSjLemTAyb5gAuj43xq7fTog==
```

---

### 📌 Phase 6-B: 외교부 API 연동
**예상 토큰**: ~8,000 토큰  
**소요시간**: 반나절

#### 구현 대상
- [ ] 재외국민 서비스 API
- [ ] 국가별 입국 요건 API
- [ ] 다국어 데이터 처리

---

## 🎯 Phase 7: 챗봇 연동 인터페이스 (7일)

### 📌 Phase 7-A: 챗봇 호환성 API
**예상 토큰**: ~8,000 토큰  
**소요시간**: 반나절

#### 구현 대상
- [ ] 챗봇 연동 API 엔드포인트
- [ ] 세션 관리 시스템
- [ ] 프로세스 추적 연동

**주의**: 챗봇 구현체는 다른 팀원이 담당

---

## 🎯 Phase 8: 프론트엔드 통합 (8-10일)

### 📌 Phase 8-A: 메인 UI 구성
**예상 토큰**: ~15,000 토큰  
**소요시간**: 2일

#### 구현 대상
- [ ] 'elderberry' 디자인 시스템
- [ ] 메인 페이지 및 네비게이션
- [ ] 사용자 권한별 UI

---

### 📌 Phase 8-B: 기능별 페이지 구현
**예상 토큰**: ~18,000 토큰  
**소요시간**: 2.5일

#### 구현 대상
- [ ] 건강 체크리스트 페이지
- [ ] 코디네이터 매칭 결과 페이지
- [ ] 시설 검색 및 상세 페이지
- [ ] 사용자 프로필 관리 페이지

---

## 🎯 Phase 9: 테스트 및 최적화 (11-12일)

### 📌 Phase 9-A: 단위 테스트
**예상 토큰**: ~10,000 토큰  
**소요시간**: 1일

#### 구현 대상
- [ ] JUnit 5 테스트 코드
- [ ] MockMvc 통합 테스트
- [ ] 매칭 알고리즘 테스트

---

### 📌 Phase 9-B: 통합 테스트 및 배포
**예상 토큰**: ~8,000 토큰  
**소요시간**: 1일

#### 구현 대상
- [ ] E2E 테스트
- [ ] Railway/Render 배포 설정
- [ ] GitHub Actions CI/CD

---

## 📊 개발 진행 관리

### 토큰 사용량 추적
- **총 예상 토큰**: ~196,000 토큰
- **일일 권장 토큰**: ~14,000 토큰
- **Phase별 토큰 분배**: 균등 분할

### 우선순위 관리
1. **P0 (Critical)**: Phase 1-4 (핵심 기능)
2. **P1 (High)**: Phase 5-6 (시설 관리, API 연동)
3. **P2 (Medium)**: Phase 7-8 (UI, 챗봇 연동)
4. **P3 (Low)**: Phase 9 (테스트, 최적화)

### 체크포인트
- **Day 3**: Phase 2 완료 확인
- **Day 6**: Phase 4 완료 확인
- **Day 9**: Phase 6 완료 확인
- **Day 12**: 전체 시스템 완성

---

## 🚨 리스크 관리

### 주요 리스크
1. **토큰 초과 사용**: 복잡한 로직을 단순화
2. **API 연동 실패**: Mock 데이터로 우선 개발
3. **시간 부족**: P2, P3 기능 축소

### 완화 방안
- Phase별 완료 후 다음 단계 진행
- 핵심 기능 우선 구현 (MVP 접근)
- 실시간 진행 상황 체크

---

## 📝 다음 단계

1. **Phase 1-A 시작**: 프로젝트 초기 설정
2. **토큰 사용량 모니터링** 시작
3. **일일 체크포인트** 설정

이 계획서를 바탕으로 체계적인 개발을 진행하시기 바랍니다.
</file>

<file path="frontend/src/components/ui/Button.tsx">
/**
 * 재사용 가능한 버튼 컴포넌트
 * 'elderberry' 테마 스타일 적용
 */
import React from 'react';
import { motion } from 'framer-motion';
import { Loader2 } from 'lucide-react';
⋮----
interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'care';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  loading?: boolean;
  fullWidth?: boolean;
  onClick?: () => void;
  type?: 'button' | 'submit' | 'reset';
  className?: string;
}
</file>

<file path="frontend/src/components/ui/Card.tsx">
/**
 * 재사용 가능한 카드 컴포넌트
 * 'elderberry' 테마 스타일 적용
 */
import React from 'react';
import { motion } from 'framer-motion';
⋮----
interface CardProps {
  children: React.ReactNode;
  className?: string;
  padding?: 'none' | 'sm' | 'md' | 'lg';
  shadow?: 'none' | 'sm' | 'md' | 'lg';
  hover?: boolean;
  onClick?: () => void;
}
⋮----
const Card: React.FC<CardProps> = ({
  children,
  className = '',
  padding = 'md',
  shadow = 'sm',
  hover = false,
  onClick,
}) =>
⋮----
// === 카드 서브컴포넌트들 ===
⋮----
interface CardHeaderProps {
  children: React.ReactNode;
  className?: string;
}
⋮----
export const CardHeader: React.FC<CardHeaderProps> = ({ 
  children, 
  className = '' 
}) => (
  <div className={`border-b border-elderberry-100 pb-4 mb-4 ${className}`}>
    {children}
  </div>
);
⋮----
interface CardTitleProps {
  children: React.ReactNode;
  className?: string;
}
⋮----
export const CardTitle: React.FC<CardTitleProps> = ({ 
  children, 
  className = '' 
}) => (
  <h3 className={`text-lg font-semibold text-elderberry-900 ${className}`}>
    {children}
  </h3>
);
⋮----
interface CardDescriptionProps {
  children: React.ReactNode;
  className?: string;
}
⋮----
export const CardDescription: React.FC<CardDescriptionProps> = ({ 
  children, 
  className = '' 
}) => (
  <p className={`text-sm text-elderberry-600 mt-1 ${className}`}>
    {children}
  </p>
);
⋮----
interface CardContentProps {
  children: React.ReactNode;
  className?: string;
}
⋮----
export const CardContent: React.FC<CardContentProps> = ({ 
  children, 
  className = '' 
}) => (
  <div className={className}>
    {children}
  </div>
);
⋮----
interface CardFooterProps {
  children: React.ReactNode;
  className?: string;
}
⋮----
export const CardFooter: React.FC<CardFooterProps> = ({ 
  children, 
  className = '' 
}) => (
  <div className={`border-t border-elderberry-100 pt-4 mt-4 ${className}`}>
    {children}
  </div>
);
</file>

<file path="frontend/src/components/ui/ProgressBar.tsx">
/**
 * 진행률 표시 바 컴포넌트
 * 체크리스트 진행 상황 표시용
 */
import React from 'react';
import { motion } from 'framer-motion';
⋮----
interface ProgressBarProps {
  progress: number; // 0-100
  steps?: string[];
  currentStep?: number;
  showPercentage?: boolean;
  showSteps?: boolean;
  className?: string;
}
⋮----
progress: number; // 0-100
⋮----
{/* 진행률 텍스트 */}
⋮----
{/* 진행률 바 */}
⋮----
{/* 단계별 표시 */}
⋮----
{/* 단계 원형 표시 */}
</file>

<file path="frontend/src/components/ui/RadioGroup.tsx">
/**
 * 라디오 버튼 그룹 컴포넌트
 * ADL 평가용 선택 인터페이스
 */
import React from 'react';
import { motion } from 'framer-motion';
⋮----
export interface RadioOption {
  value: string | number;
  label: string;
  description?: string;
  disabled?: boolean;
}
⋮----
interface RadioGroupProps {
  name: string;
  value?: string | number;
  options: RadioOption[];
  onChange: (value: string | number) => void;
  error?: string;
  required?: boolean;
  className?: string;
  direction?: 'vertical' | 'horizontal';
}
⋮----
{/* 커스텀 라디오 버튼 */}
⋮----
{/* 라벨 및 설명 */}
⋮----
{/* 선택 표시 아이콘 */}
⋮----
{/* 에러 메시지 */}
</file>

<file path="frontend/src/features/health/steps/AdditionalInfoStep.tsx">
/**
 * 추가 정보 입력 단계
 * 돌봄상태, 식사형태, 질환정보 등
 */
import React from 'react';
import { motion } from 'framer-motion';
import { FileText, AlertTriangle } from 'lucide-react';
⋮----
import { useHealthAssessmentStore } from '@/stores/healthAssessmentStore';
import { CARE_TARGET_STATUS, MEAL_TYPES } from '@/types/health';
import type { CareTargetStatus, MealType } from '@/types/health';
import RadioGroup, { type RadioOption } from '@/components/ui/RadioGroup';
⋮----
// 돌봄대상자 상태 옵션
⋮----
// 식사형태 옵션
⋮----
{/* 섹션 헤더 */}
⋮----
{/* 돌봄대상자 상태 */}
⋮----
setCareTargetStatus(value as CareTargetStatus);
clearError('careTargetStatus');
⋮----
{/* 식사형태 */}
⋮----
setMealType(value as MealType);
clearError('mealType');
⋮----
{/* 질환 정보 */}
⋮----
{/* 특이사항 및 기타 메모 */}
⋮----
{/* 안내 메시지 */}
</file>

<file path="frontend/src/features/health/steps/AdlCommunicationStep.tsx">
/**
 * ADL 평가 - 의사소통 능력
 * KB라이프생명 기반 인지 및 소통 능력 평가
 */
import React from 'react';
import { motion } from 'framer-motion';
import { MessageCircle, AlertCircle, CheckCircle2, Info } from 'lucide-react';
⋮----
import { useHealthAssessmentStore } from '@/stores/healthAssessmentStore';
import { ADL_OPTIONS } from '@/types/health';
import type { AdlLevel } from '@/types/health';
import RadioGroup, { type RadioOption } from '@/components/ui/RadioGroup';
⋮----
// 의사소통 평가 옵션 변환
⋮----
// 평가 레벨별 상세 설명
function getCommunicationDescription(level: AdlLevel): string
⋮----
// 현재 선택된 레벨에 따른 추가 정보
⋮----
{/* 섹션 헤더 */}
⋮----
{/* 평가 질문 */}
⋮----
{/* 선택된 레벨에 따른 추가 정보 */}
⋮----
{/* 의사소통 영역별 세부 안내 */}
⋮----
{/* 평가 가이드라인 */}
⋮----
{/* 점수 정보 */}
⋮----
{/* 예시 상황 */}
</file>

<file path="frontend/src/features/health/steps/AdlEatingStep.tsx">
/**
 * ADL 평가 - 식사 활동 능력
 * KB라이프생명 기반 식사 능력 평가
 */
import React from 'react';
import { motion } from 'framer-motion';
import { Utensils, AlertCircle, CheckCircle2, Info } from 'lucide-react';
⋮----
import { useHealthAssessmentStore } from '@/stores/healthAssessmentStore';
import { ADL_OPTIONS } from '@/types/health';
import type { AdlLevel } from '@/types/health';
import RadioGroup, { type RadioOption } from '@/components/ui/RadioGroup';
⋮----
// 식사 평가 옵션 변환
⋮----
// 평가 레벨별 상세 설명
function getEatingDescription(level: AdlLevel): string
⋮----
// 현재 선택된 레벨에 따른 추가 정보
⋮----
{/* 섹션 헤더 */}
⋮----
{/* 평가 질문 */}
⋮----
{/* 선택된 레벨에 따른 추가 정보 */}
⋮----
{/* 식사 유형별 세부 안내 */}
⋮----
{/* 평가 가이드라인 */}
⋮----
{/* 점수 정보 */}
⋮----
{/* 예시 상황 */}
</file>

<file path="frontend/src/features/health/steps/AdlMobilityStep.tsx">
/**
 * ADL 평가 - 걷기 활동 능력
 * KB라이프생명 기반 이동성 평가
 */
import React from 'react';
import { motion } from 'framer-motion';
import { Activity, AlertCircle, CheckCircle2 } from 'lucide-react';
⋮----
import { useHealthAssessmentStore } from '@/stores/healthAssessmentStore';
import { ADL_OPTIONS } from '@/types/health';
import type { AdlLevel } from '@/types/health';
import RadioGroup, { type RadioOption } from '@/components/ui/RadioGroup';
⋮----
// 이동성 평가 옵션 변환
⋮----
// 평가 레벨별 상세 설명
function getMobilityDescription(level: AdlLevel): string
⋮----
// 현재 선택된 레벨에 따른 추가 정보
⋮----
{/* 섹션 헤더 */}
⋮----
{/* 평가 질문 */}
⋮----
{/* 선택된 레벨에 따른 추가 정보 */}
⋮----
{/* 평가 가이드라인 */}
⋮----
{/* 점수 정보 */}
⋮----
{/* 예시 상황 */}
</file>

<file path="frontend/src/features/health/steps/AdlToiletStep.tsx">
/**
 * ADL 평가 - 배변 활동 능력
 * KB라이프생명 기반 화장실 이용 능력 평가
 */
import React from 'react';
import { motion } from 'framer-motion';
import { Bath, AlertCircle, CheckCircle2, Info } from 'lucide-react';
⋮----
import { useHealthAssessmentStore } from '@/stores/healthAssessmentStore';
import { ADL_OPTIONS } from '@/types/health';
import type { AdlLevel } from '@/types/health';
import RadioGroup, { type RadioOption } from '@/components/ui/RadioGroup';
⋮----
// 화장실 이용 평가 옵션 변환
⋮----
// 평가 레벨별 상세 설명
function getToiletDescription(level: AdlLevel): string
⋮----
// 현재 선택된 레벨에 따른 추가 정보
⋮----
{/* 섹션 헤더 */}
⋮----
{/* 평가 질문 */}
⋮----
{/* 선택된 레벨에 따른 추가 정보 */}
⋮----
{/* 평가 가이드라인 */}
⋮----
{/* 점수 정보 */}
⋮----
{/* 예시 상황 */}
</file>

<file path="frontend/src/features/health/steps/BasicInfoStep.tsx">
/**
 * 기본 정보 입력 단계
 * 평가 대상자의 기본 정보 수집
 */
import React from 'react';
import { motion } from 'framer-motion';
import { User, Calendar, UserCheck } from 'lucide-react';
⋮----
import { useHealthAssessmentStore } from '@/stores/healthAssessmentStore';
import type { Gender } from '@/types/health';
import RadioGroup from '@/components/ui/RadioGroup';
⋮----
// 성별 옵션
⋮----
// 평가자 관계 옵션
⋮----
// 현재 연도 계산
⋮----
{/* 회원 ID (읽기 전용) */}
⋮----
{/* 성별 선택 */}
⋮----
{/* 출생년도 선택 */}
⋮----
{/* 평가자 이름 */}
⋮----
{/* 평가자와의 관계 */}
⋮----
{/* 안내 메시지 */}
</file>

<file path="frontend/src/features/health/steps/LtciGradeStep.tsx">
/**
 * 장기요양보험 등급 입력 단계
 * 선택사항 - 기존 등급이 있는 경우만
 */
import React from 'react';
import { motion } from 'framer-motion';
import { Shield, Info } from 'lucide-react';
⋮----
import { useHealthAssessmentStore } from '@/stores/healthAssessmentStore';
import { LTCI_GRADES } from '@/types/health';
import type { LtciGrade } from '@/types/health';
import RadioGroup, { type RadioOption } from '@/components/ui/RadioGroup';
⋮----
// 장기요양보험 등급 옵션 변환
⋮----
{/* 섹션 헤더 */}
⋮----
{/* 안내 메시지 */}
⋮----
{/* 등급 선택 */}
⋮----
{/* 선택된 등급 정보 */}
⋮----
{/* 등급별 설명 */}
⋮----
{/* 신청 안내 */}
</file>

<file path="frontend/src/features/health/steps/ReviewStep.tsx">
/**
 * 검토 및 제출 단계
 * 입력된 모든 정보 확인 및 평가 제출
 */
import React, { useState, useMemo } from 'react';
import { motion } from 'framer-motion';
import { 
  CheckCircle2, 
  AlertCircle, 
  User, 
  Activity, 
  Utensils, 
  Bath, 
  MessageCircle,
  Shield,
  FileText,
  Loader2,
  Download
} from 'lucide-react';
⋮----
import { useHealthAssessmentStore } from '@/stores/healthAssessmentStore';
import { HealthAssessmentApi } from '@/services/healthApi';
import { ADL_OPTIONS, LTCI_GRADES, CARE_TARGET_STATUS, MEAL_TYPES } from '@/types/health';
import Button from '@/components/ui/Button';
import Card, { CardHeader, CardTitle, CardContent } from '@/components/ui/Card';
⋮----
interface ReviewStepProps {
  onComplete?: (assessmentId: number) => void;
}
⋮----
// ADL 점수 계산
⋮----
// 케어 등급 예상 (간단한 로직)
⋮----
// 폼 데이터 검증
⋮----
// 평가 제출
const handleSubmit = async () =>
⋮----
// 성공 후 처리
⋮----
// 성공 화면
⋮----
{/* 섹션 헤더 */}
⋮----
{/* 완성도 표시 */}
⋮----
{/* 기본 정보 요약 */}
⋮----
{/* ADL 평가 요약 */}
⋮----
{/* ADL 총점 */}
⋮----
{/* 추가 정보 요약 */}
⋮----
{/* 오류 메시지 */}
⋮----
{/* 제출 버튼 */}
⋮----
{/* 안내 메시지 */}
</file>

<file path="frontend/src/features/health/HealthAssessmentWizard.tsx">
/**
 * 건강 상태 평가 체크리스트 마법사 컴포넌트
 * KB라이프생명 기반 단계별 돌봄지수 평가
 */
import React, { useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ChevronLeft, ChevronRight, AlertCircle, CheckCircle2 } from 'lucide-react';
⋮----
import { useHealthAssessmentStore } from '@/stores/healthAssessmentStore';
import Button from '@/components/ui/Button';
import Card, { CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from '@/components/ui/Card';
import ProgressBar from '@/components/ui/ProgressBar';
⋮----
// 단계별 컴포넌트들
import BasicInfoStep from './steps/BasicInfoStep';
import AdlMobilityStep from './steps/AdlMobilityStep';
import AdlEatingStep from './steps/AdlEatingStep';
import AdlToiletStep from './steps/AdlToiletStep';
import AdlCommunicationStep from './steps/AdlCommunicationStep';
import LtciGradeStep from './steps/LtciGradeStep';
import AdditionalInfoStep from './steps/AdditionalInfoStep';
import ReviewStep from './steps/ReviewStep';
⋮----
interface HealthAssessmentWizardProps {
  onComplete?: (assessmentId: number) => void;
  onCancel?: () => void;
  memberId: string;
}
⋮----
// 초기화 시 로컬 스토리지에서 데이터 복원
⋮----
// 현재 단계 컴포넌트 렌더링
const renderCurrentStep = () =>
⋮----
// 다음 단계 진행 핸들러
const handleNext = () =>
⋮----
// 에러가 있는지 확인
⋮----
{/* 헤더 */}
⋮----
{/* 진행률 표시 */}
⋮----
{/* 메인 카드 */}
⋮----
{/* 에러 표시 */}
⋮----
{/* 현재 단계 컴포넌트 */}
⋮----
{/* 이전 버튼 */}
⋮----
{/* 중간 정보 */}
⋮----
{/* 다음/완료 버튼 */}
⋮----
{/* 하단 액션 버튼들 */}
⋮----
resetForm();
onCancel?.();
⋮----
{/* 도움말 정보 */}
</file>

<file path="frontend/src/services/healthApi.ts">
/**
 * 건강 상태 평가 API 서비스
 */
import axios from 'axios';
import type { 
  HealthAssessment, 
  HealthAssessmentCreateRequest, 
  CareGradeResult 
} from '@/types/health';
⋮----
// 요청 인터셉터: JWT 토큰 자동 추가
⋮----
// 응답 인터셉터: 에러 처리
⋮----
// 토큰 만료 시 로그인 페이지로 리다이렉트
⋮----
export class HealthAssessmentApi
⋮----
/**
   * 새로운 건강 평가 생성
   */
static async createAssessment(request: HealthAssessmentCreateRequest): Promise<HealthAssessment>
⋮----
/**
   * 회원별 최신 건강 평가 조회
   */
static async getLatestAssessment(memberId: string): Promise<HealthAssessment | null>
⋮----
return null; // 평가 기록이 없는 경우
⋮----
/**
   * 회원별 건강 평가 이력 조회
   */
static async getAssessmentHistory(memberId: string): Promise<HealthAssessment[]>
⋮----
/**
   * 건강 평가 수정
   */
static async updateAssessment(
    assessmentId: number, 
    request: Partial<HealthAssessmentCreateRequest>
): Promise<HealthAssessment>
⋮----
/**
   * 케어 등급 재계산
   */
static async calculateCareGrade(assessmentId: number): Promise<CareGradeResult>
⋮----
/**
   * 건강 평가 요약 조회
   */
static async getAssessmentSummary(assessmentId: number): Promise<string>
⋮----
/**
   * 평가 완성도 체크
   */
static async checkCompleteness(assessmentId: number): Promise<
⋮----
/**
   * 건강 평가 삭제 (관리자만)
   */
static async deleteAssessment(assessmentId: number): Promise<void>
</file>

<file path="frontend/src/stores/healthAssessmentStore.ts">
/**
 * 건강 상태 평가 체크리스트 상태 관리
 * Zustand를 사용한 전역 상태 관리
 */
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import type { 
  HealthAssessmentCreateRequest, 
  ChecklistState, 
  ChecklistStep,
  AdlLevel,
  LtciGrade,
  CareTargetStatus,
  MealType,
  Gender 
} from '@/types/health';
⋮----
interface HealthAssessmentStore extends ChecklistState {
  // === 액션 메서드 ===
  
  // 단계 이동
  nextStep: () => void;
  previousStep: () => void;
  goToStep: (stepIndex: number) => void;
  
  // 폼 데이터 업데이트
  updateFormData: (data: Partial<HealthAssessmentCreateRequest>) => void;
  updateAdlScore: (field: keyof Pick<HealthAssessmentCreateRequest, 'mobilityLevel' | 'eatingLevel' | 'toiletLevel' | 'communicationLevel'>, value: AdlLevel) => void;
  
  // 기본 정보 설정
  setBasicInfo: (memberId: string, gender?: Gender, birthYear?: number) => void;
  
  // 추가 정보 설정
  setLtciGrade: (grade?: LtciGrade) => void;
  setCareTargetStatus: (status?: CareTargetStatus) => void;
  setMealType: (type?: MealType) => void;
  setDiseaseTypes: (types: string) => void;
  setNotes: (notes: string) => void;
  
  // 검증 및 완성도
  validateCurrentStep: () => boolean;
  calculateCompletionPercentage: () => number;
  
  // 에러 처리
  setError: (field: string, error: string) => void;
  clearError: (field: string) => void;
  clearAllErrors: () => void;
  
  // 제출 상태
  setSubmitting: (isSubmitting: boolean) => void;
  
  // 초기화
  resetForm: () => void;
  
  // 임시 저장 및 복원
  saveToLocalStorage: () => void;
  loadFromLocalStorage: () => void;
}
⋮----
// === 액션 메서드 ===
⋮----
// 단계 이동
⋮----
// 폼 데이터 업데이트
⋮----
// 기본 정보 설정
⋮----
// 추가 정보 설정
⋮----
// 검증 및 완성도
⋮----
// 에러 처리
⋮----
// 제출 상태
⋮----
// 초기화
⋮----
// 임시 저장 및 복원
⋮----
// === 초기 단계 정의 ===
⋮----
// === 초기 상태 ===
⋮----
// === 로컬 스토리지 키 ===
⋮----
// === 단계 이동 ===
⋮----
// 현재 단계 검증
⋮----
// === 폼 데이터 업데이트 ===
⋮----
// 자동 저장
⋮----
// === 기본 정보 설정 ===
⋮----
// === 추가 정보 설정 ===
⋮----
// === 검증 ===
⋮----
// 필수 ADL 항목 재검증
⋮----
// 필수 필드 80%, 선택 필드 20% 가중치
⋮----
// === 에러 처리 ===
⋮----
// === 제출 상태 ===
⋮----
// === 초기화 ===
⋮----
// === 로컬 스토리지 ===
⋮----
// 24시간 이내 데이터만 복원
</file>

<file path="frontend/src/types/health.ts">
/**
 * 건강 상태 평가 관련 타입 정의
 * KB라이프생명 기반 돌봄지수 체크 시스템
 */
⋮----
// === ADL 평가 레벨 ===
export type AdlLevel = 1 | 2 | 3;
⋮----
export interface AdlOptions {
  1: string;
  2: string;
  3: string;
}
⋮----
// === 장기요양보험 등급 ===
export type LtciGrade = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
⋮----
// === 돌봄대상자 상태 ===
export type CareTargetStatus = 1 | 2 | 3 | 4;
⋮----
// === 식사형태 ===
export type MealType = 1 | 2 | 3;
⋮----
// === 성별 ===
export type Gender = 'MALE' | 'FEMALE' | 'M' | 'F';
⋮----
// === 건강 평가 생성 요청 ===
export interface HealthAssessmentCreateRequest {
  memberId: string;
  gender?: Gender;
  birthYear?: number;
  
  // ADL 평가 (필수)
  mobilityLevel: AdlLevel;
  eatingLevel: AdlLevel;
  toiletLevel: AdlLevel;
  communicationLevel: AdlLevel;
  
  // 추가 평가 항목
  ltciGrade?: LtciGrade;
  careTargetStatus?: CareTargetStatus;
  mealType?: MealType;
  diseaseTypes?: string;
  
  // 추가 정보
  notes?: string;
  assessorName?: string;
  assessorRelation?: string;
}
⋮----
// ADL 평가 (필수)
⋮----
// 추가 평가 항목
⋮----
// 추가 정보
⋮----
// === 건강 평가 응답 ===
export interface HealthAssessment {
  id: number;
  memberId: string;
  gender?: string;
  birthYear?: number;
  
  // ADL 평가
  mobilityLevel: number;
  eatingLevel: number;
  toiletLevel: number;
  communicationLevel: number;
  
  // 계산된 점수
  adlScore: number;
  overallCareGrade: string;
  careGradeLevel: number;
  
  // 추가 평가 항목
  ltciGrade?: number;
  careTargetStatus?: number;
  mealType?: number;
  diseaseTypes?: string;
  
  // 메타 정보
  assessmentDate: string;
  createdAt: string;
  updatedAt: string;
  
  // 비즈니스 로직 결과
  specializedCareType: string;
  estimatedMonthlyCostRange: string;
  
  notes?: string;
  assessorName?: string;
  assessorRelation?: string;
}
⋮----
// ADL 평가
⋮----
// 계산된 점수
⋮----
// 추가 평가 항목
⋮----
// 메타 정보
⋮----
// 비즈니스 로직 결과
⋮----
// === 케어 등급 결과 ===
export interface CareGradeResult {
  gradeLevel: number;
  gradeName: string;
  careType: string;
  description: string;
  recommendedFacilityTypes: string[];
  estimatedMonthlyCost: {
    min: number;
    max: number;
    currency: string;
  };
}
⋮----
// === 체크리스트 UI 상태 ===
export interface ChecklistStep {
  id: string;
  title: string;
  description: string;
  isRequired: boolean;
  isCompleted: boolean;
  validationErrors?: string[];
}
⋮----
export interface ChecklistState {
  currentStep: number;
  totalSteps: number;
  steps: ChecklistStep[];
  formData: Partial<HealthAssessmentCreateRequest>;
  isSubmitting: boolean;
  errors: Record<string, string>;
}
⋮----
// === ADL 평가 옵션 정의 ===
⋮----
// === 장기요양보험 등급 정의 ===
⋮----
// === 돌봄대상자 상태 정의 ===
⋮----
// === 식사형태 정의 ===
</file>

<file path="frontend/src/App.css">
/**
 * 메인 앱 스타일
 * 'elderberry' 테마 기반 글로벌 스타일
 */
⋮----
/* Tailwind CSS 임포트 */
@tailwind base;
@tailwind components;
@tailwind utilities;
⋮----
/* 전역 스타일 */
@layer base {
⋮----
html {
⋮----
body {
⋮----
/* 스크롤바 스타일링 */
::-webkit-scrollbar {
⋮----
::-webkit-scrollbar-track {
⋮----
@apply bg-elderberry-100;
⋮----
::-webkit-scrollbar-thumb {
⋮----
::-webkit-scrollbar-thumb:hover {
⋮----
@apply bg-elderberry-400;
⋮----
/* 컴포넌트 스타일 */
@layer components {
⋮----
/* 폼 요소 기본 스타일 */
.form-input {
⋮----
.form-input:focus {
⋮----
/* 카드 그림자 효과 */
.card-shadow {
⋮----
.card-shadow-lg {
⋮----
/* 버튼 호버 효과 */
.btn-elderberry {
⋮----
.btn-elderberry:hover {
⋮----
/* 그라데이션 배경 */
.gradient-elderberry {
⋮----
/* 애니메이션 클래스 */
.fade-in {
⋮----
.slide-up {
⋮----
.bounce-gentle {
⋮----
/* 유틸리티 스타일 */
@layer utilities {
⋮----
/* 텍스트 그라데이션 */
.text-gradient-elderberry {
⋮----
/* 반응형 그리드 */
.grid-responsive {
⋮----
/* 중앙 정렬 컨테이너 */
.container-center {
⋮----
/* 섹션 패딩 */
.section-padding {
⋮----
/* 애니메이션 정의 */
⋮----
/* 인쇄 스타일 */
⋮----
.no-print {
⋮----
.card-shadow,
⋮----
/* 다크모드 대응 (나중에 추가할 때를 위해) */
⋮----
:root {
⋮----
/* 다크모드 색상 변수들 (필요시 추가) */
⋮----
/* 접근성 개선 */
⋮----
*,
⋮----
/* 포커스 스타일 개선 */
:focus-visible {
⋮----
/* 선택 영역 스타일 */
::selection {
</file>

<file path="frontend/src/main.tsx">
/**
 * React 앱 진입점
 * Vite + React 18 기반
 */
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
⋮----
// 전역 스타일 불러오기
⋮----
// React 18 루트 생성 및 렌더링
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
⋮----
// Vite 환경 변수 타입 정의
interface ImportMetaEnv {
  readonly VITE_API_BASE_URL: string
  readonly VITE_WS_URL: string
  readonly VITE_KAKAO_API_KEY: string
  readonly VITE_USE_FREE_MAP: string
  readonly VITE_GITHUB_REPO_OWNER: string
  readonly VITE_GITHUB_REPO_NAME: string
  readonly VITE_DEV_MODE: string
  readonly VITE_LOG_LEVEL: string
}
⋮----
interface ImportMeta {
  readonly env: ImportMetaEnv
}
</file>

<file path="frontend/postcss.config.js">

</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="frontend/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
⋮----
// https://vitejs.dev/config/
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="src/main/java/com/globalcarelink/auth/dto/LoginRequest.java">
public class LoginRequest {
</file>

<file path="src/main/java/com/globalcarelink/auth/dto/MemberRegisterRequest.java">
public class MemberRegisterRequest {
</file>

<file path="src/main/java/com/globalcarelink/auth/dto/MemberResponse.java">
public class MemberResponse {
⋮----
public static MemberResponse from(Member member) {
return MemberResponse.builder()
.id(member.getId())
.email(member.getEmail())
.name(member.getName())
.phoneNumber(member.getPhoneNumber())
.role(member.getRole())
.isJobSeeker(member.getIsJobSeeker())
.isActive(member.getIsActive())
.language(member.getLanguage())
.region(member.getRegion())
.createdAt(member.getCreatedAt())
.updatedAt(member.getUpdatedAt())
.build();
</file>

<file path="src/main/java/com/globalcarelink/auth/dto/MemberUpdateRequest.java">
public class MemberUpdateRequest {
</file>

<file path="src/main/java/com/globalcarelink/auth/dto/TokenResponse.java">
public class TokenResponse {
⋮----
public static TokenResponse of(String accessToken, Long expiresIn, MemberResponse member) {
return TokenResponse.builder()
.accessToken(accessToken)
.tokenType("Bearer")
.expiresIn(expiresIn)
.member(member)
.build();
</file>

<file path="src/main/java/com/globalcarelink/auth/AuthController.java">
public class AuthController {
⋮----
public ResponseEntity<MemberResponse> register(@RequestBody @Valid MemberRegisterRequest request) {
MemberResponse response = memberService.register(request);
return ResponseEntity.status(HttpStatus.CREATED).body(response);
⋮----
public ResponseEntity<TokenResponse> login(@RequestBody @Valid LoginRequest request) {
TokenResponse response = memberService.login(request);
return ResponseEntity.ok(response);
⋮----
public ResponseEntity<MemberResponse> getCurrentMember(@RequestParam String email) {
MemberResponse response = memberService.findByEmail(email);
</file>

<file path="src/main/java/com/globalcarelink/auth/JwtAuthenticationFilter.java">
public class JwtAuthenticationFilter extends OncePerRequestFilter {
⋮----
protected void doFilterInternal(HttpServletRequest request,
⋮----
String token = resolveToken(request);
⋮----
if (StringUtils.hasText(token) && jwtTokenProvider.validateToken(token)) {
Authentication authentication = jwtTokenProvider.getAuthentication(token);
SecurityContextHolder.getContext().setAuthentication(authentication);
⋮----
filterChain.doFilter(request, response);
⋮----
private String resolveToken(HttpServletRequest request) {
String bearerToken = request.getHeader("Authorization");
⋮----
if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
return bearerToken.substring(7);
</file>

<file path="src/main/java/com/globalcarelink/auth/JwtTokenProvider.java">
public class JwtTokenProvider {
⋮----
protected void init() {
key = Keys.hmacShaKeyFor(secretKey.getBytes());
⋮----
public String createToken(String email, String role) {
Claims claims = Jwts.claims().subject(email).build();
claims.put("role", role);
⋮----
Date now = new Date();
Date validity = new Date(now.getTime() + expiration);
⋮----
return Jwts.builder()
.claims(claims)
.issuedAt(now)
.expiration(validity)
.signWith(key)
.compact();
⋮----
public Authentication getAuthentication(String token) {
Claims claims = getClaims(token);
String email = claims.getSubject();
String role = claims.get("role", String.class);
⋮----
return new UsernamePasswordAuthenticationToken(
⋮----
Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + role))
⋮----
public String getEmail(String token) {
return getClaims(token).getSubject();
⋮----
public boolean validateToken(String token) {
⋮----
getClaims(token);
⋮----
log.debug("Invalid JWT token: {}", e.getMessage());
⋮----
private Claims getClaims(String token) {
return Jwts.parser()
.verifyWith(key)
.build()
.parseSignedClaims(token)
.getPayload();
</file>

<file path="src/main/java/com/globalcarelink/auth/MemberController.java">
public class MemberController {
⋮----
public ResponseEntity<MemberResponse> getMember(@PathVariable Long id) {
MemberResponse response = memberService.findById(id);
return ResponseEntity.ok(response);
⋮----
public ResponseEntity<MemberResponse> updateProfile(
⋮----
MemberResponse response = memberService.updateProfile(id, request);
⋮----
public ResponseEntity<Void> toggleJobSeekerStatus(@PathVariable Long id) {
memberService.toggleJobSeekerStatus(id);
return ResponseEntity.ok().build();
⋮----
public ResponseEntity<Void> deactivate(@PathVariable Long id) {
memberService.deactivate(id);
⋮----
public ResponseEntity<List<MemberResponse>> getMembersByRole(@PathVariable MemberRole role) {
List<MemberResponse> response = memberService.findByRole(role);
⋮----
public ResponseEntity<List<MemberResponse>> getActiveJobSeekers() {
List<MemberResponse> response = memberService.findActiveJobSeekers();
⋮----
public ResponseEntity<Long> countByRole(@PathVariable MemberRole role) {
long count = memberService.countByRole(role);
return ResponseEntity.ok(count);
</file>

<file path="src/main/java/com/globalcarelink/auth/MemberRepository.java">
public interface MemberRepository extends JpaRepository<Member, Long> {
⋮----
Optional<Member> findByEmail(String email);
⋮----
boolean existsByEmail(String email);
⋮----
List<Member> findByRole(MemberRole role);
⋮----
List<Member> findByRoleAndIsActive(MemberRole role, Boolean isActive);
⋮----
List<Member> findByIsJobSeekerAndIsActive(Boolean isJobSeeker, Boolean isActive);
⋮----
List<Member> findByRolesAndIsActive(@Param("roles") List<MemberRole> roles, @Param("isActive") Boolean isActive);
⋮----
List<Member> findActiveByRoleAndRegion(@Param("role") MemberRole role, @Param("region") String region);
⋮----
List<Member> searchByKeyword(@Param("keyword") String keyword);
⋮----
long countByRole(MemberRole role);
⋮----
long countByRoleAndIsActive(MemberRole role, Boolean isActive);
</file>

<file path="src/main/java/com/globalcarelink/common/config/AsyncConfig.java">
public class AsyncConfig implements AsyncConfigurer {
⋮----
public Executor getAsyncExecutor() {
ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
executor.setCorePoolSize(5);
executor.setMaxPoolSize(20);
executor.setQueueCapacity(100);
executor.setKeepAliveSeconds(60);
executor.setThreadNamePrefix("Elderberry-Async-");
executor.setWaitForTasksToCompleteOnShutdown(true);
executor.setAwaitTerminationSeconds(30);
executor.initialize();
⋮----
public Executor matchingTaskExecutor() {
⋮----
executor.setCorePoolSize(3);
executor.setMaxPoolSize(10);
executor.setQueueCapacity(50);
⋮----
executor.setThreadNamePrefix("Matching-Async-");
⋮----
public Executor statisticsTaskExecutor() {
⋮----
executor.setCorePoolSize(2);
executor.setMaxPoolSize(5);
executor.setQueueCapacity(25);
⋮----
executor.setThreadNamePrefix("Statistics-Async-");
⋮----
public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
⋮----
log.error("비동기 작업 실행 중 예외 발생 - 메서드: {}, 파라미터: {}",
method.getName(), objects, throwable);
</file>

<file path="src/main/java/com/globalcarelink/common/config/CacheConfig.java">
public class CacheConfig {
⋮----
public CacheManager cacheManager() {
CaffeineCacheManager cacheManager = new CaffeineCacheManager();
cacheManager.setCaffeine(caffeineCacheBuilder());
cacheManager.setCacheNames(
java.util.List.of(
⋮----
private Caffeine<Object, Object> caffeineCacheBuilder() {
return Caffeine.newBuilder()
.initialCapacity(100)
.maximumSize(1000)
.expireAfterAccess(Duration.ofMinutes(30))
.expireAfterWrite(Duration.ofMinutes(60))
.recordStats();
⋮----
public CacheManager coordinatorMatchCacheManager() {
CaffeineCacheManager cacheManager = new CaffeineCacheManager("coordinator-matches");
cacheManager.setCaffeine(Caffeine.newBuilder()
.initialCapacity(50)
.maximumSize(500)
.expireAfterAccess(Duration.ofMinutes(15))
.expireAfterWrite(Duration.ofMinutes(30))
.recordStats());
⋮----
public CacheManager healthAssessmentCacheManager() {
CaffeineCacheManager cacheManager = new CaffeineCacheManager("health-assessments");
⋮----
.maximumSize(2000)
.expireAfterAccess(Duration.ofMinutes(60))
.expireAfterWrite(Duration.ofHours(2))
⋮----
public CacheManager statisticsCacheManager() {
CaffeineCacheManager cacheManager = new CaffeineCacheManager("matching-statistics");
⋮----
.initialCapacity(10)
.maximumSize(100)
.expireAfterAccess(Duration.ofMinutes(10))
.expireAfterWrite(Duration.ofMinutes(15))
</file>

<file path="src/main/java/com/globalcarelink/common/config/JpaConfig.java">
public class JpaConfig {
</file>

<file path="src/main/java/com/globalcarelink/common/config/LoggingAspect.java">
public class LoggingAspect {
⋮----
private static final org.slf4j.Logger performanceLogger = LoggerFactory.getLogger("performance");
⋮----
public void serviceLayer() {}
⋮----
public void controllerLayer() {}
⋮----
public void repositoryLayer() {}
⋮----
public Object logServiceExecution(ProceedingJoinPoint joinPoint) throws Throwable {
long startTime = System.currentTimeMillis();
String methodName = joinPoint.getSignature().getName();
String className = joinPoint.getTarget().getClass().getSimpleName();
⋮----
Object[] args = joinPoint.getArgs();
String sanitizedArgs = sanitizeArgs(args);
⋮----
log.debug("서비스 메서드 시작: {}.{} - 파라미터: {}", className, methodName, sanitizedArgs);
⋮----
Object result = joinPoint.proceed();
⋮----
long duration = System.currentTimeMillis() - startTime;
log.debug("서비스 메서드 완료: {}.{} - 실행시간: {}ms", className, methodName, duration);
⋮----
performanceLogger.info("느린 서비스 메서드: {}.{} - {}ms", className, methodName, duration);
⋮----
log.error("서비스 메서드 오류: {}.{} - 실행시간: {}ms, 오류: {}",
className, methodName, duration, e.getMessage(), e);
⋮----
public Object logControllerExecution(ProceedingJoinPoint joinPoint) throws Throwable {
⋮----
log.info("컨트롤러 메서드 시작: {}.{} - 파라미터: {}", className, methodName, sanitizedArgs);
⋮----
log.info("컨트롤러 메서드 완료: {}.{} - 실행시간: {}ms", className, methodName, duration);
⋮----
log.error("컨트롤러 메서드 오류: {}.{} - 실행시간: {}ms, 오류: {}",
⋮----
public void logException(JoinPoint joinPoint, Throwable ex) {
⋮----
log.error("예외 발생: {}.{} - 예외타입: {}, 메시지: {}",
className, methodName, ex.getClass().getSimpleName(), ex.getMessage());
⋮----
if (ex.getCause() != null) {
log.error("원인: {}", ex.getCause().getMessage());
⋮----
public Object logRepositoryExecution(ProceedingJoinPoint joinPoint) throws Throwable {
⋮----
log.debug("Repository 메서드 시작: {}.{}", className, methodName);
⋮----
log.debug("Repository 메서드 완료: {}.{} - 실행시간: {}ms", className, methodName, duration);
⋮----
performanceLogger.warn("느린 DB 쿼리: {}.{} - {}ms", className, methodName, duration);
⋮----
log.error("Repository 메서드 오류: {}.{} - 실행시간: {}ms, 오류: {}",
className, methodName, duration, e.getMessage());
⋮----
private String sanitizeArgs(Object[] args) {
⋮----
return Arrays.stream(args)
.map(this::sanitizeArg)
.reduce((a, b) -> a + ", " + b)
.map(s -> "[" + s + "]")
.orElse("[]");
⋮----
private String sanitizeArg(Object arg) {
⋮----
String argString = arg.toString();
⋮----
if (argString.toLowerCase().contains("password")) {
⋮----
if (argString.length() > 100) {
return argString.substring(0, 97) + "...";
</file>

<file path="src/main/java/com/globalcarelink/common/config/LoggingFilter.java">
public class LoggingFilter extends OncePerRequestFilter {
⋮----
protected void doFilterInternal(HttpServletRequest request,
⋮----
long startTime = System.currentTimeMillis();
⋮----
setupMDC(request);
⋮----
log.info("요청 시작: {} {}", request.getMethod(), request.getRequestURI());
⋮----
filterChain.doFilter(request, response);
⋮----
long duration = System.currentTimeMillis() - startTime;
⋮----
log.info("요청 완료: {} {} - 응답코드: {}, 처리시간: {}ms",
request.getMethod(),
request.getRequestURI(),
response.getStatus(),
⋮----
log.warn("느린 요청 감지: {}ms - {} {}", duration, request.getMethod(), request.getRequestURI());
⋮----
clearMDC();
⋮----
private void setupMDC(HttpServletRequest request) {
String traceId = UUID.randomUUID().toString().substring(0, 8);
MDC.put(TRACE_ID, traceId);
MDC.put(REQUEST_URI, request.getRequestURI());
MDC.put(METHOD, request.getMethod());
MDC.put(CLIENT_IP, getClientIpAddress(request));
⋮----
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
if (authentication != null && authentication.isAuthenticated() &&
!"anonymousUser".equals(authentication.getName())) {
⋮----
String userEmail = authentication.getName();
MDC.put(USER_EMAIL, userEmail);
MDC.put(USER_ID, extractUserId(userEmail));
⋮----
private void clearMDC() {
MDC.remove(TRACE_ID);
MDC.remove(USER_ID);
MDC.remove(USER_EMAIL);
MDC.remove(REQUEST_URI);
MDC.remove(METHOD);
MDC.remove(CLIENT_IP);
⋮----
private String getClientIpAddress(HttpServletRequest request) {
String xForwardedFor = request.getHeader("X-Forwarded-For");
if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
return xForwardedFor.split(",")[0].trim();
⋮----
String xRealIp = request.getHeader("X-Real-IP");
if (xRealIp != null && !xRealIp.isEmpty()) {
⋮----
return request.getRemoteAddr();
⋮----
private String extractUserId(String email) {
return email != null ? email.split("@")[0] : "unknown";
</file>

<file path="src/main/java/com/globalcarelink/common/entity/BaseEntity.java">
public abstract class BaseEntity {
</file>

<file path="src/main/java/com/globalcarelink/common/exception/CustomException.java">
public class CustomException extends RuntimeException {
⋮----
public static class Unauthorized extends CustomException {
⋮----
public static class Forbidden extends CustomException {
⋮----
public static class NotFound extends CustomException {
⋮----
public static class BadRequest extends CustomException {
⋮----
public static class Conflict extends CustomException {
</file>

<file path="src/main/java/com/globalcarelink/common/util/DateUtil.java">
public final class DateUtil {
⋮----
public static final ZoneId KOREA_ZONE = ZoneId.of("Asia/Seoul");
public static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd");
public static final DateTimeFormatter DATETIME_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
public static final DateTimeFormatter TIMESTAMP_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS");
public static final DateTimeFormatter KOREAN_DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy년 MM월 dd일", Locale.KOREAN);
public static final DateTimeFormatter KOREAN_DATETIME_FORMAT = DateTimeFormatter.ofPattern("yyyy년 MM월 dd일 HH시 mm분", Locale.KOREAN);
⋮----
public static LocalDateTime now() {
return LocalDateTime.now(KOREA_ZONE);
⋮----
public static LocalDate today() {
return LocalDate.now(KOREA_ZONE);
⋮----
public static String formatDate(LocalDate date) {
return date != null ? date.format(DATE_FORMAT) : null;
⋮----
public static String formatDateTime(LocalDateTime dateTime) {
return dateTime != null ? dateTime.format(DATETIME_FORMAT) : null;
⋮----
public static String formatKoreanDate(LocalDate date) {
return date != null ? date.format(KOREAN_DATE_FORMAT) : null;
⋮----
public static String formatKoreanDateTime(LocalDateTime dateTime) {
return dateTime != null ? dateTime.format(KOREAN_DATETIME_FORMAT) : null;
⋮----
public static LocalDate parseDate(String dateString) {
⋮----
return LocalDate.parse(dateString, DATE_FORMAT);
⋮----
throw new IllegalArgumentException("날짜 형식이 올바르지 않습니다: " + dateString, e);
⋮----
public static LocalDateTime parseDateTime(String dateTimeString) {
⋮----
return LocalDateTime.parse(dateTimeString, DATETIME_FORMAT);
⋮----
throw new IllegalArgumentException("날짜시간 형식이 올바르지 않습니다: " + dateTimeString, e);
⋮----
public static long daysBetween(LocalDate startDate, LocalDate endDate) {
return ChronoUnit.DAYS.between(startDate, endDate);
⋮----
public static long hoursBetween(LocalDateTime startDateTime, LocalDateTime endDateTime) {
return ChronoUnit.HOURS.between(startDateTime, endDateTime);
⋮----
public static long minutesBetween(LocalDateTime startDateTime, LocalDateTime endDateTime) {
return ChronoUnit.MINUTES.between(startDateTime, endDateTime);
⋮----
public static boolean isToday(LocalDate date) {
return date != null && date.equals(today());
⋮----
public static boolean isThisWeek(LocalDate date) {
⋮----
LocalDate today = today();
LocalDate weekStart = today.with(DayOfWeek.MONDAY);
LocalDate weekEnd = today.with(DayOfWeek.SUNDAY);
⋮----
return !date.isBefore(weekStart) && !date.isAfter(weekEnd);
⋮----
public static boolean isThisMonth(LocalDate date) {
⋮----
return date.getYear() == today.getYear() && date.getMonth() == today.getMonth();
⋮----
public static int calculateAge(LocalDate birthDate) {
⋮----
return Period.between(birthDate, today()).getYears();
⋮----
public static String getTimeAgoText(LocalDateTime dateTime) {
⋮----
LocalDateTime now = now();
long minutes = ChronoUnit.MINUTES.between(dateTime, now);
⋮----
long hours = ChronoUnit.HOURS.between(dateTime, now);
⋮----
long days = ChronoUnit.DAYS.between(dateTime, now);
⋮----
public static LocalDateTime startOfDay(LocalDate date) {
return date != null ? date.atStartOfDay() : null;
⋮----
public static LocalDateTime endOfDay(LocalDate date) {
return date != null ? date.atTime(23, 59, 59, 999_999_999) : null;
⋮----
public static LocalDate getFirstDayOfMonth(LocalDate date) {
return date != null ? date.withDayOfMonth(1) : null;
⋮----
public static LocalDate getLastDayOfMonth(LocalDate date) {
return date != null ? date.withDayOfMonth(date.lengthOfMonth()) : null;
⋮----
public static boolean isBusinessDay(LocalDate date) {
⋮----
DayOfWeek dayOfWeek = date.getDayOfWeek();
⋮----
public static boolean isWeekend(LocalDate date) {
return !isBusinessDay(date);
⋮----
public static LocalDateTime convertToKoreaTime(LocalDateTime utcDateTime) {
⋮----
return utcDateTime.atZone(ZoneOffset.UTC)
.withZoneSameInstant(KOREA_ZONE)
.toLocalDateTime();
⋮----
public static LocalDateTime convertToUtc(LocalDateTime koreaDateTime) {
⋮----
return koreaDateTime.atZone(KOREA_ZONE)
.withZoneSameInstant(ZoneOffset.UTC)
⋮----
public static boolean isValidDateRange(LocalDate startDate, LocalDate endDate) {
⋮----
return !startDate.isAfter(endDate);
⋮----
public static boolean isValidDateTimeRange(LocalDateTime startDateTime, LocalDateTime endDateTime) {
⋮----
return !startDateTime.isAfter(endDateTime);
</file>

<file path="src/main/java/com/globalcarelink/common/util/SecurityUtil.java">
public final class SecurityUtil {
⋮----
private static final String DEFAULT_KEY = "GlobalCareLink!"; // 16자 고정 키 (개발용)
⋮----
private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(
⋮----
public static String encryptSensitiveData(String plainText) {
⋮----
SecretKeySpec secretKey = new SecretKeySpec(DEFAULT_KEY.getBytes(StandardCharsets.UTF_8), ALGORITHM);
Cipher cipher = Cipher.getInstance(TRANSFORMATION);
cipher.init(Cipher.ENCRYPT_MODE, secretKey);
⋮----
byte[] encryptedBytes = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
return Base64.getEncoder().encodeToString(encryptedBytes);
⋮----
log.error("데이터 암호화 실패: {}", e.getMessage());
return plainText; // 실패 시 원본 반환 (개발용)
⋮----
public static String decryptSensitiveData(String encryptedText) {
⋮----
cipher.init(Cipher.DECRYPT_MODE, secretKey);
⋮----
byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedText));
return new String(decryptedBytes, StandardCharsets.UTF_8);
⋮----
log.error("데이터 복호화 실패: {}", e.getMessage());
return encryptedText; // 실패 시 원본 반환
⋮----
public static String maskEmail(String email) {
if (email == null || !email.contains("@")) return email;
⋮----
String[] parts = email.split("@");
⋮----
if (username.length() <= 2) return email;
⋮----
String maskedUsername = username.charAt(0) + "*".repeat(username.length() - 2) + username.charAt(username.length() - 1);
⋮----
public static String maskPhoneNumber(String phoneNumber) {
if (phoneNumber == null || phoneNumber.length() < 8) return phoneNumber;
⋮----
return phoneNumber.substring(0, 3) + "-****-" + phoneNumber.substring(phoneNumber.length() - 4);
⋮----
public static String generateSecureToken() {
SecureRandom random = new SecureRandom();
⋮----
random.nextBytes(bytes);
return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
⋮----
public static String generateSecurePassword(int length) {
⋮----
StringBuilder password = new StringBuilder();
⋮----
// 각 카테고리에서 최소 1개씩 포함
password.append(upperCase.charAt(random.nextInt(upperCase.length())));
password.append(lowerCase.charAt(random.nextInt(lowerCase.length())));
password.append(digits.charAt(random.nextInt(digits.length())));
password.append(specialChars.charAt(random.nextInt(specialChars.length())));
⋮----
// 나머지 길이만큼 랜덤 생성
⋮----
password.append(allChars.charAt(random.nextInt(allChars.length())));
⋮----
// 문자열 섞기
return shuffleString(password.toString());
⋮----
public static boolean containsSqlInjection(String input) {
⋮----
return SQL_INJECTION_PATTERN.matcher(input).find();
⋮----
public static String sanitizeForSql(String input) {
⋮----
return input.replaceAll("'", "''")
.replaceAll("\"", "\\\"")
.replaceAll(";", "")
.replaceAll("--", "")
.replaceAll("/\\*", "")
.replaceAll("\\*/", "");
⋮----
public static boolean isSecurePassword(String password) {
if (password == null || password.length() < 8 || password.length() > 128) {
⋮----
boolean hasUpper = password.chars().anyMatch(Character::isUpperCase);
boolean hasLower = password.chars().anyMatch(Character::isLowerCase);
boolean hasDigit = password.chars().anyMatch(Character::isDigit);
boolean hasSpecial = password.chars().anyMatch(ch -> "@$!%*?&".indexOf(ch) >= 0);
⋮----
public static SecretKey generateAESKey() throws NoSuchAlgorithmException {
KeyGenerator keyGenerator = KeyGenerator.getInstance(ALGORITHM);
keyGenerator.init(256);
return keyGenerator.generateKey();
⋮----
private static String shuffleString(String input) {
char[] characters = input.toCharArray();
⋮----
int j = random.nextInt(i + 1);
⋮----
return new String(characters);
</file>

<file path="src/main/java/com/globalcarelink/common/util/ValidationUtil.java">
public final class ValidationUtil {
⋮----
private static final Pattern EMAIL_PATTERN = Pattern.compile(
⋮----
private static final Pattern PHONE_PATTERN = Pattern.compile(
⋮----
private static final Pattern PASSWORD_PATTERN = Pattern.compile(
⋮----
private static final Pattern KOREAN_NAME_PATTERN = Pattern.compile(
⋮----
public static boolean isValidEmail(String email) {
return email != null && EMAIL_PATTERN.matcher(email).matches();
⋮----
public static boolean isValidPhoneNumber(String phoneNumber) {
if (phoneNumber == null) return true; // Optional field
return PHONE_PATTERN.matcher(phoneNumber).matches();
⋮----
public static boolean isValidPassword(String password) {
return password != null && PASSWORD_PATTERN.matcher(password).matches();
⋮----
public static boolean isValidKoreanName(String name) {
return name != null && KOREAN_NAME_PATTERN.matcher(name).matches();
⋮----
public static boolean isValidRegion(String region) {
if (region == null || region.trim().isEmpty()) return true; // Optional field
return region.length() >= 2 && region.length() <= 100;
⋮----
public static boolean isValidLanguageCode(String language) {
if (language == null || language.trim().isEmpty()) return true; // Optional field
return language.matches("^[a-z]{2}(-[A-Z]{2})?$"); // ko, en, zh-CN 등
⋮----
public static String getPasswordValidationMessage() {
⋮----
public static String getPhoneValidationMessage() {
⋮----
public static String getEmailValidationMessage() {
⋮----
public static String sanitizeInput(String input) {
⋮----
return input.trim()
.replaceAll("<script[^>]*>.*?</script>", "")
.replaceAll("<[^>]+>", "")
.replaceAll("[\\r\\n]+", " ");
⋮----
public static boolean containsSuspiciousPattern(String input) {
⋮----
String lowerInput = input.toLowerCase();
return lowerInput.contains("<script") ||
lowerInput.contains("javascript:") ||
lowerInput.contains("onload=") ||
lowerInput.contains("onerror=") ||
lowerInput.contains("eval(") ||
lowerInput.contains("document.cookie");
</file>

<file path="src/main/java/com/globalcarelink/common/HealthController.java">
public class HealthController {
⋮----
public ResponseEntity<Map<String, Object>> health() {
⋮----
response.put("status", "UP");
response.put("message", "GlobalCareLink 서비스가 정상적으로 실행 중입니다");
response.put("timestamp", LocalDateTime.now());
response.put("version", "0.0.1-SNAPSHOT");
⋮----
return ResponseEntity.ok(response);
</file>

<file path="src/main/java/com/globalcarelink/coordinator/CoordinatorLanguageSkill.java">
import lombok.*;
⋮----
/**
 * 코디네이터 언어 능력 엔티티
 * 글로벌 서비스를 위한 다국어 지원 능력 관리
 */
⋮----
public class CoordinatorLanguageSkill extends BaseEntity {
⋮----
/**
     * 언어 코드 (ISO 639-1)
     * KO: 한국어, EN: 영어, ZH: 중국어, JP: 일본어, ES: 스페인어, 
     * VI: 베트남어, TH: 태국어, RU: 러시아어
     */
⋮----
/**
     * 언어명 (사용자 표시용)
     */
⋮----
/**
     * 언어 수준 (CEFR 기준 + 모국어)
     * NATIVE: 모국어 수준
     * FLUENT: 유창함 (C1-C2)
     * BUSINESS: 업무 가능 (B2)
     * CONVERSATIONAL: 일상 대화 (B1)
     * BASIC: 기초 수준 (A1-A2)
     */
⋮----
/**
     * 자격증/인증 정보
     */
⋮----
private String certification; // "TOEIC 950", "HSK 6급", "JLPT N1" 등
⋮----
/**
     * 전문 분야 (해당 언어로 상담 가능한 분야)
     */
⋮----
private String specialization; // "의료상담", "법무상담", "부동산" 등
⋮----
/**
     * 국가/지역 경험 (해당 언어권 거주/근무 경험)
     */
⋮----
private String countryExperience; // "미국 5년 거주", "중국 현지 근무 3년" 등
⋮----
/**
     * 언어별 서비스 요금 (추가 요금)
     */
⋮----
private Double serviceFeeRate; // 기본 요금 대비 배율 (1.0=동일, 1.5=50%할증)
⋮----
/**
     * 활성 상태
     */
⋮----
/**
     * 우선순위 (같은 언어 내에서의 우선순위)
     */
⋮----
// ===== 비즈니스 메서드 =====
⋮----
/**
     * 업무 수준 이상 여부
     */
public boolean isBusinessLevelOrAbove() {
⋮----
/**
     * 전문 상담 가능 여부
     */
public boolean canProvideProfessionalConsultation() {
⋮----
/**
     * 해당 국가 경험 여부
     */
public boolean hasCountryExperience() {
return countryExperience != null && !countryExperience.trim().isEmpty();
⋮----
/**
     * 자격증 보유 여부
     */
public boolean hasCertification() {
return certification != null && !certification.trim().isEmpty();
⋮----
/**
     * 언어별 매칭 점수 계산 (5점 만점)
     */
public double calculateMatchingScore() {
⋮----
// 자격증 보유 시 가산점
if (hasCertification()) {
⋮----
// 현지 경험 가산점
if (hasCountryExperience()) {
⋮----
// 전문 분야 가산점
if (specialization != null && !specialization.trim().isEmpty()) {
⋮----
return Math.min(baseScore, 5.0);
⋮----
/**
     * 언어 능력 표시 문자열
     */
public String getDisplayText() {
StringBuilder display = new StringBuilder();
display.append(languageName).append(" (").append(getProficiencyDisplayName()).append(")");
⋮----
display.append(" - ").append(certification);
⋮----
display.append(" [").append(countryExperience).append("]");
⋮----
return display.toString();
⋮----
/**
     * 수준별 한글 표시명
     */
public String getProficiencyDisplayName() {
⋮----
/**
     * 재외동포 국가별 언어 매칭
     */
public boolean matchesCountry(String countryCode) {
return switch (languageCode.toUpperCase()) {
case "EN" -> countryCode.matches("US|CA|AU|NZ|GB"); // 영어권
case "ZH" -> countryCode.matches("CN|TW|SG|MY");    // 중화권
case "JP" -> countryCode.equals("JP");              // 일본
case "ES" -> countryCode.matches("ES|MX|AR|CL|PE"); // 스페인어권
case "VI" -> countryCode.equals("VN");              // 베트남
case "TH" -> countryCode.equals("TH");              // 태국
case "RU" -> countryCode.matches("RU|KZ|UZ");       // 러시아어권
⋮----
/**
     * 언어 수준 enum
     */
⋮----
public String getDescription() {
</file>

<file path="src/main/java/com/globalcarelink/coordinator/CoordinatorLanguageSkillRepository.java">
/**
 * 코디네이터 언어 능력 데이터 접근 계층
 */
⋮----
public interface CoordinatorLanguageSkillRepository extends JpaRepository<CoordinatorLanguageSkill, Long> {
⋮----
/**
     * 코디네이터별 언어 능력 조회
     */
List<CoordinatorLanguageSkill> findByCoordinatorIdAndIsActiveTrueOrderByPriorityOrder(String coordinatorId);
⋮----
/**
     * 특정 언어 코드로 조회
     */
List<CoordinatorLanguageSkill> findByLanguageCodeAndIsActiveTrue(String languageCode);
⋮----
/**
     * 특정 코디네이터의 특정 언어 능력 조회
     */
Optional<CoordinatorLanguageSkill> findByCoordinatorIdAndLanguageCodeAndIsActiveTrue(String coordinatorId, String languageCode);
⋮----
/**
     * 모든 활성 언어 능력 조회 (우선순위 정렬)
     */
List<CoordinatorLanguageSkill> findByIsActiveTrueOrderByPriorityOrder();
⋮----
/**
     * 업무 수준 이상 언어 능력자 조회
     */
⋮----
List<CoordinatorLanguageSkill> findBusinessLevelLanguageSkills();
⋮----
/**
     * 특정 수준 이상 언어 능력자 조회
     */
List<CoordinatorLanguageSkill> findByProficiencyLevelInAndIsActiveTrueOrderByPriorityOrder(List<CoordinatorLanguageSkill.LanguageProficiency> proficiencyLevels);
⋮----
/**
     * 자격증 보유자 조회
     */
⋮----
List<CoordinatorLanguageSkill> findByCertificationNotNullAndIsActiveTrueOrderByPriorityOrder();
⋮----
/**
     * 현지 경험 보유자 조회
     */
⋮----
List<CoordinatorLanguageSkill> findByCountryExperienceNotNullAndIsActiveTrueOrderByPriorityOrder();
⋮----
/**
     * 언어별 코디네이터 수 통계
     */
⋮----
List<LanguageStatistics> findLanguageDistributionStatistics();
⋮----
/**
     * 코디네이터별 언어 수 통계
     */
⋮----
List<CoordinatorLanguageCount> findCoordinatorLanguageCountStatistics();
⋮----
/**
     * 특정 국가에서 경험이 있는 코디네이터 조회
     */
⋮----
List<CoordinatorLanguageSkill> findByCountryExperienceContaining(@Param("countryName") String countryName);
⋮----
/**
     * 다국어 지원 코디네이터 (2개 언어 이상)
     */
⋮----
List<String> findMultilingualCoordinatorIds();
⋮----
/**
     * 언어별 평균 매칭 점수
     */
⋮----
List<LanguageAverageScore> findLanguageAverageScores();
⋮----
// ===== DTO 인터페이스들 =====
⋮----
interface LanguageStatistics {
String getLanguageCode();
String getLanguageName();
Long getCoordinatorCount();
⋮----
interface CoordinatorLanguageCount {
String getCoordinatorId();
Long getLanguageCount();
⋮----
interface LanguageAverageScore {
⋮----
Double getAvgScore();
</file>

<file path="src/main/java/com/globalcarelink/coordinator/LanguageMatchingService.java">
/**
 * 언어 기반 코디네이터 매칭 서비스
 * 재외동포의 언어 선호도와 코디네이터 언어 능력을 매칭
 */
⋮----
public class LanguageMatchingService {
⋮----
/**
     * 언어 기반 코디네이터 추천
     */
public List<CoordinatorLanguageMatch> findLanguageCompatibleCoordinators(
⋮----
log.debug("언어 기반 코디네이터 검색 - 언어: {}, 국가: {}, 전문상담: {}",
⋮----
// 1. 해당 언어 가능 코디네이터 조회
⋮----
languageSkillRepository.findByLanguageCodeAndIsActiveTrue(preferredLanguage.toUpperCase());
⋮----
// 2. 전문 상담 필요 시 수준 필터링
⋮----
languageSkills = languageSkills.stream()
.filter(CoordinatorLanguageSkill::canProvideProfessionalConsultation)
.collect(Collectors.toList());
⋮----
// 3. 국가 경험 가산점 적용
List<CoordinatorLanguageMatch> matches = languageSkills.stream()
.map(skill -> createLanguageMatch(skill, countryCode))
.sorted(Comparator.comparing(CoordinatorLanguageMatch::getMatchScore).reversed())
⋮----
log.info("언어 매칭 완료 - 언어: {}, 매칭된 코디네이터: {}명", preferredLanguage, matches.size());
⋮----
/**
     * 다국어 지원 코디네이터 조회
     */
public List<CoordinatorMultilingualProfile> findMultilingualCoordinators() {
// 언어별 그룹핑
⋮----
languageSkillRepository.findByIsActiveTrueOrderByPriorityOrder().stream()
.collect(Collectors.groupingBy(CoordinatorLanguageSkill::getCoordinatorId));
⋮----
return skillsByCoordinator.entrySet().stream()
.map(entry -> {
String coordinatorId = entry.getKey();
List<CoordinatorLanguageSkill> skills = entry.getValue();
⋮----
return CoordinatorMultilingualProfile.builder()
.coordinatorId(coordinatorId)
.languageSkills(skills)
.totalLanguages(skills.size())
.averageScore(calculateAverageLanguageScore(skills))
.hasNativeLanguages(hasNativeLanguages(skills))
.supportedCountries(getSupportedCountries(skills))
.build();
⋮----
.sorted(Comparator.comparing(CoordinatorMultilingualProfile::getAverageScore).reversed())
⋮----
/**
     * 특정 국가의 재외동포를 위한 최적 코디네이터 추천
     */
public List<CoordinatorLanguageMatch> findOptimalCoordinatorForOverseasKorean(
⋮----
// 1. 주 언어 매칭
⋮----
allMatches.addAll(findLanguageCompatibleCoordinators(preferredLanguage, countryCode, true));
⋮----
// 2. 추가 언어 매칭 (낮은 우선순위)
if (additionalLanguages != null && !additionalLanguages.isEmpty()) {
⋮----
findLanguageCompatibleCoordinators(additionalLang, countryCode, false);
⋮----
// 추가 언어는 매칭 점수 가중치 적용
additionalMatches.forEach(match ->
match.setMatchScore(match.getMatchScore() * 0.7));
⋮----
allMatches.addAll(additionalMatches);
⋮----
// 3. 중복 제거 및 정렬
return allMatches.stream()
.collect(Collectors.groupingBy(match -> match.getLanguageSkill().getCoordinatorId()))
.values().stream()
.map(matches -> matches.stream().max(Comparator.comparing(CoordinatorLanguageMatch::getMatchScore)).orElse(null))
.filter(match -> match != null)
⋮----
.limit(10)
⋮----
/**
     * 언어별 서비스 요금 계산
     */
public ServiceFeeCalculation calculateLanguageServiceFee(
⋮----
.findByCoordinatorIdAndLanguageCodeAndIsActiveTrue(coordinatorId, languageCode)
.orElse(null);
⋮----
if (skill == null || skill.getServiceFeeRate() == null) {
return ServiceFeeCalculation.builder()
.baseFee(baseFee)
.languageFee(baseFee)
.feeRate(1.0)
.additionalFee(0.0)
.hasLanguagePremium(false)
⋮----
double languageFee = baseFee * skill.getServiceFeeRate();
⋮----
.languageFee(languageFee)
.feeRate(skill.getServiceFeeRate())
.additionalFee(additionalFee)
.hasLanguagePremium(skill.getServiceFeeRate() > 1.0)
.languageName(skill.getLanguageName())
.proficiencyLevel(skill.getProficiencyLevel().name())
⋮----
/**
     * 코디네이터별 지원 가능 언어 통계
     */
public Map<String, Long> getLanguageDistributionStatistics() {
return languageSkillRepository.findByIsActiveTrueOrderByPriorityOrder().stream()
.collect(Collectors.groupingBy(
⋮----
Collectors.counting()
⋮----
/**
     * 부족한 언어 분석 (수요 대비 공급 부족)
     */
public List<LanguageGapAnalysis> analyzeLanguageGaps() {
Map<String, Long> currentSupply = getLanguageDistributionStatistics();
⋮----
// 재외동포 주요 거주국 기반 수요 추정
Map<String, Long> estimatedDemand = Map.of(
"EN", 50L, // 영어권 재외동포 다수
"ZH", 40L, // 중국 거주 재외동포
"JP", 30L, // 일본 거주 재외동포
"ES", 15L, // 남미 재외동포
"RU", 10L, // 구소련 재외동포
"VI", 8L,  // 베트남 진출 증가
"TH", 5L   // 동남아 진출
⋮----
return estimatedDemand.entrySet().stream()
⋮----
String langCode = entry.getKey();
Long demand = entry.getValue();
Long supply = currentSupply.getOrDefault(langCode, 0L);
⋮----
return LanguageGapAnalysis.builder()
.languageCode(langCode)
.languageName(getLanguageName(langCode))
.estimatedDemand(demand)
.currentSupply(supply)
.gap(demand - supply)
.supplyRatio((double) supply / demand)
.priority(demand - supply > 0 ? "HIGH" : "ADEQUATE")
⋮----
.sorted(Comparator.comparing(LanguageGapAnalysis::getGap).reversed())
⋮----
// ===== 내부 헬퍼 메서드 =====
⋮----
private CoordinatorLanguageMatch createLanguageMatch(CoordinatorLanguageSkill skill, String countryCode) {
double matchScore = skill.calculateMatchingScore();
⋮----
// 국가 매칭 보너스
if (skill.matchesCountry(countryCode)) {
⋮----
// 현지 경험 추가 보너스
if (skill.hasCountryExperience() &&
skill.getCountryExperience().toLowerCase().contains(getCountryName(countryCode).toLowerCase())) {
⋮----
return CoordinatorLanguageMatch.builder()
.languageSkill(skill)
.matchScore(Math.min(matchScore, 5.0))
.matchReason(generateMatchReason(skill, countryCode, matchScore))
⋮----
private double calculateAverageLanguageScore(List<CoordinatorLanguageSkill> skills) {
return skills.stream()
.mapToDouble(CoordinatorLanguageSkill::calculateMatchingScore)
.average()
.orElse(0.0);
⋮----
private boolean hasNativeLanguages(List<CoordinatorLanguageSkill> skills) {
⋮----
.anyMatch(skill -> skill.getProficiencyLevel() == CoordinatorLanguageSkill.LanguageProficiency.NATIVE);
⋮----
private List<String> getSupportedCountries(List<CoordinatorLanguageSkill> skills) {
⋮----
.filter(skill -> skill.getCountryExperience() != null)
.map(CoordinatorLanguageSkill::getCountryExperience)
⋮----
private String generateMatchReason(CoordinatorLanguageSkill skill, String countryCode, double matchScore) {
StringBuilder reason = new StringBuilder();
⋮----
reason.append("🗣️ ").append(skill.getLanguageName())
.append(" (").append(skill.getProficiencyDisplayName()).append(")");
⋮----
if (skill.hasCertification()) {
reason.append(" ✓ ").append(skill.getCertification());
⋮----
reason.append(" 🌍 ").append(getCountryName(countryCode)).append(" 전문");
⋮----
if (skill.hasCountryExperience()) {
reason.append(" 📍 현지경험: ").append(skill.getCountryExperience());
⋮----
reason.append(" (매칭도: ").append(String.format("%.1f", matchScore)).append("/5.0)");
⋮----
return reason.toString();
⋮----
private String getCountryName(String countryCode) {
return switch (countryCode.toUpperCase()) {
⋮----
private String getLanguageName(String langCode) {
return switch (langCode.toUpperCase()) {
⋮----
// ===== DTO 클래스들 =====
⋮----
public static class CoordinatorLanguageMatch {
⋮----
public static class CoordinatorMultilingualProfile {
⋮----
public static class ServiceFeeCalculation {
⋮----
public static class LanguageGapAnalysis {
</file>

<file path="src/main/java/com/globalcarelink/health/dto/HealthAssessmentCreateRequest.java">
/**
 * 건강 평가 생성 요청 DTO
 */
⋮----
public class HealthAssessmentCreateRequest {
⋮----
// === ADL 평가 (필수) ===
⋮----
// === 추가 평가 항목 ===
⋮----
// === 추가 정보 ===
⋮----
private String notes; // 특이사항
⋮----
private String assessorName; // 평가자 이름
⋮----
private String assessorRelation; // 평가자와의 관계 (본인, 가족, 간병인 등)
</file>

<file path="src/main/java/com/globalcarelink/health/dto/HealthAssessmentStatistics.java">
/**
 * 건강 평가 통계 응답 DTO
 */
⋮----
public class HealthAssessmentStatistics {
⋮----
// === 기본 통계 ===
⋮----
/**
     * 전체 평가 수
     */
⋮----
/**
     * 완성된 평가 수 (4개 ADL 영역 모두 작성)
     */
⋮----
/**
     * 최근 30일 평가 수
     */
⋮----
/**
     * 완성도 비율 (%)
     */
public double getCompletionRate() {
⋮----
// === 케어 등급별 분포 ===
⋮----
/**
     * 케어 등급별 통계
     * [{"grade": "1", "count": 150}, {"grade": "2", "count": 200}, ...]
     */
⋮----
/**
     * ADL 점수 구간별 분포
     * [{"score_range": "경증(100-140)", "count": 80}, ...]
     */
⋮----
/**
     * 연령대별 케어 등급 분포
     * [{"age_group": "70대", "ltci_grade": "3", "count": 45}, ...]
     */
⋮----
/**
     * 성별 케어 패턴 분석
     * [{"gender": "M", "ltci_grade": "2", "avg_adl_score": 180.5, "count": 30}, ...]
     */
⋮----
// === 특화 케어 통계 ===
⋮----
/**
     * 호스피스 케어 대상자 수
     */
⋮----
/**
     * 치매 전문 케어 대상자 수
     */
⋮----
/**
     * 중증 환자 수
     */
⋮----
/**
     * 재외동포 평가 수
     */
⋮----
// === 추가 분석 데이터 ===
⋮----
/**
     * 평균 ADL 점수
     */
⋮----
/**
     * 가장 많은 케어 등급
     */
⋮----
/**
     * 평가 트렌드 (월별)
     */
⋮----
// === 내부 DTO 클래스들 ===
⋮----
public static class MonthlyTrend {
private String month; // "2024-01"
⋮----
public static class CareGradeStatistics {
⋮----
public static class DiseaseTypeStatistics {
⋮----
// === 편의 메서드 ===
⋮----
/**
     * 케어 등급별 통계를 구조화된 객체로 변환
     */
public List<CareGradeStatistics> getCareGradeStatisticsStructured() {
if (careGradeDistribution == null) return List.of();
⋮----
return careGradeDistribution.stream()
.map(map -> CareGradeStatistics.builder()
.gradeLevel(String.valueOf(map.get("grade")))
.count((Long) map.get("count"))
.percentage(calculatePercentage((Long) map.get("count"), totalAssessments))
.build())
.toList();
⋮----
/**
     * 최고 빈도 케어 등급 조회
     */
public String getMostFrequentCareGrade() {
if (careGradeDistribution == null || careGradeDistribution.isEmpty()) {
⋮----
.max((a, b) -> Long.compare((Long) a.get("count"), (Long) b.get("count")))
.map(map -> String.valueOf(map.get("grade")))
.orElse("데이터 없음");
⋮----
/**
     * 건강한 사용자 비율 (ADL 점수 140점 이하)
     */
public double getHealthyUserRatio() {
⋮----
long healthyCount = adlScoreDistribution.stream()
.filter(map -> {
String range = String.valueOf(map.get("score_range"));
return range.contains("경증(100-140)");
⋮----
.mapToLong(map -> (Long) map.get("count"))
.sum();
⋮----
/**
     * 고위험군 비율 (ADL 점수 220점 이상)
     */
public double getHighRiskRatio() {
⋮----
long highRiskCount = adlScoreDistribution.stream()
⋮----
return range.contains("최중증(221-300)");
⋮----
// === 내부 헬퍼 메서드 ===
⋮----
private double calculatePercentage(Long count, Long total) {
</file>

<file path="src/main/java/com/globalcarelink/health/dto/HealthAssessmentUpdateRequest.java">
/**
 * 건강 평가 수정 요청 DTO
 * 모든 필드는 선택사항 (null이면 기존 값 유지)
 */
⋮----
public class HealthAssessmentUpdateRequest {
⋮----
// === ADL 평가 ===
⋮----
// === 추가 평가 항목 ===
⋮----
// === 추가 정보 ===
⋮----
private String notes; // 특이사항
⋮----
private String updateReason; // 수정 사유
</file>

<file path="src/main/java/com/globalcarelink/health/HealthAssessmentController.java">
/**
 * 건강 상태 평가 API 컨트롤러
 * KB라이프생명 기반 돌봄지수 체크 시스템
 */
⋮----
public class HealthAssessmentController {
⋮----
public ResponseEntity<HealthAssessment> createAssessment(
⋮----
log.info("건강 평가 생성 요청 - 회원: {}", request.getMemberId());
⋮----
HealthAssessment assessment = healthAssessmentService.createAssessment(request);
⋮----
return ResponseEntity.status(HttpStatus.CREATED).body(assessment);
⋮----
public ResponseEntity<HealthAssessment> getLatestAssessment(
⋮----
Optional<HealthAssessment> assessment = healthAssessmentService.getLatestAssessmentByMemberId(memberId);
⋮----
.map(ResponseEntity::ok)
.orElse(ResponseEntity.notFound().build());
⋮----
public ResponseEntity<List<HealthAssessment>> getAssessmentHistory(
⋮----
List<HealthAssessment> assessments = healthAssessmentService.getAssessmentHistoryByMemberId(memberId);
⋮----
return ResponseEntity.ok(assessments);
⋮----
public ResponseEntity<Page<HealthAssessment>> getAssessmentsByMemberId(
⋮----
Pageable pageable = PageRequest.of(page, size);
Page<HealthAssessment> assessments = healthAssessmentService.getAssessmentsByMemberId(memberId, pageable);
⋮----
public ResponseEntity<HealthAssessment> updateAssessment(
⋮----
log.info("건강 평가 수정 요청 - ID: {}", assessmentId);
⋮----
HealthAssessment updated = healthAssessmentService.updateAssessment(assessmentId, request);
⋮----
return ResponseEntity.ok(updated);
⋮----
public ResponseEntity<CareGradeCalculator.CareGradeResult> calculateCareGrade(
⋮----
// 평가 조회
// TODO: 실제로는 assessmentId로 조회해야 함
HealthAssessment assessment = new HealthAssessment(); // 임시
⋮----
CareGradeCalculator.CareGradeResult result = healthAssessmentService.calculateCareGrade(assessment);
⋮----
return ResponseEntity.ok(result);
⋮----
public ResponseEntity<Void> deleteAssessment(
⋮----
log.info("건강 평가 삭제 요청 - ID: {}", assessmentId);
⋮----
healthAssessmentService.deleteAssessment(assessmentId);
⋮----
return ResponseEntity.noContent().build();
⋮----
// ===== 특화 조회 API =====
⋮----
public ResponseEntity<List<HealthAssessment>> getHospiceCareTargets() {
List<HealthAssessment> assessments = healthAssessmentService.getHospiceCareTargets();
⋮----
public ResponseEntity<List<HealthAssessment>> getDementiaCareTargets() {
List<HealthAssessment> assessments = healthAssessmentService.getDementiaCareTargets();
⋮----
public ResponseEntity<List<HealthAssessment>> getSevereCareTargets() {
List<HealthAssessment> assessments = healthAssessmentService.getSevereCareTargets();
⋮----
public ResponseEntity<List<HealthAssessment>> getOverseasKoreanAssessments() {
List<HealthAssessment> assessments = healthAssessmentService.getOverseasKoreanAssessments();
⋮----
public ResponseEntity<List<HealthAssessment>> getAssessmentsByCareGradeRange(
⋮----
List<HealthAssessment> assessments = healthAssessmentService.getAssessmentsByCareGradeRange(minGrade, maxGrade);
⋮----
// ===== 통계 및 분석 API =====
⋮----
public ResponseEntity<HealthAssessmentStatistics> getStatistics() {
HealthAssessmentStatistics statistics = healthAssessmentService.getStatistics();
return ResponseEntity.ok(statistics);
⋮----
public ResponseEntity<List<Map<String, Object>>> getMemberAssessmentTrend(
⋮----
List<Map<String, Object>> trend = healthAssessmentService.getMemberAssessmentTrend(memberId);
return ResponseEntity.ok(trend);
⋮----
// ===== 간편 조회 API =====
⋮----
public ResponseEntity<String> getAssessmentSummary(
⋮----
String summary = assessment.generateAssessmentSummary();
return ResponseEntity.ok(summary);
⋮----
public ResponseEntity<Map<String, Object>> checkAssessmentCompleteness(
⋮----
Map<String, Object> completeness = Map.of(
"isComplete", assessment.isComplete(),
"completionPercentage", assessment.isComplete() ? 100 : 75, // 임시 계산
"missingFields", assessment.isComplete() ? List.of() : List.of("ltciGrade", "diseaseTypes"),
"careType", assessment.getSpecializedCareType(),
"estimatedCost", assessment.getEstimatedMonthlyCostRange()
⋮----
return ResponseEntity.ok(completeness);
</file>

<file path="src/main/java/com/globalcarelink/profile/dto/DomesticProfileRequest.java">
public class DomesticProfileRequest {
</file>

<file path="src/main/java/com/globalcarelink/profile/dto/DomesticProfileResponse.java">
public class DomesticProfileResponse {
⋮----
public static DomesticProfileResponse from(DomesticProfile profile) {
⋮----
return DomesticProfileResponse.builder()
.id(profile.getId())
.memberId(profile.getMember().getId())
.birthDate(profile.getBirthDate())
.gender(profile.getGender())
.address(profile.getAddress())
.detailedAddress(profile.getDetailedAddress())
.postalCode(profile.getPostalCode())
.emergencyContactName(profile.getEmergencyContactName())
.emergencyContactPhone(maskPhoneNumber(profile.getEmergencyContactPhone()))
.emergencyContactRelation(profile.getEmergencyContactRelation())
.healthInsuranceNumber(maskHealthInsuranceNumber(profile.getHealthInsuranceNumber()))
.ltciGrade(profile.getLtciGrade())
.ltciCertificateNumber(profile.getLtciCertificateNumber())
.preferredRegion(profile.getPreferredRegion())
.careLevel(profile.getCareLevel())
.specialNeeds(profile.getSpecialNeeds())
.familyVisitFrequency(profile.getFamilyVisitFrequency())
.budgetRange(profile.getBudgetRange())
.profileCompletionPercentage(profile.getProfileCompletionPercentage())
.createdAt(profile.getCreatedAt())
.updatedAt(profile.getUpdatedAt())
.hasBasicInfo(profile.hasBasicInfo())
.hasEmergencyContact(profile.hasEmergencyContact())
.hasHealthInfo(profile.hasHealthInfo())
.isProfileComplete(profile.isProfileComplete())
.build();
⋮----
private static String maskPhoneNumber(String phoneNumber) {
if (phoneNumber == null || phoneNumber.length() < 8) {
⋮----
return phoneNumber.substring(0, 3) + "-****-" + phoneNumber.substring(phoneNumber.length() - 4);
⋮----
private static String maskHealthInsuranceNumber(String insuranceNumber) {
if (insuranceNumber == null || insuranceNumber.length() < 8) {
⋮----
return insuranceNumber.substring(0, 6) + "****" + insuranceNumber.substring(insuranceNumber.length() - 3);
</file>

<file path="src/main/java/com/globalcarelink/profile/dto/OverseasProfileRequest.java">
public class OverseasProfileRequest {
</file>

<file path="src/main/java/com/globalcarelink/profile/dto/OverseasProfileResponse.java">
public class OverseasProfileResponse {
⋮----
public static OverseasProfileResponse from(OverseasProfile profile) {
⋮----
return OverseasProfileResponse.builder()
.id(profile.getId())
.memberId(profile.getMember().getId())
.birthDate(profile.getBirthDate())
.gender(profile.getGender())
.overseasAddress(profile.getOverseasAddress())
.residenceCountry(profile.getResidenceCountry())
.residenceCity(profile.getResidenceCity())
.koreanAddress(profile.getKoreanAddress())
.koreanPostalCode(profile.getKoreanPostalCode())
.passportNumber(maskPassportNumber(profile.getPassportNumber()))
.passportExpiryDate(profile.getPassportExpiryDate())
.visaStatus(profile.getVisaStatus())
.visaExpiryDate(profile.getVisaExpiryDate())
.overseasContactName(profile.getOverseasContactName())
.overseasContactPhone(maskOverseasPhone(profile.getOverseasContactPhone()))
.overseasContactRelation(profile.getOverseasContactRelation())
.koreaContactName(profile.getKoreaContactName())
.koreaContactPhone(maskPhoneNumber(profile.getKoreaContactPhone()))
.koreaContactRelation(profile.getKoreaContactRelation())
.overseasInsuranceNumber(maskInsuranceNumber(profile.getOverseasInsuranceNumber()))
.overseasInsuranceProvider(profile.getOverseasInsuranceProvider())
.travelInsurance(profile.getTravelInsurance())
.entryPurpose(profile.getEntryPurpose())
.expectedStayDuration(profile.getExpectedStayDuration())
.preferredCommunicationMethod(profile.getPreferredCommunicationMethod())
.timeZonePreference(profile.getTimeZonePreference())
.preferredRegionInKorea(profile.getPreferredRegionInKorea())
.budgetRange(profile.getBudgetRange())
.careLevel(profile.getCareLevel())
.specialNeeds(profile.getSpecialNeeds())
.culturalDietaryRequirements(profile.getCulturalDietaryRequirements())
.profileCompletionPercentage(profile.getProfileCompletionPercentage())
.coordinatorRequired(profile.getCoordinatorRequired())
.createdAt(profile.getCreatedAt())
.updatedAt(profile.getUpdatedAt())
.hasBasicInfo(profile.hasBasicInfo())
.hasPassportInfo(profile.hasPassportInfo())
.hasOverseasContact(profile.hasOverseasContact())
.hasKoreaContact(profile.hasKoreaContact())
.isDocumentationComplete(profile.isDocumentationComplete())
.isProfileComplete(profile.isProfileComplete())
.build();
⋮----
private static String maskPassportNumber(String passportNumber) {
if (passportNumber == null || passportNumber.length() < 6) {
⋮----
return passportNumber.substring(0, 5) + "****";
⋮----
private static String maskPhoneNumber(String phoneNumber) {
if (phoneNumber == null || phoneNumber.length() < 8) {
⋮----
return phoneNumber.substring(0, 3) + "-****-" + phoneNumber.substring(phoneNumber.length() - 4);
⋮----
private static String maskOverseasPhone(String phoneNumber) {
⋮----
if (phoneNumber.contains("-")) {
String[] parts = phoneNumber.split("-");
⋮----
return phoneNumber.substring(0, 6) + "***" + phoneNumber.substring(phoneNumber.length() - 4);
⋮----
private static String maskInsuranceNumber(String insuranceNumber) {
if (insuranceNumber == null || insuranceNumber.length() < 8) {
⋮----
return insuranceNumber.substring(0, 6) + "***" + insuranceNumber.substring(insuranceNumber.length() - 3);
</file>

<file path="src/main/java/com/globalcarelink/profile/DomesticProfile.java">
import lombok.*;
⋮----
public class DomesticProfile extends BaseEntity {
⋮----
public void updateBasicInfo(LocalDate birthDate, String gender, String address,
⋮----
calculateProfileCompletion();
⋮----
public void updateEmergencyContact(String name, String phone, String relation) {
⋮----
public void updateHealthInfo(String healthInsuranceNumber, Integer ltciGrade,
⋮----
public void updateCareInfo(String preferredRegion, String careLevel,
⋮----
private void calculateProfileCompletion() {
⋮----
if (gender != null && !gender.trim().isEmpty()) completedFields++;
if (address != null && !address.trim().isEmpty()) completedFields++;
if (detailedAddress != null && !detailedAddress.trim().isEmpty()) completedFields++;
if (postalCode != null && !postalCode.trim().isEmpty()) completedFields++;
if (emergencyContactName != null && !emergencyContactName.trim().isEmpty()) completedFields++;
if (emergencyContactPhone != null && !emergencyContactPhone.trim().isEmpty()) completedFields++;
if (emergencyContactRelation != null && !emergencyContactRelation.trim().isEmpty()) completedFields++;
if (healthInsuranceNumber != null && !healthInsuranceNumber.trim().isEmpty()) completedFields++;
⋮----
if (ltciCertificateNumber != null && !ltciCertificateNumber.trim().isEmpty()) completedFields++;
if (preferredRegion != null && !preferredRegion.trim().isEmpty()) completedFields++;
if (careLevel != null && !careLevel.trim().isEmpty()) completedFields++;
if (specialNeeds != null && !specialNeeds.trim().isEmpty()) completedFields++;
if (budgetRange != null && !budgetRange.trim().isEmpty()) completedFields++;
⋮----
this.profileCompletionPercentage = Math.round((float) completedFields / totalFields * 100);
⋮----
public boolean isProfileComplete() {
⋮----
public boolean hasBasicInfo() {
⋮----
public boolean hasEmergencyContact() {
⋮----
public boolean hasHealthInfo() {
</file>

<file path="src/main/java/com/globalcarelink/profile/DomesticProfileRepository.java">
public interface DomesticProfileRepository extends JpaRepository<DomesticProfile, Long> {
⋮----
Optional<DomesticProfile> findByMemberId(Long memberId);
⋮----
boolean existsByMemberId(Long memberId);
⋮----
List<DomesticProfile> findByProfileCompletionPercentageGreaterThanEqual(@Param("percentage") Integer percentage);
⋮----
List<DomesticProfile> findByLtciGrade(@Param("grade") Integer grade);
⋮----
List<DomesticProfile> findByCareLevel(@Param("careLevel") String careLevel);
⋮----
List<DomesticProfile> findByPreferredRegion(@Param("region") String region);
⋮----
List<DomesticProfile> findByBudgetRange(@Param("budgetRange") String budgetRange);
⋮----
List<DomesticProfile> findJobSeekersWithProfileCompletion(@Param("percentage") Integer percentage);
⋮----
List<DomesticProfile> findByCity(@Param("city") String city);
⋮----
long countCompleteProfiles();
⋮----
long countProfilesWithEmergencyContact();
⋮----
long countProfilesWithLtciGrade();
⋮----
List<Object[]> getCareeLevelStatistics();
⋮----
List<Object[]> getBudgetRangeStatistics();
⋮----
Double getAverageProfileCompletion();
</file>

<file path="src/main/java/com/globalcarelink/profile/OverseasProfile.java">
import lombok.*;
⋮----
public class OverseasProfile extends BaseEntity {
⋮----
public void updateBasicInfo(LocalDate birthDate, String gender, String overseasAddress,
⋮----
calculateProfileCompletion();
⋮----
public void updateKoreanAddress(String koreanAddress, String koreanPostalCode) {
⋮----
public void updatePassportInfo(String passportNumber, LocalDate passportExpiryDate,
⋮----
public void updateOverseasContact(String name, String phone, String relation) {
⋮----
public void updateKoreaContact(String name, String phone, String relation) {
⋮----
public void updateInsuranceInfo(String overseasInsuranceNumber, String overseasInsuranceProvider,
⋮----
public void updateTripInfo(String entryPurpose, String expectedStayDuration,
⋮----
public void updateCareInfo(String preferredRegionInKorea, String budgetRange, String careLevel,
⋮----
public void setCoordinatorRequired(boolean required) {
⋮----
private void calculateProfileCompletion() {
⋮----
if (gender != null && !gender.trim().isEmpty()) completedFields++;
if (overseasAddress != null && !overseasAddress.trim().isEmpty()) completedFields++;
if (residenceCountry != null && !residenceCountry.trim().isEmpty()) completedFields++;
if (residenceCity != null && !residenceCity.trim().isEmpty()) completedFields++;
if (koreanAddress != null && !koreanAddress.trim().isEmpty()) completedFields++;
if (koreanPostalCode != null && !koreanPostalCode.trim().isEmpty()) completedFields++;
if (passportNumber != null && !passportNumber.trim().isEmpty()) completedFields++;
⋮----
if (visaStatus != null && !visaStatus.trim().isEmpty()) completedFields++;
⋮----
if (overseasContactName != null && !overseasContactName.trim().isEmpty()) completedFields++;
if (overseasContactPhone != null && !overseasContactPhone.trim().isEmpty()) completedFields++;
if (overseasContactRelation != null && !overseasContactRelation.trim().isEmpty()) completedFields++;
if (koreaContactName != null && !koreaContactName.trim().isEmpty()) completedFields++;
if (koreaContactPhone != null && !koreaContactPhone.trim().isEmpty()) completedFields++;
if (koreaContactRelation != null && !koreaContactRelation.trim().isEmpty()) completedFields++;
if (overseasInsuranceNumber != null && !overseasInsuranceNumber.trim().isEmpty()) completedFields++;
if (overseasInsuranceProvider != null && !overseasInsuranceProvider.trim().isEmpty()) completedFields++;
if (travelInsurance != null && !travelInsurance.trim().isEmpty()) completedFields++;
if (entryPurpose != null && !entryPurpose.trim().isEmpty()) completedFields++;
if (expectedStayDuration != null && !expectedStayDuration.trim().isEmpty()) completedFields++;
if (preferredCommunicationMethod != null && !preferredCommunicationMethod.trim().isEmpty()) completedFields++;
if (timeZonePreference != null && !timeZonePreference.trim().isEmpty()) completedFields++;
if (budgetRange != null && !budgetRange.trim().isEmpty()) completedFields++;
⋮----
this.profileCompletionPercentage = Math.round((float) completedFields / totalFields * 100);
⋮----
public boolean isProfileComplete() {
⋮----
public boolean hasBasicInfo() {
⋮----
public boolean hasPassportInfo() {
⋮----
public boolean hasOverseasContact() {
⋮----
public boolean hasKoreaContact() {
⋮----
public boolean isDocumentationComplete() {
return hasPassportInfo() && visaStatus != null;
</file>

<file path="src/main/java/com/globalcarelink/profile/OverseasProfileRepository.java">
public interface OverseasProfileRepository extends JpaRepository<OverseasProfile, Long> {
⋮----
Optional<OverseasProfile> findByMemberId(Long memberId);
⋮----
boolean existsByMemberId(Long memberId);
⋮----
List<OverseasProfile> findByResidenceCountry(@Param("country") String country);
⋮----
List<OverseasProfile> findByResidenceCountryAndCity(@Param("country") String country, @Param("city") String city);
⋮----
List<OverseasProfile> findByProfileCompletionPercentageGreaterThanEqual(@Param("percentage") Integer percentage);
⋮----
List<OverseasProfile> findRequiringCoordinator();
⋮----
List<OverseasProfile> findRequiringCoordinatorWithCompletion(@Param("percentage") Integer percentage);
⋮----
List<OverseasProfile> findByPassportExpiryDateBefore(@Param("date") LocalDate date);
⋮----
List<OverseasProfile> findByVisaExpiryDateBefore(@Param("date") LocalDate date);
⋮----
List<OverseasProfile> findByPreferredRegionInKorea(@Param("region") String region);
⋮----
List<OverseasProfile> findByBudgetRange(@Param("budgetRange") String budgetRange);
⋮----
List<OverseasProfile> findByCareLevel(@Param("careLevel") String careLevel);
⋮----
List<OverseasProfile> findByEntryPurpose(@Param("purpose") String purpose);
⋮----
List<OverseasProfile> findByExpectedStayDuration(@Param("duration") String duration);
⋮----
List<OverseasProfile> findByPreferredCommunicationMethod(@Param("method") String method);
⋮----
List<OverseasProfile> findByTimeZonePreference(@Param("timeZone") String timeZone);
⋮----
List<OverseasProfile> findJobSeekersWithProfileCompletion(@Param("percentage") Integer percentage);
⋮----
long countCompleteProfiles();
⋮----
long countRequiringCoordinator();
⋮----
List<Object[]> getResidenceCountryStatistics();
⋮----
List<Object[]> getCareLevelStatistics();
⋮----
List<Object[]> getBudgetRangeStatistics();
⋮----
List<Object[]> getEntryPurposeStatistics();
⋮----
Double getAverageProfileCompletion();
⋮----
long countExpiringPassports(@Param("threeMonthsLater") LocalDate threeMonthsLater);
⋮----
long countExpiringVisas(@Param("oneMonthLater") LocalDate oneMonthLater);
</file>

<file path="src/main/java/com/globalcarelink/profile/ProfileController.java">
public class ProfileController {
⋮----
public ResponseEntity<DomesticProfileResponse> createDomesticProfile(
⋮----
DomesticProfileResponse response = profileService.createDomesticProfile(memberId, request);
return ResponseEntity.status(HttpStatus.CREATED).body(response);
⋮----
public ResponseEntity<OverseasProfileResponse> createOverseasProfile(
⋮----
OverseasProfileResponse response = profileService.createOverseasProfile(memberId, request);
⋮----
public ResponseEntity<DomesticProfileResponse> getDomesticProfile(
⋮----
DomesticProfileResponse response = profileService.getDomesticProfile(memberId);
return ResponseEntity.ok(response);
⋮----
public ResponseEntity<OverseasProfileResponse> getOverseasProfile(
⋮----
OverseasProfileResponse response = profileService.getOverseasProfile(memberId);
⋮----
public ResponseEntity<DomesticProfileResponse> updateDomesticProfile(
⋮----
DomesticProfileResponse response = profileService.updateDomesticProfile(memberId, request);
⋮----
public ResponseEntity<OverseasProfileResponse> updateOverseasProfile(
⋮----
OverseasProfileResponse response = profileService.updateOverseasProfile(memberId, request);
⋮----
public ResponseEntity<Void> deleteDomesticProfile(
⋮----
profileService.deleteDomesticProfile(memberId);
return ResponseEntity.noContent().build();
⋮----
public ResponseEntity<Void> deleteOverseasProfile(
⋮----
profileService.deleteOverseasProfile(memberId);
⋮----
public ResponseEntity<List<DomesticProfileResponse>> getDomesticProfilesByCompletion(
⋮----
List<DomesticProfileResponse> profiles = profileService.getDomesticProfilesByCompletion(minCompletion);
return ResponseEntity.ok(profiles);
⋮----
public ResponseEntity<List<OverseasProfileResponse>> getOverseasProfilesByCountry(
⋮----
List<OverseasProfileResponse> profiles = profileService.getOverseasProfilesByCountry(country);
⋮----
public ResponseEntity<List<OverseasProfileResponse>> getOverseasProfilesRequiringCoordinator() {
⋮----
List<OverseasProfileResponse> profiles = profileService.getOverseasProfilesRequiringCoordinator();
⋮----
public ResponseEntity<List<OverseasProfileResponse>> getOverseasProfilesWithExpiringDocuments() {
⋮----
List<OverseasProfileResponse> profiles = profileService.getOverseasProfilesWithExpiringDocuments();
</file>

<file path="src/main/java/com/globalcarelink/GlobalCareLinkApplication.java">
public class GlobalCareLinkApplication {
public static void main(String[] args) {
SpringApplication.run(GlobalCareLinkApplication.class, args);
</file>

<file path="src/main/resources/application-test.yml">
spring:
  datasource:
    url: jdbc:sqlite::memory:
    driver-class-name: org.sqlite.JDBC
  
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: false
  
  logging:
    level:
      org.hibernate.SQL: WARN
      com.globalcarelink: INFO
</file>

<file path="src/main/resources/logback-spring.xml">
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    
    <!-- 로그 파일 경로 설정 -->
    <property name="LOG_PATH" value="./logs"/>
    <property name="LOG_FILE_NAME" value="lightcare"/>
    
    <!-- 콘솔 출력 패턴 (개발용) -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %highlight(%-5level) %cyan([%X{traceId}]) %yellow(%logger{36}) - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 일반 로그 파일 (INFO 이상) -->
    <appender name="FILE_INFO" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${LOG_FILE_NAME}.log</file>
        <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
            <providers>
                <timestamp/>
                <logLevel/>
                <loggerName/>
                <mdc/>
                <message/>
                <stackTrace/>
                <pattern>
                    <pattern>
                        {
                            "timestamp": "%d{yyyy-MM-dd HH:mm:ss.SSS}",
                            "level": "%level",
                            "thread": "%thread",
                            "logger": "%logger{40}",
                            "traceId": "%X{traceId:-}",
                            "userId": "%X{userId:-}",
                            "userEmail": "%X{userEmail:-}",
                            "requestUri": "%X{requestUri:-}",
                            "method": "%X{method:-}",
                            "clientIp": "%X{clientIp:-}",
                            "message": "%message",
                            "exception": "%exception"
                        }
                    </pattern>
                </pattern>
            </providers>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${LOG_FILE_NAME}.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>INFO</level>
        </filter>
    </appender>
    
    <!-- 에러 로그 파일 (ERROR만) -->
    <appender name="FILE_ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${LOG_FILE_NAME}-error.log</file>
        <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
            <providers>
                <timestamp/>
                <logLevel/>
                <loggerName/>
                <mdc/>
                <message/>
                <stackTrace/>
                <pattern>
                    <pattern>
                        {
                            "timestamp": "%d{yyyy-MM-dd HH:mm:ss.SSS}",
                            "level": "%level",
                            "thread": "%thread",
                            "logger": "%logger{40}",
                            "traceId": "%X{traceId:-}",
                            "userId": "%X{userId:-}",
                            "userEmail": "%X{userEmail:-}",
                            "requestUri": "%X{requestUri:-}",
                            "method": "%X{method:-}",
                            "clientIp": "%X{clientIp:-}",
                            "message": "%message",
                            "exception": "%exception",
                            "stackTrace": "%ex{full}"
                        }
                    </pattern>
                </pattern>
            </providers>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${LOG_FILE_NAME}-error.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>60</maxHistory>
        </rollingPolicy>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>
    
    <!-- 성능 로그 파일 (메서드 실행 시간 등) -->
    <appender name="FILE_PERFORMANCE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${LOG_FILE_NAME}-performance.log</file>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}] [%X{method}] %X{requestUri} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${LOG_FILE_NAME}-performance.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
    </appender>
    
    <!-- 프로파일별 설정 -->
    <springProfile name="dev,test">
        <root level="DEBUG">
            <appender-ref ref="CONSOLE"/>
            <appender-ref ref="FILE_INFO"/>
            <appender-ref ref="FILE_ERROR"/>
        </root>
    </springProfile>
    
    <springProfile name="prod">
        <root level="INFO">
            <appender-ref ref="FILE_INFO"/>
            <appender-ref ref="FILE_ERROR"/>
        </root>
    </springProfile>
    
    <!-- 특정 패키지 로그 레벨 설정 -->
    <logger name="com.globalcarelink" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE_INFO"/>
        <appender-ref ref="FILE_ERROR"/>
    </logger>
    
    <logger name="org.springframework.security" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE_INFO"/>
    </logger>
    
    <logger name="performance" level="INFO" additivity="false">
        <appender-ref ref="FILE_PERFORMANCE"/>
    </logger>
    
    <!-- SQL 로그 -->
    <logger name="org.hibernate.SQL" level="DEBUG"/>
    <logger name="org.hibernate.type.descriptor.sql.BasicBinder" level="TRACE"/>
    
</configuration>
</file>

<file path="src/test/java/com/globalcarelink/GlobalCareLinkApplicationTest.java">
class GlobalCareLinkApplicationTest {
⋮----
void contextLoads() {
</file>

<file path=".env.example">
# ===========================================
# LightCare 환경변수 설정 (예시 파일)
# 실제 사용 시 .env 파일로 복사 후 실제 값 입력
# ===========================================

# ===========================================
# 데이터베이스 설정 (SQLite - 파일 기반)
# ===========================================
DATABASE_URL=jdbc:sqlite:./data/lightcare.db
# SQLite는 사용자명/비밀번호 불필요

# ===========================================
# JWT 보안 설정 (필수 변경)
# ===========================================
JWT_SECRET=your_super_secret_jwt_key_with_256_bits_minimum_change_in_production
JWT_EXPIRATION=86400000

# ===========================================
# 이메일 설정 (Gmail SMTP - 무료)
# ===========================================
GMAIL_USERNAME=your-email@gmail.com
GMAIL_APP_PASSWORD=your_gmail_app_password
# Gmail 앱 비밀번호 발급 방법: https://support.google.com/accounts/answer/185833

# ===========================================
# 외부 API 키 (무료 플랜)
# ===========================================
# 카카오맵 API (월 30만건 무료)
KAKAO_API_KEY=your_kakao_map_api_key
KAKAO_REST_API_KEY=your_kakao_rest_api_key

# 공공데이터 API (발급받은 인증키)
PUBLIC_API_KEY=CCXHQiSSQ0J+RRaadSjmmS7ltxG/tlSVOYMjh45MmGne68ptgGAaAJVJti8nBazSjLemTAyb5gAuj43xq7fTog==

# 외교부 API
MOFA_API_KEY=your_mofa_api_key

# ===========================================
# GitHub 설정 (파일 저장용)
# ===========================================
GITHUB_TOKEN=your_github_personal_access_token
GITHUB_REPO_OWNER=dooseob
GITHUB_REPO_NAME=elderberry-files

# ===========================================
# 개발 환경 설정
# ===========================================
SPRING_PROFILES_ACTIVE=dev
LOG_LEVEL=debug
SERVER_PORT=8080

# Java 설정
JAVA_HOME=/path/to/jdk-21
JAVA_OPTS=-Xmx1g -Xms512m

# ===========================================
# 프론트엔드 환경변수 (Vite)
# ===========================================
VITE_API_BASE_URL=http://localhost:8080/api
VITE_WS_URL=ws://localhost:8080/ws
VITE_KAKAO_API_KEY=your_kakao_api_key
VITE_GITHUB_REPO_OWNER=dooseob
VITE_GITHUB_REPO_NAME=elderberry
VITE_DEV_MODE=true

# ===========================================
# 배포 환경 (Railway/Render)
# ===========================================
# Railway 배포시 자동 설정
RAILWAY_ENVIRONMENT=production
PORT=8080

# Render 배포시 설정
RENDER_EXTERNAL_URL=https://your-app.onrender.com

# ===========================================
# 모니터링 및 로깅
# ===========================================
# 개발 환경에서는 false, 운영에서는 true
ACTUATOR_ENABLED=false
METRICS_ENABLED=false
</file>

<file path=".gitignore">
# ===========================================
# LightCare 프로젝트 .gitignore
# ===========================================

# ===========================================
# 환경변수 및 보안 파일 (절대 커밋 금지!)
# ===========================================
.env
.env.local
.env.dev
.env.prod
.env.staging
*.env
secrets/
config/secrets.yml
application-secret.yml

# API 키 파일
api-keys.txt
keys/
credentials/

# ===========================================
# Java/Spring Boot
# ===========================================
# 컴파일된 클래스 파일
*.class
*.jar
*.war
*.ear
*.nar

# Gradle
.gradle/
build/
gradle-app.setting
!gradle-wrapper.jar
!**/src/main/**/build/
!**/src/test/**/build/

# Maven (혹시 사용할 경우)
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties

# Spring Boot
*.jar
*.war
*.orig
spring-boot-*.txt
.factorypath

# ===========================================
# 데이터베이스 (SQLite)
# ===========================================
*.db
*.sqlite
*.sqlite3
data/
database/
db/
# 테스트 DB 제외
!**/src/test/resources/**/*.db

# ===========================================
# 로그 파일
# ===========================================
*.log
logs/
log/
*.log.*
application.log
error.log
debug.log

# ===========================================
# IDE 설정 파일
# ===========================================
# IntelliJ IDEA
.idea/
*.iws
*.iml
*.ipr
out/
.idea_modules/

# Eclipse
.metadata
bin/
tmp/
*.tmp
*.bak
*.swp
*~.nib
local.properties
.settings/
.loadpath
.recommenders

# NetBeans
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

# Visual Studio Code
.vscode/
*.code-workspace

# ===========================================
# Node.js/React/Vite (프론트엔드)
# ===========================================
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# 빌드 결과물
dist/
dist-ssr/
build/

# 환경변수 (프론트엔드)
.env.local
.env.development.local
.env.test.local
.env.production.local

# ===========================================
# 운영체제
# ===========================================
# Windows
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
*.cab
*.msi
*.msix
*.msm
*.msp
*.lnk

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Linux
*~
.fuse_hidden*
.directory
.Trash-*
.nfs*

# ===========================================
# 임시 파일 및 백업
# ===========================================
*.tmp
*.temp
*.swp
*.swo
*~
.#*
\#*#
.#*
*.orig
*.rej

# ===========================================
# 테스트 관련
# ===========================================
# 테스트 결과
/test-results/
/coverage/
*.lcov
.nyc_output

# ===========================================
# 배포 관련
# ===========================================
# Docker
.dockerignore
Dockerfile.prod
docker-compose.override.yml

# 배포 아티팩트
deploy/
deployment/
.deploy/

# ===========================================
# 개발 도구
# ===========================================
# JProfiler
*.jpb

# YourKit
*.hprof

# JMeter
*.jmx
jmeter.log

# ===========================================
# 커스텀 제외 (프로젝트별)
# ===========================================
# 업로드된 파일들
uploads/
files/
media/
static/uploads/

# 캐시 파일
.cache/
*.cache

# 시크릿 백업
*.secret
*.private
*.key
*.pem
*.p12
*.pfx

# 개발 중 메모 파일
TODO.txt
NOTES.txt
scratch.txt
temp.md

# ===========================================
# 중요: 실수로 커밋하기 쉬운 파일들
# ===========================================
# 설정 백업
application-local.yml
application-dev.yml.backup
config-backup/

# 개발 테스트 파일
test-data.sql
sample-data.json
mock-data/

# 성능 테스트 결과
benchmark/
performance-test/
</file>

<file path="gradlew">
#!/bin/sh

# Gradle start up script for POSIX generated by Gradle.

DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

JAVA_EXE="java"
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        JAVA_EXE="$JAVA_HOME/jre/sh/java"
    else
        JAVA_EXE="$JAVA_HOME/bin/java"
    fi
fi

if [ ! -x "$JAVA_EXE" ] ; then
    echo "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
    echo ""
    echo "Please set the JAVA_HOME variable in your environment to match the"
    echo "location of your Java installation."
    exit 1
fi

CLASSPATH=gradle/wrapper/gradle-wrapper.jar

exec "$JAVA_EXE" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "-Dorg.gradle.appname=$APP_BASE_NAME" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
</file>

<file path="settings.gradle.kts">
rootProject.name = "global-care-link"
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(grep:*)",
      "Bash(mkdir:*)",
      "Bash(git init:*)",
      "Bash(git remote add:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git config:*)",
      "Bash(git push:*)",
      "Bash(java:*)",
      "Bash(./gradlew build:*)",
      "Bash(gradle:*)",
      "Bash(chmod:*)",
      "Bash(wc:*)",
      "Bash(./gradlew:*)",
      "Bash(export:*)",
      "Bash(ls:*)",
      "Bash(claude mcp add:*)",
      "Bash(claude mcp:*)",
      "Bash(npm install:*)",
      "Bash(/mnt/c/Program Files/Java/jdk-21/bin/java -version)",
      "Bash(cmd.exe:*)"
    ],
    "deny": []
  }
}
</file>

<file path="frontend/src/components/coordinator/CoordinatorCard.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import { 
  Star, 
  MapPin, 
  Globe, 
  Award, 
  Users, 
  Clock, 
  CheckCircle2,
  AlertCircle,
  Calendar,
  Phone
} from 'lucide-react';
import Card, { CardHeader, CardContent, CardFooter } from '@/components/ui/Card';
import Button from '@/components/ui/Button';
import { CoordinatorMatch, CoordinatorLanguageSkill } from '@/services/coordinatorApi';
⋮----
interface CoordinatorCardProps {
  coordinator: CoordinatorMatch;
  onSelect?: (coordinatorId: string) => void;
  onViewDetails?: (coordinatorId: string) => void;
  isSelected?: boolean;
  showActions?: boolean;
}
⋮----
const getScoreColor = (score: number) =>
⋮----
const getWorkloadStatus = (ratio: number) =>
⋮----
const renderLanguageSkills = (skills: CoordinatorLanguageSkill[]) =>
⋮----
</file>

<file path="frontend/src/components/coordinator/MatchingPreferencePanel.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import { X, Settings, Globe, MapPin, Clock, Shield } from 'lucide-react';
import { MatchingPreference } from '@/services/coordinatorApi';
import Card, { CardHeader, CardTitle, CardContent } from '@/components/ui/Card';
import Button from '@/components/ui/Button';
⋮----
interface MatchingPreferencePanelProps {
  preference: MatchingPreference;
  onChange: (preference: MatchingPreference) => void;
  onClose: () => void;
}
⋮----
const handleChange = (key: keyof MatchingPreference, value: any) =>
⋮----
onChange=
</file>

<file path="frontend/src/components/coordinator/MatchingStatsDashboard.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import { 
  X, 
  BarChart3, 
  Users, 
  Star, 
  Clock, 
  TrendingUp,
  CheckCircle2,
  Activity
} from 'lucide-react';
import { CoordinatorMatchingStatistics } from '@/services/coordinatorApi';
import Card, { CardHeader, CardTitle, CardContent } from '@/components/ui/Card';
import Button from '@/components/ui/Button';
⋮----
interface MatchingStatsDashboardProps {
  statistics: CoordinatorMatchingStatistics;
  onClose: () => void;
}
⋮----
const getSatisfactionLevel = (score: number) =>
⋮----
const getSuccessRateLevel = (rate: number) =>
⋮----
const getResponseTimeLevel = (time: number) =>
</file>

<file path="frontend/src/features/coordinator/CoordinatorMatchingWizard.tsx">
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Search, 
  Filter, 
  BarChart3, 
  Users, 
  Star,
  AlertCircle,
  CheckCircle2,
  Loader2
} from 'lucide-react';
import { useQuery } from '@tanstack/react-query';
⋮----
import { coordinatorMatchingApi, CoordinatorMatch, MatchingPreference, CoordinatorMatchingStatistics } from '@/services/coordinatorApi';
import { HealthAssessment } from '@/types/health';
import CoordinatorCard from '@/components/coordinator/CoordinatorCard';
import MatchingPreferencePanel from '@/components/coordinator/MatchingPreferencePanel';
import MatchingStatsDashboard from '@/components/coordinator/MatchingStatsDashboard';
import Card, { CardHeader, CardTitle, CardContent } from '@/components/ui/Card';
import Button from '@/components/ui/Button';
⋮----
interface CoordinatorMatchingWizardProps {
  assessmentId: number;
  assessment?: HealthAssessment;
  onMatchingComplete?: (selectedCoordinatorId: string) => void;
  onCancel?: () => void;
}
⋮----
const CoordinatorMatchingWizard: React.FC<CoordinatorMatchingWizardProps> = ({
  assessmentId,
  assessment,
  onMatchingComplete,
  onCancel,
}) =>
⋮----
const handlePreferenceChange = (newPreference: MatchingPreference) =>
⋮----
const handleCoordinatorSelect = (coordinatorId: string) =>
⋮----
const handleMatchingComplete = () =>
⋮----
const getMatchQualityStats = (matches?: CoordinatorMatch[]) =>
⋮----
onClick=
⋮----
console.log('코디네이터 상세 보기:', id);
</file>

<file path="frontend/src/services/coordinatorApi.ts">
import { HealthAssessment } from '@/types/health';
⋮----
export interface CoordinatorMatch {
  coordinatorId: string;
  name: string;
  matchScore: number;
  matchReason: string;
  experienceYears: number;
  successfulCases: number;
  customerSatisfaction: number;
  specialtyAreas: string[];
  compatibleCareGrades: number[];
  languageSkills: CoordinatorLanguageSkill[];
  availableWeekends: boolean;
  availableEmergency: boolean;
  workingRegions: string[];
  currentActiveCases: number;
  maxSimultaneousCases: number;
  workloadRatio: number;
}
⋮----
export interface CoordinatorLanguageSkill {
  language: string;
  proficiencyLevel: string;
  isNative: boolean;
  certificationLevel?: string;
}
⋮----
export interface MatchingPreference {
  preferredLanguage?: string;
  preferredRegion?: string;
  needsWeekendAvailability?: boolean;
  needsEmergencyAvailability?: boolean;
  minCustomerSatisfaction?: number;
  maxResults?: number;
  countryCode?: string;
  needsProfessionalConsultation?: boolean;
}
⋮----
export interface CoordinatorMatchingStatistics {
  totalActiveCoordinators: number;
  averageCustomerSatisfaction: number;
  availableCoordinators: number;
  totalSuccessfulMatches: number;
  overallMatchingSuccessRate: number;
  averageResponseTime: number;
}
⋮----
export interface MatchingSimulationRequest {
  healthAssessmentCount: number;
  coordinatorCount: number;
  simulationType: 'RANDOM' | 'REALISTIC' | 'STRESS_TEST';
  includeLanguageMatching?: boolean;
  includeSpecialtyMatching?: boolean;
  includeWorkloadOptimization?: boolean;
}
⋮----
export interface MatchingSimulationResult {
  totalHealthAssessments: number;
  totalCoordinators: number;
  successfulMatches: number;
  failedMatches: number;
  averageMatchingScore: number;
  matchingSuccessRate: number;
  executionTimeMs: number;
  simulationTime: string;
}
⋮----
class CoordinatorMatchingApi {
⋮----
async findMatches(assessmentId: number, preference?: MatchingPreference): Promise<CoordinatorMatch[]>
⋮----
async getStatistics(): Promise<CoordinatorMatchingStatistics>
⋮----
async runSimulation(request: MatchingSimulationRequest): Promise<MatchingSimulationResult>
⋮----
async getCoordinatorDetails(coordinatorId: string): Promise<CoordinatorMatch>
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Elderberry - 글로벌 요양원 구인구직 서비스</title>
    <meta name="description" content="재외동포를 위한 한국 요양원 매칭 서비스" />
    
    <!-- Noto Sans KR 폰트 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Pretendard 폰트 -->
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
⋮----
// 'elderberry' 테마 - 따뜻하고 평화로운 컬러 팔레트
</file>

<file path="src/main/java/com/globalcarelink/auth/Member.java">
import lombok.*;
⋮----
public class Member extends BaseEntity {
⋮----
public void updateProfile(String name, String phoneNumber, String language, String region) {
⋮----
public void updatePassword(String encodedPassword) {
⋮----
public void toggleJobSeekerStatus() {
⋮----
public void deactivate() {
⋮----
public void activate() {
⋮----
public boolean isOverseasUser() {
⋮----
public boolean isStaff() {
return this.role.isStaff();
</file>

<file path="src/main/java/com/globalcarelink/auth/MemberRole.java">
/**
 * 회원 역할 정의 - 사용자와 구직자 완전 분리
 * 
 * 역할 분류:
 * 1. 관리/운영진: ADMIN, FACILITY, COORDINATOR
 * 2. 환자/가족: USER_DOMESTIC, USER_OVERSEAS (요양 서비스 이용자)
 * 3. 구직자: JOB_SEEKER_DOMESTIC, JOB_SEEKER_OVERSEAS (요양 분야 취업 희망자)
 */
⋮----
// === 관리/운영진 ===
⋮----
// === 환자/가족 (요양 서비스 이용자) ===
⋮----
// === 구직자 (요양 분야 취업 희망자) ===
⋮----
// === 역할 분류 메서드 ===
⋮----
/**
     * 환자/가족 사용자 여부
     */
public boolean isPatientFamily() {
⋮----
/**
     * 구직자 여부
     */
public boolean isJobSeeker() {
⋮----
/**
     * 관리/운영진 여부
     */
public boolean isStaff() {
⋮----
/**
     * 해외 거주자 여부 (재외동포)
     */
public boolean isOverseas() {
⋮----
/**
     * 국내 거주자 여부
     */
public boolean isDomestic() {
⋮----
/**
     * 코디네이터 서비스 이용 가능 여부
     */
public boolean canUseCoordinatorService() {
return isPatientFamily(); // 환자/가족만 코디네이터 서비스 이용 가능
⋮----
/**
     * 구인구직 서비스 이용 가능 여부
     */
public boolean canUseJobService() {
return isJobSeeker() || this == FACILITY; // 구직자 + 시설회원(구인)
⋮----
/**
     * 건강 평가 서비스 이용 가능 여부
     */
public boolean canUseHealthAssessment() {
return isPatientFamily(); // 환자/가족만 건강 평가 가능
⋮----
// === 내부 열거형 ===
⋮----
/**
     * 회원 유형 분류
     */
⋮----
STAFF,          // 관리/운영진
PATIENT_FAMILY, // 환자/가족
JOB_SEEKER      // 구직자
</file>

<file path="src/main/java/com/globalcarelink/auth/MemberService.java">
public class MemberService {
⋮----
public MemberResponse register(MemberRegisterRequest request) {
validateRegisterRequest(request);
⋮----
if (memberRepository.existsByEmail(request.getEmail())) {
log.warn("회원가입 실패 - 이메일 중복: {}", SecurityUtil.maskEmail(request.getEmail()));
⋮----
// 입력값 sanitize
String sanitizedEmail = ValidationUtil.sanitizeInput(request.getEmail()).toLowerCase();
String sanitizedName = ValidationUtil.sanitizeInput(request.getName());
String sanitizedPhoneNumber = ValidationUtil.sanitizeInput(request.getPhoneNumber());
String sanitizedLanguage = ValidationUtil.sanitizeInput(request.getLanguage());
String sanitizedRegion = ValidationUtil.sanitizeInput(request.getRegion());
⋮----
Member member = Member.builder()
.email(sanitizedEmail)
.password(passwordEncoder.encode(request.getPassword()))
.name(sanitizedName)
.phoneNumber(sanitizedPhoneNumber)
.role(request.getRole())
.isJobSeeker(request.getIsJobSeeker())
.language(sanitizedLanguage)
.region(sanitizedRegion)
.build();
⋮----
Member savedMember = memberRepository.save(member);
⋮----
log.info("새 회원 가입 성공: email={}, role={}, region={}",
SecurityUtil.maskEmail(savedMember.getEmail()),
savedMember.getRole(),
savedMember.getRegion());
⋮----
return MemberResponse.from(savedMember);
⋮----
public TokenResponse login(LoginRequest request) {
Member member = memberRepository.findByEmail(request.getEmail())
.orElseThrow(() -> new CustomException.Unauthorized("이메일 또는 비밀번호가 올바르지 않습니다"));
⋮----
if (!member.getIsActive()) {
⋮----
if (!passwordEncoder.matches(request.getPassword(), member.getPassword())) {
⋮----
String token = jwtTokenProvider.createToken(member.getEmail(), member.getRole().name());
log.info("로그인 성공: email={}, role={}", member.getEmail(), member.getRole());
⋮----
return TokenResponse.of(token, jwtExpiration, MemberResponse.from(member));
⋮----
public MemberResponse findById(Long id) {
Member member = memberRepository.findById(id)
.orElseThrow(() -> new CustomException.NotFound("존재하지 않는 회원입니다"));
⋮----
return MemberResponse.from(member);
⋮----
public MemberResponse findByEmail(String email) {
Member member = memberRepository.findByEmail(email)
⋮----
public MemberResponse updateProfile(Long id, MemberUpdateRequest request) {
⋮----
member.updateProfile(
request.getName() != null ? request.getName() : member.getName(),
request.getPhoneNumber() != null ? request.getPhoneNumber() : member.getPhoneNumber(),
request.getLanguage() != null ? request.getLanguage() : member.getLanguage(),
request.getRegion() != null ? request.getRegion() : member.getRegion()
⋮----
log.info("프로필 업데이트: email={}", member.getEmail());
⋮----
public void toggleJobSeekerStatus(Long id) {
⋮----
member.toggleJobSeekerStatus();
log.info("구직자 상태 변경: email={}, isJobSeeker={}", member.getEmail(), member.getIsJobSeeker());
⋮----
public void deactivate(Long id) {
⋮----
member.deactivate();
log.info("회원 비활성화: email={}", member.getEmail());
⋮----
public List<MemberResponse> findByRole(MemberRole role) {
return memberRepository.findByRole(role).stream()
.map(MemberResponse::from)
.toList();
⋮----
public List<MemberResponse> findActiveJobSeekers() {
return memberRepository.findByIsJobSeekerAndIsActive(true, true).stream()
⋮----
public long countByRole(MemberRole role) {
return memberRepository.countByRole(role);
⋮----
private void validateRegisterRequest(MemberRegisterRequest request) {
// 이메일 검증
if (!ValidationUtil.isValidEmail(request.getEmail())) {
throw new CustomException.BadRequest(ValidationUtil.getEmailValidationMessage());
⋮----
// 보안 위험 패턴 검사
if (ValidationUtil.containsSuspiciousPattern(request.getEmail()) ||
ValidationUtil.containsSuspiciousPattern(request.getName()) ||
ValidationUtil.containsSuspiciousPattern(request.getRegion())) {
log.warn("회원가입 시도에서 의심스러운 패턴 감지: email={}", SecurityUtil.maskEmail(request.getEmail()));
⋮----
// SQL 인젝션 검사
if (SecurityUtil.containsSqlInjection(request.getEmail()) ||
SecurityUtil.containsSqlInjection(request.getName()) ||
SecurityUtil.containsSqlInjection(request.getRegion())) {
log.error("회원가입 시도에서 SQL 인젝션 패턴 감지: email={}", SecurityUtil.maskEmail(request.getEmail()));
⋮----
// 비밀번호 강도 검증
if (!SecurityUtil.isSecurePassword(request.getPassword())) {
throw new CustomException.BadRequest(ValidationUtil.getPasswordValidationMessage());
⋮----
// 전화번호 검증
if (StringUtils.hasText(request.getPhoneNumber()) &&
!ValidationUtil.isValidPhoneNumber(request.getPhoneNumber())) {
throw new CustomException.BadRequest(ValidationUtil.getPhoneValidationMessage());
⋮----
// 언어 코드 검증
if (!ValidationUtil.isValidLanguageCode(request.getLanguage())) {
⋮----
// 지역 검증
if (!ValidationUtil.isValidRegion(request.getRegion())) {
⋮----
// 이름 검증 (한글 이름인 경우)
if (StringUtils.hasText(request.getLanguage()) &&
request.getLanguage().startsWith("ko") &&
!ValidationUtil.isValidKoreanName(request.getName())) {
log.info("한글 이름이 아닌 사용자 가입: email={}, name length={}",
SecurityUtil.maskEmail(request.getEmail()),
request.getName().length());
⋮----
// 역할별 추가 검증
validateRoleSpecificRules(request);
⋮----
private void validateRoleSpecificRules(MemberRegisterRequest request) {
switch (request.getRole()) {
⋮----
if (!StringUtils.hasText(request.getRegion())) {
⋮----
if (!StringUtils.hasText(request.getLanguage()) || "ko".equals(request.getLanguage())) {
log.info("해외 사용자이지만 한국어 설정: email={}", SecurityUtil.maskEmail(request.getEmail()));
⋮----
if (Boolean.TRUE.equals(request.getIsJobSeeker())) {
⋮----
log.warn("관리자 계정 생성 시도: email={}", SecurityUtil.maskEmail(request.getEmail()));
</file>

<file path="src/main/java/com/globalcarelink/common/config/SecurityConfig.java">
public class SecurityConfig {
⋮----
public PasswordEncoder passwordEncoder() {
return new BCryptPasswordEncoder(12);
⋮----
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
⋮----
.csrf(AbstractHttpConfigurer::disable)
.cors(cors -> cors.configurationSource(corsConfigurationSource()))
.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
⋮----
.headers(headers -> headers
.frameOptions().deny()
.contentTypeOptions().and()
.httpStrictTransportSecurity(hstsConfig -> hstsConfig
.maxAgeInSeconds(31536000))
.referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN)
⋮----
.authorizeHttpRequests(auth -> auth
.requestMatchers("/api/auth/login", "/api/auth/register").permitAll()
.requestMatchers("/swagger-ui/**", "/v3/api-docs/**", "/swagger-resources/**").permitAll()
.requestMatchers("/actuator/health", "/actuator/info").permitAll()
.requestMatchers("/error").permitAll()
.requestMatchers("/api/health-assessments/statistics").hasRole("ADMIN")
.requestMatchers("/api/coordinator-matching/statistics").hasRole("ADMIN")
.requestMatchers("/api/coordinator-matching/simulate").hasRole("ADMIN")
.requestMatchers("/api/coordinator-matching/available").hasAnyRole("COORDINATOR", "ADMIN")
.requestMatchers("/api/health-assessments/**").hasAnyRole("USER_DOMESTIC", "USER_OVERSEAS", "COORDINATOR", "ADMIN")
.requestMatchers("/api/coordinator-matching/**").hasAnyRole("USER_DOMESTIC", "USER_OVERSEAS", "COORDINATOR", "ADMIN")
.requestMatchers("/api/profiles/**").hasAnyRole("USER_DOMESTIC", "USER_OVERSEAS", "COORDINATOR", "FACILITY", "ADMIN")
.requestMatchers("/api/members/**").hasAnyRole("USER_DOMESTIC", "USER_OVERSEAS", "COORDINATOR", "FACILITY", "ADMIN")
.anyRequest().authenticated()
⋮----
.addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider),
⋮----
.exceptionHandling(exceptions -> exceptions
.authenticationEntryPoint((request, response, authException) -> {
response.setStatus(401);
response.setContentType("application/json;charset=UTF-8");
response.getWriter().write("{\"error\":\"Unauthorized\",\"message\":\"인증이 필요합니다\"}");
⋮----
.accessDeniedHandler((request, response, accessDeniedException) -> {
response.setStatus(403);
⋮----
response.getWriter().write("{\"error\":\"Forbidden\",\"message\":\"접근 권한이 없습니다\"}");
⋮----
return http.build();
⋮----
public CorsConfigurationSource corsConfigurationSource() {
CorsConfiguration configuration = new CorsConfiguration();
⋮----
configuration.setAllowedOriginPatterns(Arrays.asList(
⋮----
configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"));
⋮----
configuration.setAllowedHeaders(Arrays.asList(
⋮----
configuration.setExposedHeaders(Arrays.asList(
⋮----
configuration.setAllowCredentials(true);
configuration.setMaxAge(3600L);
⋮----
UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
source.registerCorsConfiguration("/**", configuration);
</file>

<file path="src/main/java/com/globalcarelink/coordinator/CoordinatorCareSettings.java">
import lombok.*;
⋮----
public class CoordinatorCareSettings extends BaseEntity {
⋮----
public boolean isEligibleForCareGrade(Integer careGrade) {
⋮----
if (excludedCareGrades != null && excludedCareGrades.contains(careGrade)) return false;
if (preferredCareGrades != null && !preferredCareGrades.isEmpty()) {
return preferredCareGrades.contains(careGrade);
⋮----
public boolean hasSpecialty(String specialty) {
return specialtyAreas != null && specialtyAreas.contains(specialty);
⋮----
public double getSuccessRate() {
⋮----
public boolean canTakeNewCase() {
return isActive && getCurrentActiveCases() < maxSimultaneousCases;
⋮----
private int getCurrentActiveCases() {
⋮----
private void updateTimestamp() {
this.lastUpdated = LocalDateTime.now();
</file>

<file path="src/main/java/com/globalcarelink/coordinator/CoordinatorCareSettingsRepository.java">
public interface CoordinatorCareSettingsRepository extends JpaRepository<CoordinatorCareSettings, Long> {
⋮----
Optional<CoordinatorCareSettings> findByCoordinatorIdAndIsActiveTrue(String coordinatorId);
⋮----
List<CoordinatorCareSettings> findByIsActiveTrueOrderByPerformanceScoreDesc();
⋮----
List<CoordinatorCareSettings> findAvailableCoordinators();
⋮----
List<CoordinatorCareSettings> findEligibleForCareGrade(@Param("careGrade") Integer careGrade);
⋮----
List<CoordinatorCareSettings> findBySpecialty(@Param("specialty") String specialty);
⋮----
List<CoordinatorCareSettings> findByMinSatisfaction(@Param("minSatisfaction") Double minSatisfaction);
⋮----
List<CoordinatorCareSettings> findByWorkingRegion(@Param("region") String region);
⋮----
List<CoordinatorCareSettings> findByAvailableWeekendsAndIsActiveTrue(Boolean availableWeekends);
⋮----
List<CoordinatorCareSettings> findByAvailableEmergencyAndIsActiveTrue(Boolean availableEmergency);
⋮----
Double getAverageCustomerSatisfaction();
⋮----
Long getActiveCoordinatorCount();
</file>

<file path="src/main/java/com/globalcarelink/coordinator/CoordinatorCareSettingsService.java">
public class CoordinatorCareSettingsService {
⋮----
public Optional<CoordinatorCareSettings> getCoordinatorSettings(String coordinatorId) {
return careSettingsRepository.findByCoordinatorIdAndIsActiveTrue(coordinatorId);
⋮----
public CoordinatorCareSettings saveOrUpdateSettings(CoordinatorCareSettings settings) {
settings.setLastUpdated(LocalDateTime.now());
return careSettingsRepository.save(settings);
⋮----
public List<CoordinatorCareSettings> getCoordinatorsBySpecialty(String specialty) {
return careSettingsRepository.findBySpecialty(specialty);
⋮----
public List<CoordinatorCareSettings> getAvailableCoordinators() {
return careSettingsRepository.findAvailableCoordinators();
⋮----
public List<CoordinatorCareSettings> getCoordinatorsByMinSatisfaction(Double minSatisfaction) {
return careSettingsRepository.findByMinSatisfaction(minSatisfaction);
⋮----
public CoordinatorMatchingStatistics getMatchingStatistics() {
Long totalCoordinators = careSettingsRepository.getActiveCoordinatorCount();
Double avgSatisfaction = careSettingsRepository.getAverageCustomerSatisfaction();
List<CoordinatorCareSettings> availableCoordinators = getAvailableCoordinators();
⋮----
return CoordinatorMatchingStatistics.builder()
.totalActiveCoordinators(totalCoordinators)
.averageCustomerSatisfaction(avgSatisfaction)
.availableCoordinators(availableCoordinators.size())
.build();
⋮----
public MatchingSimulationResult runMatchingSimulation(MatchingSimulationRequest request) {
log.info("매칭 시뮬레이션 실행 - 평가수: {}, 코디네이터수: {}",
request.getHealthAssessmentCount(), request.getCoordinatorCount());
⋮----
long startTime = System.currentTimeMillis();
⋮----
List<CoordinatorCareSettings> allCoordinators = careSettingsRepository.findByIsActiveTrueOrderByPerformanceScoreDesc();
int totalMatches = Math.min(request.getHealthAssessmentCount(), allCoordinators.size() * 5);
⋮----
long endTime = System.currentTimeMillis();
⋮----
return MatchingSimulationResult.builder()
.totalHealthAssessments(request.getHealthAssessmentCount())
.totalCoordinators(request.getCoordinatorCount())
.successfulMatches(totalMatches)
.averageMatchingScore(4.2)
.executionTimeMs(executionTime)
.matchingSuccessRate((double) totalMatches / request.getHealthAssessmentCount() * 100)
</file>

<file path="src/main/java/com/globalcarelink/coordinator/CoordinatorMatch.java">
import lombok.*;
⋮----
public class CoordinatorMatch {
⋮----
public boolean isAvailable() {
⋮----
public String getAvailabilityStatus() {
⋮----
public String getExperienceLevel() {
⋮----
public String getSatisfactionLevel() {
</file>

<file path="src/main/java/com/globalcarelink/coordinator/CoordinatorMatchingController.java">
public class CoordinatorMatchingController {
⋮----
public ResponseEntity<List<CoordinatorMatch>> matchCoordinators(
⋮----
log.info("코디네이터 매칭 요청 - 평가ID: {}, 선호언어: {}",
healthAssessmentId, preference.getPreferredLanguage());
⋮----
Optional<HealthAssessment> assessmentOpt = healthAssessmentService.getAssessmentById(healthAssessmentId);
if (assessmentOpt.isEmpty()) {
return ResponseEntity.notFound().build();
⋮----
HealthAssessment assessment = assessmentOpt.get();
List<CoordinatorMatch> matches = matchingService.findOptimalMatches(assessment, preference);
⋮----
log.info("코디네이터 매칭 완료 - 평가ID: {}, 매칭결과: {}명", healthAssessmentId, matches.size());
⋮----
return ResponseEntity.ok(matches);
⋮----
public ResponseEntity<List<CoordinatorMatch>> getCoordinatorsByLanguage(
⋮----
log.info("언어별 코디네이터 조회 - 언어: {}, 국가: {}", languageCode, countryCode);
⋮----
MatchingPreference preference = MatchingPreference.builder()
.preferredLanguage(languageCode)
.countryCode(countryCode)
.needsProfessionalConsultation(needsProfessionalConsultation)
.build();
⋮----
HealthAssessment dummyAssessment = HealthAssessment.builder()
.mobilityLevel(2)
.eatingLevel(2)
.toiletLevel(2)
.communicationLevel(2)
.ltciGrade(4)
⋮----
dummyAssessment.calculateAdlScore();
⋮----
List<CoordinatorMatch> matches = matchingService.findOptimalMatches(dummyAssessment, preference);
⋮----
public ResponseEntity<List<CoordinatorCareSettings>> getCoordinatorsBySpecialty(
⋮----
log.info("전문분야별 코디네이터 조회 - 분야: {}", specialty);
⋮----
List<CoordinatorCareSettings> coordinators = coordinatorCareSettingsService.getCoordinatorsBySpecialty(specialty);
⋮----
return ResponseEntity.ok(coordinators);
⋮----
public ResponseEntity<List<CoordinatorCareSettings>> getAvailableCoordinators() {
⋮----
log.info("가용한 코디네이터 조회 요청");
⋮----
List<CoordinatorCareSettings> availableCoordinators = coordinatorCareSettingsService.getAvailableCoordinators();
⋮----
return ResponseEntity.ok(availableCoordinators);
⋮----
public ResponseEntity<CoordinatorMatchingStatistics> getMatchingStatistics() {
⋮----
log.info("코디네이터 매칭 통계 조회");
⋮----
CoordinatorMatchingStatistics statistics = coordinatorCareSettingsService.getMatchingStatistics();
⋮----
return ResponseEntity.ok(statistics);
⋮----
public ResponseEntity<MatchingSimulationResult> simulateMatching(
⋮----
log.info("매칭 시뮬레이션 시작 - 평가수: {}, 코디네이터수: {}",
request.getHealthAssessmentCount(), request.getCoordinatorCount());
⋮----
MatchingSimulationResult result = coordinatorCareSettingsService.runMatchingSimulation(request);
⋮----
return ResponseEntity.ok(result);
</file>

<file path="src/main/java/com/globalcarelink/coordinator/CoordinatorMatchingStatistics.java">
import lombok.*;
⋮----
public class CoordinatorMatchingStatistics {
⋮----
public String getSatisfactionLevel() {
⋮----
public double getAvailabilityRate() {
</file>

<file path="src/main/java/com/globalcarelink/coordinator/CoordinatorWorkloadOptimizer.java">
public class CoordinatorWorkloadOptimizer {
⋮----
public List<CoordinatorMatch> optimizeWorkloadDistribution(List<CoordinatorMatch> matches) {
return matches.stream()
.map(match -> {
double workloadScore = calculateWorkloadScore(match);
⋮----
double adjustedScore = match.getMatchScore() + (workloadScore * 0.3);
⋮----
String workloadReason = generateWorkloadReason(workloadScore);
String combinedReason = match.getMatchReason() + "\n" + workloadReason;
⋮----
return CoordinatorMatch.builder()
.coordinatorId(match.getCoordinatorId())
.name(match.getName())
.matchScore(Math.min(adjustedScore, 5.0))
.matchReason(combinedReason)
.experienceYears(match.getExperienceYears())
.successfulCases(match.getSuccessfulCases())
.customerSatisfaction(match.getCustomerSatisfaction())
.specialtyAreas(match.getSpecialtyAreas())
.compatibleCareGrades(match.getCompatibleCareGrades())
.languageSkills(match.getLanguageSkills())
.availableWeekends(match.getAvailableWeekends())
.availableEmergency(match.getAvailableEmergency())
.workingRegions(match.getWorkingRegions())
.currentActiveCases(match.getCurrentActiveCases())
.maxSimultaneousCases(match.getMaxSimultaneousCases())
.workloadRatio(match.getWorkloadRatio())
.build();
⋮----
.sorted(Comparator.comparing(CoordinatorMatch::getMatchScore).reversed())
.collect(Collectors.toList());
⋮----
private double calculateWorkloadScore(CoordinatorMatch match) {
double workloadRatio = match.getWorkloadRatio();
⋮----
private String generateWorkloadReason(double workloadScore) {
</file>

<file path="src/main/java/com/globalcarelink/coordinator/MatchingExplanationGenerator.java">
public class MatchingExplanationGenerator {
⋮----
public String generateMatchReason(CoordinatorCareSettings coordinator, HealthAssessment assessment, double matchScore) {
StringBuilder reason = new StringBuilder();
⋮----
if (isSpecialtyMatch(coordinator, assessment)) {
reason.append("🎯 전문 분야 완벽 매칭: ");
reason.append(getSpecialtyDescription(coordinator, assessment));
reason.append("\n");
⋮----
int experience = coordinator.getExperienceYears();
reason.append("📊 경력: ").append(experience).append("년 (");
if (experience >= 10) reason.append("최고 전문가");
else if (experience >= 5) reason.append("숙련 전문가");
else if (experience >= 2) reason.append("경력자");
else reason.append("신입");
reason.append(")\n");
⋮----
double satisfaction = coordinator.getCustomerSatisfaction();
reason.append("⭐ 고객 만족도: ").append(satisfaction).append("/5.0");
if (satisfaction >= 4.5) reason.append(" (최우수)");
else if (satisfaction >= 4.0) reason.append(" (우수)");
else if (satisfaction >= 3.5) reason.append(" (양호)");
⋮----
int successfulCases = coordinator.getSuccessfulCases();
int totalCases = coordinator.getTotalCases();
⋮----
reason.append("🏆 성공률: ").append(String.format("%.1f", successRate))
.append("% (").append(successfulCases).append("/").append(totalCases).append("건)\n");
⋮----
reason.append("💼 전체 매칭 점수: ").append(String.format("%.1f", matchScore)).append("/5.0");
⋮----
return reason.toString();
⋮----
private boolean isSpecialtyMatch(CoordinatorCareSettings coordinator, HealthAssessment assessment) {
if (coordinator.getSpecialtyAreas() == null || coordinator.getSpecialtyAreas().isEmpty()) {
⋮----
if (assessment.getLtciGrade() == 6 || assessment.getCommunicationLevel() == 3) {
if (coordinator.hasSpecialty("dementia")) return true;
⋮----
if (assessment.getCareGradeLevel() <= 2) {
if (coordinator.hasSpecialty("medical")) return true;
⋮----
if (assessment.getMobilityLevel() >= 2) {
if (coordinator.hasSpecialty("rehabilitation")) return true;
⋮----
private String getSpecialtyDescription(CoordinatorCareSettings coordinator, HealthAssessment assessment) {
StringBuilder description = new StringBuilder();
⋮----
if (coordinator.hasSpecialty("dementia")) {
description.append("치매 전문 케어");
⋮----
if (coordinator.hasSpecialty("medical")) {
if (description.length() > 0) description.append(", ");
description.append("의료 전문 케어");
⋮----
if (coordinator.hasSpecialty("rehabilitation")) {
⋮----
description.append("재활 전문 케어");
⋮----
return description.toString();
</file>

<file path="src/main/java/com/globalcarelink/coordinator/MatchingPreference.java">
import lombok.*;
⋮----
public class MatchingPreference {
⋮----
public Integer getMaxResults() {
⋮----
public Double getMinCustomerSatisfaction() {
</file>

<file path="src/main/java/com/globalcarelink/coordinator/MatchingSimulationRequest.java">
import lombok.*;
⋮----
public class MatchingSimulationRequest {
⋮----
private String simulationType; // RANDOM, REALISTIC, STRESS_TEST
</file>

<file path="src/main/java/com/globalcarelink/coordinator/MatchingSimulationResult.java">
import lombok.*;
⋮----
public class MatchingSimulationResult {
⋮----
private LocalDateTime simulationTime = LocalDateTime.now();
⋮----
public Integer getFailedMatches() {
⋮----
public String getPerformanceLevel() {
⋮----
public String getSuccessRateLevel() {
</file>

<file path="src/main/java/com/globalcarelink/coordinator/OptimizedCoordinatorMatchingService.java">
public class OptimizedCoordinatorMatchingService {
⋮----
public List<CoordinatorMatch> findOptimalMatches(HealthAssessment assessment, MatchingPreference preference) {
log.info("코디네이터 매칭 시작 - 케어등급: {}, 언어: {}",
assessment.getOverallCareGrade(), preference.getPreferredLanguage());
⋮----
List<CoordinatorCareSettings> eligibleCoordinators = filterByBasicQualifications(assessment);
log.debug("1단계 기본 자격 필터링: {}명", eligibleCoordinators.size());
⋮----
List<CoordinatorCareSettings> settingsMatched = filterByCoordinatorSettings(eligibleCoordinators, assessment);
log.debug("2단계 코디네이터 설정 매칭: {}명", settingsMatched.size());
⋮----
List<CoordinatorMatch> scoredMatches = calculateOptimalMatches(settingsMatched, assessment, preference);
log.debug("3단계 AI 스코어링 완료: {}건", scoredMatches.size());
⋮----
List<CoordinatorMatch> optimizedMatches = workloadOptimizer.optimizeWorkloadDistribution(scoredMatches);
log.info("매칭 완료 - 총 {}명의 코디네이터 매칭", optimizedMatches.size());
⋮----
return optimizedMatches.stream()
.limit(preference.getMaxResults())
.collect(Collectors.toList());
⋮----
public void evictMatchingCache() {
log.info("코디네이터 매칭 캐시 삭제");
⋮----
private List<CoordinatorCareSettings> filterByBasicQualifications(HealthAssessment assessment) {
Integer careGrade = assessment.getCareGradeLevel();
return careSettingsRepository.findEligibleForCareGrade(careGrade);
⋮----
private List<CoordinatorCareSettings> filterByCoordinatorSettings(
⋮----
return coordinators.stream()
.filter(coordinator -> coordinator.isEligibleForCareGrade(assessment.getCareGradeLevel()))
.filter(CoordinatorCareSettings::canTakeNewCase)
⋮----
private List<CoordinatorMatch> calculateOptimalMatches(
⋮----
.map(coordinator -> createCoordinatorMatch(coordinator, assessment, preference))
.sorted(Comparator.comparing(CoordinatorMatch::getMatchScore).reversed())
⋮----
private List<CoordinatorLanguageSkill> getCoordinatorLanguageSkills(String coordinatorId) {
return languageSkillRepository.findByCoordinatorIdAndIsActiveTrueOrderByPriorityOrder(coordinatorId);
⋮----
private CoordinatorMatch createCoordinatorMatch(
⋮----
double matchScore = calculateComprehensiveMatchScore(coordinator, assessment, preference);
String matchReason = explanationGenerator.generateMatchReason(coordinator, assessment, matchScore);
⋮----
List<CoordinatorLanguageSkill> languageSkills = getCoordinatorLanguageSkills(coordinator.getCoordinatorId());
⋮----
return CoordinatorMatch.builder()
.coordinatorId(coordinator.getCoordinatorId())
.matchScore(matchScore)
.matchReason(matchReason)
.experienceYears(coordinator.getExperienceYears())
.successfulCases(coordinator.getSuccessfulCases())
.customerSatisfaction(coordinator.getCustomerSatisfaction())
.specialtyAreas(coordinator.getSpecialtyAreas())
.compatibleCareGrades(coordinator.getPreferredCareGrades())
.languageSkills(languageSkills)
.availableWeekends(coordinator.getAvailableWeekends())
.availableEmergency(coordinator.getAvailableEmergency())
.workingRegions(coordinator.getWorkingRegions())
.currentActiveCases(getCurrentActiveCases(coordinator.getCoordinatorId()))
.maxSimultaneousCases(coordinator.getMaxSimultaneousCases())
.workloadRatio(calculateWorkloadRatio(coordinator))
.build();
⋮----
private double calculateComprehensiveMatchScore(
⋮----
score += calculateSpecialtyMatchScore(coordinator, assessment) * 0.4;
score += calculateExperienceScore(coordinator) * 0.25;
score += coordinator.getCustomerSatisfaction() * 0.2;
score += calculateLocationScore(coordinator, preference) * 0.1;
score += calculateAvailabilityBonus(coordinator) * 0.05;
⋮----
return Math.min(score, 5.0);
⋮----
private double calculateSpecialtyMatchScore(CoordinatorCareSettings coordinator, HealthAssessment assessment) {
⋮----
if (assessment.getLtciGrade() == 6 || assessment.getCommunicationLevel() == 3) {
if (coordinator.hasSpecialty("dementia")) {
⋮----
if (assessment.getCareGradeLevel() <= 2 || assessment.getCareTargetStatus() <= 2) {
if (coordinator.hasSpecialty("medical")) {
⋮----
if (assessment.getMobilityLevel() >= 2) {
if (coordinator.hasSpecialty("rehabilitation")) {
⋮----
return Math.min(specialtyScore, 5.0);
⋮----
private double calculateExperienceScore(CoordinatorCareSettings coordinator) {
int experience = coordinator.getExperienceYears();
double successRate = coordinator.getSuccessRate();
⋮----
return Math.min(baseScore + (successRate * 1.0), 5.0);
⋮----
private double calculateLocationScore(CoordinatorCareSettings coordinator, MatchingPreference preference) {
if (preference.getPreferredRegion() == null) return 3.0;
⋮----
if (coordinator.getWorkingRegions() != null &&
coordinator.getWorkingRegions().contains(preference.getPreferredRegion())) {
⋮----
private double calculateAvailabilityBonus(CoordinatorCareSettings coordinator) {
double workloadRatio = calculateWorkloadRatio(coordinator);
⋮----
private double calculateWorkloadRatio(CoordinatorCareSettings coordinator) {
int currentCases = getCurrentActiveCases(coordinator.getCoordinatorId());
return (double) currentCases / coordinator.getMaxSimultaneousCases();
⋮----
private int getCurrentActiveCases(String coordinatorId) {
</file>

<file path="src/main/java/com/globalcarelink/health/CareGradeCalculator.java">
/**
 * 케어 등급 계산기
 * KB라이프생명 기반 돌봄지수 체크 시스템 구현
 */
⋮----
public class CareGradeCalculator {
⋮----
/**
     * 종합 케어 등급 계산 (KB라이프생명 우선순위 로직 적용)
     * ADL 점수 + 장기요양보험 등급 + 돌봄대상자 상태를 종합하여 산출
     */
public CareGradeResult calculateComprehensiveGrade(HealthAssessment assessment) {
log.debug("케어 등급 계산 시작 - 회원: {}", assessment.getMemberId());
⋮----
// 1. 기본 ADL 점수 계산
int adlScore = calculateADLScore(assessment);
assessment.setAdlScore(adlScore);
⋮----
// 2. 장기요양보험 등급 반영
int ltciGrade = assessment.getLtciGrade() != null ? assessment.getLtciGrade() : 8;
⋮----
// 3. 돌봄대상자 상태 반영
int careTargetStatus = assessment.getCareTargetStatus() != null ? assessment.getCareTargetStatus() : 4;
⋮----
// 4. 종합 케어 등급 도출 (KB라이프생명 우선순위 방식)
CareGradeResult result = determineOverallCareGrade(assessment, adlScore, ltciGrade, careTargetStatus);
⋮----
// 5. 평가 결과 저장
assessment.setOverallCareGrade(result.getGradeName());
⋮----
log.info("케어 등급 계산 완료 - 회원: {}, ADL점수: {}, 종합등급: {}, 특화케어: {}",
assessment.getMemberId(), adlScore, result.getGradeName(), assessment.getSpecializedCareType());
⋮----
/**
     * ADL 점수 계산 (일상생활수행능력)
     * 각 영역별 가중치 적용:
     * - 걷기: 25%
     * - 식사: 20%  
     * - 배변: 30%
     * - 의사소통: 25%
     */
private int calculateADLScore(HealthAssessment assessment) {
int mobility = assessment.getMobilityLevel();
int eating = assessment.getEatingLevel();
int toilet = assessment.getToiletLevel();
int communication = assessment.getCommunicationLevel();
⋮----
// 각 영역별 가중치 적용 (1-3점을 25-75점으로 환산)
int mobilityScore = mobility * 25;        // 25, 50, 75
int eatingScore = eating * 20;            // 20, 40, 60
int toiletScore = toilet * 30;            // 30, 60, 90
int communicationScore = communication * 25; // 25, 50, 75
⋮----
log.debug("ADL 점수 계산 - 걷기:{}({}점), 식사:{}({}점), 배변:{}({}점), 의사소통:{}({}점) = 총 {}점",
⋮----
/**
     * 종합 케어 등급 결정 (KB라이프생명 우선순위 로직 적용)
     */
private CareGradeResult determineOverallCareGrade(HealthAssessment assessment, int adlScore, int ltciGrade, int careTargetStatus) {
⋮----
// === 1단계: 특수 상황 우선 적용 (KB라이프생명 방식) ===
if (careTargetStatus == 1) { // 6개월 이하 기대수명
return createHospiceGrade("생명위험 고도", "6개월 이하 기대수명 상태");
⋮----
if (careTargetStatus == 2) { // 회복 어려운 상황
return createHospiceGrade("생명위험 중등도", "질병 회복이 어려운 상황");
⋮----
if (careTargetStatus == 3) { // 완전 의존적 상태
return CareGradeResult.builder()
.gradeLevel(1)
.gradeName("1등급 (최중증 - 완전의존)")
.description("완전히 타인에게 의존적인 상태")
.recommendedFacilityTypes("전문 요양병원, A등급 요양시설")
.urgencyLevel("매우 높음")
.medicalSupport("의료진 24시간 상주")
.build();
⋮----
// === 2단계: 중증 지표 우선 체크 (KB라이프생명 방식) ===
⋮----
// 경관식(튜브 주입) 또는 배변활동 완전도움 → 최중증 판정
if ((assessment.getMealType() != null && assessment.getMealType() == 3) ||
(assessment.getToiletLevel() != null && assessment.getToiletLevel() == 3)) {
⋮----
.gradeName("1등급 (최중증 - 중증지표)")
.description("경관식 또는 배변활동 완전도움 필요")
.recommendedFacilityTypes("요양병원, 전문 간병시설")
⋮----
.medicalSupport("의료진 및 전문 간병인 상주")
⋮----
// === 3단계: 인지지원등급 (치매 전문 케어) ===
⋮----
return createDementiaGrade(assessment);
⋮----
// === 4단계: 장기요양등급 기반 판정 (1-5등급) ===
⋮----
return createLtciBasedGrade(ltciGrade, adlScore, assessment);
⋮----
// === 5단계: 장기요양등급이 없는 경우 ADL 점수 기반 추정 ===
return createAdlBasedGrade(adlScore, assessment);
⋮----
/**
     * 호스피스 케어 등급 생성
     */
private CareGradeResult createHospiceGrade(String severityLevel, String description) {
⋮----
.gradeLevel(0) // 특별 등급
.gradeName("호스피스 케어 (" + severityLevel + ")")
.description(description)
.recommendedFacilityTypes("호스피스 전문시설, 완화의료센터")
.urgencyLevel("최우선")
.medicalSupport("완화의료 전문의, 24시간 케어팀")
⋮----
/**
     * 치매 전문 케어 등급 생성 (질환 정보 반영)
     */
private CareGradeResult createDementiaGrade(HealthAssessment assessment) {
⋮----
// 질환 정보가 있으면 더 세밀한 추천
if (assessment != null && assessment.getDiseaseTypes() != null) {
if (assessment.getDiseaseTypes().contains("PARKINSON")) {
⋮----
} else if (assessment.getDiseaseTypes().contains("STROKE")) {
⋮----
.gradeLevel(6)
.gradeName("인지지원등급 (치매 전문)")
⋮----
.recommendedFacilityTypes(facilityTypes)
.urgencyLevel("높음")
.medicalSupport("치매 전문의, 인지재활 프로그램")
⋮----
/**
     * 장기요양보험 등급 기반 케어 등급 생성 (질환 정보 반영)
     */
private CareGradeResult createLtciBasedGrade(int ltciGrade, int adlScore, HealthAssessment assessment) {
⋮----
.gradeName("1등급 (최중증)")
.description("24시간 전문 케어가 필요한 최중증 상태")
.recommendedFacilityTypes("요양병원, A등급 요양시설")
⋮----
.medicalSupport("의사 및 간호사 24시간 상주")
⋮----
.gradeLevel(2)
.gradeName("2등급 (중증)")
.description("집중적인 의료 지원이 필요한 중증 상태")
.recommendedFacilityTypes("요양병원, A-B등급 요양시설")
⋮----
.medicalSupport("간호사 상주, 의사 정기 방문")
⋮----
.gradeLevel(3)
.gradeName("3등급 (중등증)")
.description("일상 활동에 상당한 도움이 필요한 상태")
.recommendedFacilityTypes("요양시설, 노인요양공동생활가정")
.urgencyLevel("보통")
.medicalSupport("요양보호사 및 간호조무사")
⋮----
.gradeLevel(4)
.gradeName("4등급 (경증)")
.description("부분적인 도움이 필요한 경증 상태")
.recommendedFacilityTypes("주야간보호시설, 재가복지시설")
.urgencyLevel("낮음")
.medicalSupport("요양보호사, 정기 건강 체크")
⋮----
.gradeLevel(5)
.gradeName("5등급 (경증)")
.description("기본적인 지원이 필요한 경증 상태")
.recommendedFacilityTypes("주야간보호시설, 방문요양서비스")
⋮----
.medicalSupport("요양보호사, 월간 건강 관리")
⋮----
/**
     * ADL 점수 기반 케어 등급 추정 (장기요양등급이 없는 경우, 질환 정보 반영)
     */
private CareGradeResult createAdlBasedGrade(int adlScore, HealthAssessment assessment) {
⋮----
.gradeName("추정 1등급 (최중증)")
.description("ADL 점수 기반 최중증으로 추정됨 (장기요양등급 신청 권장)")
.recommendedFacilityTypes("요양병원, 전문 요양시설")
⋮----
.medicalSupport("전문 의료진 상담 필요")
⋮----
.gradeName("추정 2등급 (중증)")
.description("ADL 점수 기반 중증으로 추정됨 (장기요양등급 신청 권장)")
.recommendedFacilityTypes("요양시설, 의료 연계 시설")
⋮----
.medicalSupport("의료진 정기 상담 권장")
⋮----
.gradeName("추정 3등급 (중등증)")
.description("ADL 점수 기반 중등증으로 추정됨")
.recommendedFacilityTypes("일반 요양시설, 공동생활가정")
⋮----
.medicalSupport("요양보호사 상주")
⋮----
.gradeName("추정 4등급 (경증)")
.description("ADL 점수 기반 경증으로 추정됨")
.recommendedFacilityTypes("주야간보호시설, 재가서비스")
⋮----
.medicalSupport("정기 건강 관리")
⋮----
.gradeName("추정 5등급 (경증)")
⋮----
.recommendedFacilityTypes("방문요양서비스, 생활 지원")
⋮----
.medicalSupport("월간 건강 체크")
⋮----
/**
     * 케어 등급 결과 DTO
     */
⋮----
public static class CareGradeResult {
private final int gradeLevel;           // 등급 레벨 (1-6)
private final String gradeName;         // 등급명
private final String description;       // 상태 설명
private final String recommendedFacilityTypes; // 추천 시설 유형
private final String urgencyLevel;      // 긴급도 (매우 높음, 높음, 보통, 낮음)
private final String medicalSupport;    // 필요한 의료 지원
⋮----
/**
         * 코디네이터 매칭 우선순위 반환
         */
public String getCoordinatorMatchingPriority() {
⋮----
/**
         * 예상 월 비용 범위 (단위: 만원)
         */
public String getEstimatedMonthlyCost() {
</file>

<file path="src/main/java/com/globalcarelink/health/HealthAssessmentRepository.java">
/**
 * 건강 상태 평가 데이터 접근 계층
 */
⋮----
public interface HealthAssessmentRepository extends JpaRepository<HealthAssessment, Long> {
⋮----
/**
     * 회원별 최신 건강 평가 조회
     */
Optional<HealthAssessment> findTopByMemberIdOrderByAssessmentDateDesc(String memberId);
⋮----
/**
     * 회원별 모든 건강 평가 이력 조회 (최신순)
     */
List<HealthAssessment> findByMemberIdOrderByAssessmentDateDesc(String memberId);
⋮----
/**
     * 회원별 건강 평가 페이징 조회
     */
Page<HealthAssessment> findByMemberIdOrderByAssessmentDateDesc(String memberId, Pageable pageable);
⋮----
/**
     * 완성된 평가만 조회
     */
⋮----
List<HealthAssessment> findCompleteAssessments();
⋮----
/**
     * 특정 케어 등급 범위의 평가 조회
     */
⋮----
List<HealthAssessment> findByCareGradeRange(@Param("minGrade") Integer minGrade, @Param("maxGrade") Integer maxGrade);
⋮----
/**
     * ADL 점수 범위별 조회
     */
⋮----
List<HealthAssessment> findByAdlScoreRange(@Param("minScore") Integer minScore, @Param("maxScore") Integer maxScore);
⋮----
/**
     * 재외동포 대상 평가 조회 (Member 엔티티와 조인 필요 - 추후 구현)
     */
⋮----
List<HealthAssessment> findOverseasKoreanAssessments();
⋮----
/**
     * 특정 기간 내 평가 조회
     */
List<HealthAssessment> findByAssessmentDateBetween(LocalDateTime startDate, LocalDateTime endDate);
⋮----
/**
     * 케어 등급별 통계
     */
⋮----
List<Map<String, Object>> findCareGradeStatistics();
⋮----
/**
     * ADL 점수 구간별 통계
     */
⋮----
List<Map<String, Object>> findAdlScoreDistribution();
⋮----
/**
     * 연령대별 케어 등급 분포
     */
⋮----
List<Map<String, Object>> findAgeGroupCareGradeDistribution();
⋮----
/**
     * 성별 케어 패턴 분석
     */
⋮----
List<Map<String, Object>> findGenderCarePatternAnalysis();
⋮----
/**
     * 최근 30일 평가 현황
     */
⋮----
Long countRecentAssessments(@Param("thirtyDaysAgo") LocalDateTime thirtyDaysAgo);
⋮----
/**
     * 미완성 평가 조회
     */
⋮----
List<HealthAssessment> findIncompleteAssessments();
⋮----
/**
     * 특정 회원의 평가 개선 추이 (ADL 점수 변화)
     */
⋮----
List<Map<String, Object>> findMemberAssessmentTrend(@Param("memberId") String memberId);
⋮----
/**
     * 호스피스 케어 대상자 조회 (careTargetStatus 1-2)
     */
⋮----
List<HealthAssessment> findHospiceCareTargets();
⋮----
/**
     * 치매 전문 케어 대상자 조회 (인지지원등급 + 의사소통 3등급)
     */
⋮----
List<HealthAssessment> findDementiaCareTargets();
⋮----
/**
     * 중증 환자 조회 (1-2등급 + 높은 ADL 점수)
     */
⋮----
List<HealthAssessment> findSevereCareTargets();
</file>

<file path="src/main/java/com/globalcarelink/profile/ProfileService.java">
public class ProfileService {
⋮----
public DomesticProfileResponse createDomesticProfile(Long memberId, DomesticProfileRequest request) {
validateDomesticProfileRequest(request);
⋮----
Member member = memberRepository.findById(memberId)
.orElseThrow(() -> new CustomException.NotFound("존재하지 않는 회원입니다"));
⋮----
validateMemberForDomesticProfile(member);
⋮----
if (domesticProfileRepository.existsByMemberId(memberId)) {
⋮----
DomesticProfile profile = DomesticProfile.builder()
.member(member)
.birthDate(request.getBirthDate())
.gender(sanitizeInput(request.getGender()))
.address(sanitizeInput(request.getAddress()))
.detailedAddress(sanitizeInput(request.getDetailedAddress()))
.postalCode(sanitizeInput(request.getPostalCode()))
.emergencyContactName(sanitizeInput(request.getEmergencyContactName()))
.emergencyContactPhone(sanitizeInput(request.getEmergencyContactPhone()))
.emergencyContactRelation(sanitizeInput(request.getEmergencyContactRelation()))
.healthInsuranceNumber(sanitizeInput(request.getHealthInsuranceNumber()))
.ltciGrade(request.getLtciGrade())
.ltciCertificateNumber(sanitizeInput(request.getLtciCertificateNumber()))
.preferredRegion(sanitizeInput(request.getPreferredRegion()))
.careLevel(sanitizeInput(request.getCareLevel()))
.specialNeeds(sanitizeInput(request.getSpecialNeeds()))
.familyVisitFrequency(sanitizeInput(request.getFamilyVisitFrequency()))
.budgetRange(sanitizeInput(request.getBudgetRange()))
.build();
⋮----
DomesticProfile savedProfile = domesticProfileRepository.save(profile);
⋮----
log.info("국내 프로필 생성: memberId={}, completionRate={}%",
memberId, savedProfile.getProfileCompletionPercentage());
⋮----
return DomesticProfileResponse.from(savedProfile);
⋮----
public OverseasProfileResponse createOverseasProfile(Long memberId, OverseasProfileRequest request) {
validateOverseasProfileRequest(request);
⋮----
validateMemberForOverseasProfile(member);
⋮----
if (overseasProfileRepository.existsByMemberId(memberId)) {
⋮----
OverseasProfile profile = OverseasProfile.builder()
⋮----
.overseasAddress(sanitizeInput(request.getOverseasAddress()))
.residenceCountry(sanitizeInput(request.getResidenceCountry()))
.residenceCity(sanitizeInput(request.getResidenceCity()))
.koreanAddress(sanitizeInput(request.getKoreanAddress()))
.koreanPostalCode(sanitizeInput(request.getKoreanPostalCode()))
.passportNumber(sanitizeInput(request.getPassportNumber()))
.passportExpiryDate(request.getPassportExpiryDate())
.visaStatus(sanitizeInput(request.getVisaStatus()))
.visaExpiryDate(request.getVisaExpiryDate())
.overseasContactName(sanitizeInput(request.getOverseasContactName()))
.overseasContactPhone(sanitizeInput(request.getOverseasContactPhone()))
.overseasContactRelation(sanitizeInput(request.getOverseasContactRelation()))
.koreaContactName(sanitizeInput(request.getKoreaContactName()))
.koreaContactPhone(sanitizeInput(request.getKoreaContactPhone()))
.koreaContactRelation(sanitizeInput(request.getKoreaContactRelation()))
.overseasInsuranceNumber(sanitizeInput(request.getOverseasInsuranceNumber()))
.overseasInsuranceProvider(sanitizeInput(request.getOverseasInsuranceProvider()))
.travelInsurance(sanitizeInput(request.getTravelInsurance()))
.entryPurpose(sanitizeInput(request.getEntryPurpose()))
.expectedStayDuration(sanitizeInput(request.getExpectedStayDuration()))
.preferredCommunicationMethod(sanitizeInput(request.getPreferredCommunicationMethod()))
.timeZonePreference(sanitizeInput(request.getTimeZonePreference()))
.preferredRegionInKorea(sanitizeInput(request.getPreferredRegionInKorea()))
⋮----
.culturalDietaryRequirements(sanitizeInput(request.getCulturalDietaryRequirements()))
.coordinatorRequired(request.getCoordinatorRequired())
⋮----
OverseasProfile savedProfile = overseasProfileRepository.save(profile);
⋮----
log.info("해외 프로필 생성: memberId={}, country={}, completionRate={}%",
memberId, savedProfile.getResidenceCountry(), savedProfile.getProfileCompletionPercentage());
⋮----
return OverseasProfileResponse.from(savedProfile);
⋮----
public DomesticProfileResponse getDomesticProfile(Long memberId) {
DomesticProfile profile = domesticProfileRepository.findByMemberId(memberId)
.orElseThrow(() -> new CustomException.NotFound("국내 프로필이 존재하지 않습니다"));
⋮----
return DomesticProfileResponse.from(profile);
⋮----
public OverseasProfileResponse getOverseasProfile(Long memberId) {
OverseasProfile profile = overseasProfileRepository.findByMemberId(memberId)
.orElseThrow(() -> new CustomException.NotFound("해외 프로필이 존재하지 않습니다"));
⋮----
return OverseasProfileResponse.from(profile);
⋮----
public DomesticProfileResponse updateDomesticProfile(Long memberId, DomesticProfileRequest request) {
⋮----
updateDomesticProfileFields(profile, request);
⋮----
log.info("국내 프로필 수정: memberId={}, completionRate={}%",
memberId, profile.getProfileCompletionPercentage());
⋮----
public OverseasProfileResponse updateOverseasProfile(Long memberId, OverseasProfileRequest request) {
⋮----
updateOverseasProfileFields(profile, request);
⋮----
log.info("해외 프로필 수정: memberId={}, completionRate={}%",
⋮----
public void deleteDomesticProfile(Long memberId) {
⋮----
domesticProfileRepository.delete(profile);
log.info("국내 프로필 삭제: memberId={}", memberId);
⋮----
public void deleteOverseasProfile(Long memberId) {
⋮----
overseasProfileRepository.delete(profile);
log.info("해외 프로필 삭제: memberId={}", memberId);
⋮----
public List<DomesticProfileResponse> getDomesticProfilesByCompletion(int minCompletionRate) {
validateCompletionRate(minCompletionRate);
⋮----
return domesticProfileRepository.findByProfileCompletionPercentageGreaterThanEqual(minCompletionRate)
.stream()
.map(DomesticProfileResponse::from)
.collect(Collectors.toList());
⋮----
public List<OverseasProfileResponse> getOverseasProfilesByCountry(String country) {
if (!StringUtils.hasText(country)) {
⋮----
return overseasProfileRepository.findByResidenceCountry(country)
⋮----
.map(OverseasProfileResponse::from)
⋮----
public List<OverseasProfileResponse> getOverseasProfilesRequiringCoordinator() {
return overseasProfileRepository.findRequiringCoordinator()
⋮----
public List<OverseasProfileResponse> getOverseasProfilesWithExpiringDocuments() {
LocalDate threeMonthsLater = LocalDate.now().plusMonths(3);
LocalDate oneMonthLater = LocalDate.now().plusMonths(1);
⋮----
List<OverseasProfile> expiringPassports = overseasProfileRepository.findByPassportExpiryDateBefore(threeMonthsLater);
List<OverseasProfile> expiringVisas = overseasProfileRepository.findByVisaExpiryDateBefore(oneMonthLater);
⋮----
return expiringPassports.stream()
.filter(profile -> expiringVisas.contains(profile) ||
profile.getPassportExpiryDate() != null &&
profile.getPassportExpiryDate().isBefore(threeMonthsLater))
⋮----
private void validateMemberForDomesticProfile(Member member) {
if (member.getRole() == MemberRole.USER_OVERSEAS) {
⋮----
private void validateMemberForOverseasProfile(Member member) {
if (member.getRole() == MemberRole.USER_DOMESTIC) {
⋮----
private void validateDomesticProfileRequest(DomesticProfileRequest request) {
⋮----
validateSecurityPatterns(request.getGender(), request.getAddress(),
request.getDetailedAddress(), request.getEmergencyContactName());
⋮----
if (request.getBirthDate() != null && request.getBirthDate().isAfter(LocalDate.now())) {
⋮----
if (request.getLtciGrade() != null && (request.getLtciGrade() < 1 || request.getLtciGrade() > 6)) {
⋮----
private void validateOverseasProfileRequest(OverseasProfileRequest request) {
⋮----
if (!StringUtils.hasText(request.getResidenceCountry())) {
⋮----
validateSecurityPatterns(request.getGender(), request.getOverseasAddress(),
request.getResidenceCountry(), request.getOverseasContactName());
⋮----
if (request.getPassportExpiryDate() != null && request.getPassportExpiryDate().isBefore(LocalDate.now())) {
⋮----
private void validateSecurityPatterns(String... inputs) {
⋮----
if (StringUtils.hasText(input)) {
if (ValidationUtil.containsSuspiciousPattern(input)) {
⋮----
if (SecurityUtil.containsSqlInjection(input)) {
log.warn("프로필 입력에서 SQL 인젝션 패턴 감지: {}", SecurityUtil.maskEmail(input));
⋮----
private void validateCompletionRate(int rate) {
⋮----
private String sanitizeInput(String input) {
return ValidationUtil.sanitizeInput(input);
⋮----
private void updateDomesticProfileFields(DomesticProfile profile, DomesticProfileRequest request) {
if (request.getBirthDate() != null || StringUtils.hasText(request.getGender()) ||
StringUtils.hasText(request.getAddress()) || StringUtils.hasText(request.getDetailedAddress()) ||
StringUtils.hasText(request.getPostalCode())) {
profile.updateBasicInfo(
request.getBirthDate(),
sanitizeInput(request.getGender()),
sanitizeInput(request.getAddress()),
sanitizeInput(request.getDetailedAddress()),
sanitizeInput(request.getPostalCode())
⋮----
if (StringUtils.hasText(request.getEmergencyContactName()) ||
StringUtils.hasText(request.getEmergencyContactPhone()) ||
StringUtils.hasText(request.getEmergencyContactRelation())) {
profile.updateEmergencyContact(
sanitizeInput(request.getEmergencyContactName()),
sanitizeInput(request.getEmergencyContactPhone()),
sanitizeInput(request.getEmergencyContactRelation())
⋮----
if (StringUtils.hasText(request.getHealthInsuranceNumber()) ||
request.getLtciGrade() != null ||
StringUtils.hasText(request.getLtciCertificateNumber())) {
profile.updateHealthInfo(
sanitizeInput(request.getHealthInsuranceNumber()),
request.getLtciGrade(),
sanitizeInput(request.getLtciCertificateNumber())
⋮----
if (StringUtils.hasText(request.getPreferredRegion()) ||
StringUtils.hasText(request.getCareLevel()) ||
StringUtils.hasText(request.getSpecialNeeds()) ||
StringUtils.hasText(request.getFamilyVisitFrequency()) ||
StringUtils.hasText(request.getBudgetRange())) {
profile.updateCareInfo(
sanitizeInput(request.getPreferredRegion()),
sanitizeInput(request.getCareLevel()),
sanitizeInput(request.getSpecialNeeds()),
sanitizeInput(request.getFamilyVisitFrequency()),
sanitizeInput(request.getBudgetRange())
⋮----
private void updateOverseasProfileFields(OverseasProfile profile, OverseasProfileRequest request) {
⋮----
StringUtils.hasText(request.getOverseasAddress()) || StringUtils.hasText(request.getResidenceCountry()) ||
StringUtils.hasText(request.getResidenceCity())) {
⋮----
sanitizeInput(request.getOverseasAddress()),
sanitizeInput(request.getResidenceCountry()),
sanitizeInput(request.getResidenceCity())
⋮----
if (StringUtils.hasText(request.getKoreanAddress()) ||
StringUtils.hasText(request.getKoreanPostalCode())) {
profile.updateKoreanAddress(
sanitizeInput(request.getKoreanAddress()),
sanitizeInput(request.getKoreanPostalCode())
⋮----
if (StringUtils.hasText(request.getPassportNumber()) ||
request.getPassportExpiryDate() != null ||
StringUtils.hasText(request.getVisaStatus()) ||
request.getVisaExpiryDate() != null) {
profile.updatePassportInfo(
sanitizeInput(request.getPassportNumber()),
request.getPassportExpiryDate(),
sanitizeInput(request.getVisaStatus()),
request.getVisaExpiryDate()
⋮----
if (StringUtils.hasText(request.getOverseasContactName()) ||
StringUtils.hasText(request.getOverseasContactPhone()) ||
StringUtils.hasText(request.getOverseasContactRelation())) {
profile.updateOverseasContact(
sanitizeInput(request.getOverseasContactName()),
sanitizeInput(request.getOverseasContactPhone()),
sanitizeInput(request.getOverseasContactRelation())
⋮----
if (StringUtils.hasText(request.getKoreaContactName()) ||
StringUtils.hasText(request.getKoreaContactPhone()) ||
StringUtils.hasText(request.getKoreaContactRelation())) {
profile.updateKoreaContact(
sanitizeInput(request.getKoreaContactName()),
sanitizeInput(request.getKoreaContactPhone()),
sanitizeInput(request.getKoreaContactRelation())
⋮----
if (StringUtils.hasText(request.getOverseasInsuranceNumber()) ||
StringUtils.hasText(request.getOverseasInsuranceProvider()) ||
StringUtils.hasText(request.getTravelInsurance())) {
profile.updateInsuranceInfo(
sanitizeInput(request.getOverseasInsuranceNumber()),
sanitizeInput(request.getOverseasInsuranceProvider()),
sanitizeInput(request.getTravelInsurance())
⋮----
if (StringUtils.hasText(request.getEntryPurpose()) ||
StringUtils.hasText(request.getExpectedStayDuration()) ||
StringUtils.hasText(request.getPreferredCommunicationMethod()) ||
StringUtils.hasText(request.getTimeZonePreference())) {
profile.updateTripInfo(
sanitizeInput(request.getEntryPurpose()),
sanitizeInput(request.getExpectedStayDuration()),
sanitizeInput(request.getPreferredCommunicationMethod()),
sanitizeInput(request.getTimeZonePreference())
⋮----
if (StringUtils.hasText(request.getPreferredRegionInKorea()) ||
StringUtils.hasText(request.getBudgetRange()) ||
⋮----
StringUtils.hasText(request.getCulturalDietaryRequirements())) {
⋮----
sanitizeInput(request.getPreferredRegionInKorea()),
sanitizeInput(request.getBudgetRange()),
⋮----
sanitizeInput(request.getCulturalDietaryRequirements())
⋮----
if (request.getCoordinatorRequired() != null) {
profile.setCoordinatorRequired(request.getCoordinatorRequired());
</file>

<file path="src/main/resources/application.yml">
spring:
  application:
    name: elderberry
  
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
  
  datasource:
    url: ${DATABASE_URL:jdbc:sqlite:./data/elderberry.db}
    driver-class-name: org.sqlite.JDBC
    username: ""
    password: ""
  
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.community.dialect.SQLiteDialect
        jdbc:
          time_zone: Asia/Seoul
  
  security:
    jwt:
      secret: ${JWT_SECRET:dev_jwt_secret_key_change_in_production}
      expiration: ${JWT_EXPIRATION:86400000}
  
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=1000,expireAfterWrite=30m
  
  mail:
    host: smtp.gmail.com
    port: 587
    username: ${GMAIL_USERNAME:}
    password: ${GMAIL_APP_PASSWORD:}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true

server:
  port: ${SERVER_PORT:8080}
  
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    com.globalcarelink: ${LOG_LEVEL:DEBUG}
    org.springframework.security: DEBUG

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: when-authorized

springdoc:
  api-docs:
    enabled: true
    path: /api-docs
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
    operationsSorter: method
    tagsSorter: alpha
</file>

<file path="src/test/java/com/globalcarelink/auth/AuthControllerTest.java">
class AuthControllerTest {
⋮----
void setUp() {
validRegisterRequest = MemberRegisterRequest.builder()
.email("test@example.com")
.password("password123")
.name("테스트사용자")
.phoneNumber("010-1234-5678")
.role(MemberRole.USER_DOMESTIC)
.isJobSeeker(true)
.language("ko")
.region("서울")
.build();
⋮----
invalidRegisterRequest = MemberRegisterRequest.builder()
.email("invalid-email")
.password("123")
.name("")
.role(null)
⋮----
validLoginRequest = new LoginRequest("test@example.com", "password123");
invalidLoginRequest = new LoginRequest("", "");
⋮----
memberResponse = MemberResponse.builder()
.id(1L)
⋮----
.isActive(true)
⋮----
tokenResponse = TokenResponse.builder()
.accessToken("jwt_access_token")
.tokenType("Bearer")
.expiresIn(86400000L)
.member(memberResponse)
⋮----
void register_Success() throws Exception {
given(memberService.register(validRegisterRequest)).willReturn(memberResponse);
⋮----
mockMvc.perform(post("/api/auth/register")
.with(csrf())
.contentType(MediaType.APPLICATION_JSON)
.content(objectMapper.writeValueAsString(validRegisterRequest)))
.andDo(print())
.andExpect(status().isCreated())
.andExpect(content().contentType(MediaType.APPLICATION_JSON))
.andExpect(jsonPath("$.id").value(1L))
.andExpect(jsonPath("$.email").value("test@example.com"))
.andExpect(jsonPath("$.name").value("테스트사용자"))
.andExpect(jsonPath("$.role").value("USER_DOMESTIC"))
.andExpect(jsonPath("$.isJobSeeker").value(true))
.andExpect(jsonPath("$.isActive").value(true))
.andExpect(jsonPath("$.language").value("ko"))
.andExpect(jsonPath("$.region").value("서울"));
⋮----
void register_Fail_ValidationError() throws Exception {
⋮----
.content(objectMapper.writeValueAsString(invalidRegisterRequest)))
⋮----
.andExpect(status().isBadRequest())
⋮----
.andExpect(jsonPath("$.status").value(400))
.andExpect(jsonPath("$.error").value("Bad Request"))
.andExpect(jsonPath("$.message").value("입력 값이 올바르지 않습니다"));
⋮----
void register_Fail_EmailConflict() throws Exception {
given(memberService.register(validRegisterRequest))
.willThrow(new CustomException.Conflict("이미 존재하는 이메일입니다"));
⋮----
.andExpect(status().isConflict())
⋮----
.andExpect(jsonPath("$.status").value(409))
.andExpect(jsonPath("$.error").value("Conflict"))
.andExpect(jsonPath("$.message").value("이미 존재하는 이메일입니다"));
⋮----
void register_Fail_InvalidJson() throws Exception {
⋮----
.content("invalid json"))
⋮----
.andExpect(status().isBadRequest());
⋮----
void login_Success() throws Exception {
given(memberService.login(validLoginRequest)).willReturn(tokenResponse);
⋮----
mockMvc.perform(post("/api/auth/login")
⋮----
.content(objectMapper.writeValueAsString(validLoginRequest)))
⋮----
.andExpect(status().isOk())
⋮----
.andExpect(jsonPath("$.accessToken").value("jwt_access_token"))
.andExpect(jsonPath("$.tokenType").value("Bearer"))
.andExpect(jsonPath("$.expiresIn").value(86400000L))
.andExpect(jsonPath("$.member.email").value("test@example.com"))
.andExpect(jsonPath("$.member.role").value("USER_DOMESTIC"));
⋮----
void login_Fail_ValidationError() throws Exception {
⋮----
.content(objectMapper.writeValueAsString(invalidLoginRequest)))
⋮----
void login_Fail_Unauthorized() throws Exception {
given(memberService.login(validLoginRequest))
.willThrow(new CustomException.Unauthorized("이메일 또는 비밀번호가 올바르지 않습니다"));
⋮----
.andExpect(status().isUnauthorized())
⋮----
.andExpect(jsonPath("$.status").value(401))
.andExpect(jsonPath("$.error").value("Unauthorized"))
.andExpect(jsonPath("$.message").value("이메일 또는 비밀번호가 올바르지 않습니다"));
⋮----
void login_Fail_Forbidden() throws Exception {
⋮----
.willThrow(new CustomException.Forbidden("비활성화된 계정입니다"));
⋮----
.andExpect(status().isForbidden())
⋮----
.andExpect(jsonPath("$.status").value(403))
.andExpect(jsonPath("$.message").value("비활성화된 계정입니다"));
⋮----
void getCurrentMember_Success() throws Exception {
given(memberService.findByEmail("test@example.com")).willReturn(memberResponse);
⋮----
mockMvc.perform(get("/api/auth/me")
.param("email", "test@example.com"))
⋮----
.andExpect(jsonPath("$.role").value("USER_DOMESTIC"));
⋮----
void getCurrentMember_Fail_NotFound() throws Exception {
given(memberService.findByEmail("notexist@example.com"))
.willThrow(new CustomException.NotFound("존재하지 않는 회원입니다"));
⋮----
.param("email", "notexist@example.com"))
⋮----
.andExpect(status().isNotFound())
⋮----
.andExpect(jsonPath("$.status").value(404))
.andExpect(jsonPath("$.message").value("존재하지 않는 회원입니다"));
⋮----
void getCurrentMember_Fail_Unauthenticated() throws Exception {
⋮----
.andExpect(status().isUnauthorized());
⋮----
void register_Fail_NoCsrfToken() throws Exception {
⋮----
.andExpect(status().isForbidden());
⋮----
void register_Fail_NoRequestBody() throws Exception {
⋮----
.contentType(MediaType.APPLICATION_JSON))
⋮----
void register_Fail_NoContentType() throws Exception {
⋮----
.andExpect(status().isUnsupportedMediaType());
</file>

<file path="src/test/java/com/globalcarelink/auth/MemberRepositoryTest.java">
class MemberRepositoryTest {
⋮----
void setUp() {
domesticUser = createMember("domestic@test.com", "국내사용자", MemberRole.USER_DOMESTIC, true, "ko", "서울");
overseasUser = createMember("overseas@test.com", "해외사용자", MemberRole.USER_OVERSEAS, true, "en", "New York");
coordinator = createMember("coordinator@test.com", "코디네이터", MemberRole.COORDINATOR, false, "ko", "서울");
facilityAdmin = createMember("facility@test.com", "시설관리자", MemberRole.FACILITY, false, "ko", "부산");
⋮----
entityManager.persistAndFlush(domesticUser);
entityManager.persistAndFlush(overseasUser);
entityManager.persistAndFlush(coordinator);
entityManager.persistAndFlush(facilityAdmin);
⋮----
void findByEmail_Success() {
Optional<Member> found = memberRepository.findByEmail("domestic@test.com");
⋮----
assertThat(found).isPresent();
assertThat(found.get().getName()).isEqualTo("국내사용자");
assertThat(found.get().getRole()).isEqualTo(MemberRole.USER_DOMESTIC);
⋮----
void findByEmail_NotFound() {
Optional<Member> found = memberRepository.findByEmail("notexist@test.com");
⋮----
assertThat(found).isEmpty();
⋮----
void existsByEmail_True() {
boolean exists = memberRepository.existsByEmail("coordinator@test.com");
⋮----
assertThat(exists).isTrue();
⋮----
void existsByEmail_False() {
boolean exists = memberRepository.existsByEmail("newuser@test.com");
⋮----
assertThat(exists).isFalse();
⋮----
void findByRole_Success() {
List<Member> users = memberRepository.findByRole(MemberRole.USER_DOMESTIC);
⋮----
assertThat(users).hasSize(1);
assertThat(users.get(0).getEmail()).isEqualTo("domestic@test.com");
⋮----
void findByIsJobSeekerAndIsActive_Success() {
List<Member> jobSeekers = memberRepository.findByIsJobSeekerAndIsActive(true, true);
⋮----
assertThat(jobSeekers).hasSize(2);
assertThat(jobSeekers).extracting(Member::getEmail)
.containsExactlyInAnyOrder("domestic@test.com", "overseas@test.com");
⋮----
void findActiveByRoleAndRegion_Success() {
List<Member> seoulCoordinators = memberRepository.findActiveByRoleAndRegion(MemberRole.COORDINATOR, "서울");
⋮----
assertThat(seoulCoordinators).hasSize(1);
assertThat(seoulCoordinators.get(0).getEmail()).isEqualTo("coordinator@test.com");
⋮----
void searchByKeyword_ByName() {
List<Member> results = memberRepository.searchByKeyword("국내");
⋮----
assertThat(results).hasSize(1);
assertThat(results.get(0).getName()).contains("국내");
⋮----
void searchByKeyword_ByEmail() {
List<Member> results = memberRepository.searchByKeyword("coordinator");
⋮----
assertThat(results.get(0).getEmail()).contains("coordinator");
⋮----
void countByRole_Success() {
long userCount = memberRepository.countByRole(MemberRole.USER_DOMESTIC);
long coordinatorCount = memberRepository.countByRole(MemberRole.COORDINATOR);
⋮----
assertThat(userCount).isEqualTo(1);
assertThat(coordinatorCount).isEqualTo(1);
⋮----
void countByRoleAndIsActive_Success() {
long activeUsers = memberRepository.countByRoleAndIsActive(MemberRole.USER_DOMESTIC, true);
⋮----
assertThat(activeUsers).isEqualTo(1);
⋮----
void findByRolesAndIsActive_Success() {
List<MemberRole> userRoles = List.of(MemberRole.USER_DOMESTIC, MemberRole.USER_OVERSEAS);
List<Member> users = memberRepository.findByRolesAndIsActive(userRoles, true);
⋮----
assertThat(users).hasSize(2);
assertThat(users).extracting(Member::getRole)
.containsExactlyInAnyOrder(MemberRole.USER_DOMESTIC, MemberRole.USER_OVERSEAS);
⋮----
private Member createMember(String email, String name, MemberRole role, boolean isJobSeeker, String language, String region) {
return Member.builder()
.email(email)
.password("encoded_password")
.name(name)
.phoneNumber("010-1234-5678")
.role(role)
.isJobSeeker(isJobSeeker)
.language(language)
.region(region)
.build();
</file>

<file path="src/test/java/com/globalcarelink/auth/MemberServiceTest.java">
class MemberServiceTest {
⋮----
void setUp() {
ReflectionTestUtils.setField(memberService, "jwtExpiration", 86400000L);
⋮----
testMember = Member.builder()
.id(1L)
.email("test@example.com")
.password("encoded_password")
.name("테스트사용자")
.phoneNumber("010-1234-5678")
.role(MemberRole.USER_DOMESTIC)
.isJobSeeker(true)
.language("ko")
.region("서울")
.build();
⋮----
registerRequest = MemberRegisterRequest.builder()
.email("new@example.com")
.password("plainPassword123")
.name("신규사용자")
.phoneNumber("010-9876-5432")
.role(MemberRole.USER_OVERSEAS)
.isJobSeeker(false)
.language("en")
.region("New York")
⋮----
loginRequest = new LoginRequest("test@example.com", "plainPassword123");
⋮----
void register_Success() {
given(memberRepository.existsByEmail(registerRequest.getEmail())).willReturn(false);
given(passwordEncoder.encode(registerRequest.getPassword())).willReturn("encoded_password");
given(memberRepository.save(any(Member.class))).willReturn(testMember);
⋮----
MemberResponse result = memberService.register(registerRequest);
⋮----
assertThat(result.getEmail()).isEqualTo(testMember.getEmail());
assertThat(result.getName()).isEqualTo(testMember.getName());
assertThat(result.getRole()).isEqualTo(testMember.getRole());
⋮----
then(memberRepository).should().existsByEmail(registerRequest.getEmail());
then(passwordEncoder).should().encode(registerRequest.getPassword());
then(memberRepository).should().save(any(Member.class));
⋮----
void register_Fail_EmailExists() {
given(memberRepository.existsByEmail(registerRequest.getEmail())).willReturn(true);
⋮----
assertThatThrownBy(() -> memberService.register(registerRequest))
.isInstanceOf(CustomException.Conflict.class)
.hasMessage("이미 존재하는 이메일입니다");
⋮----
then(passwordEncoder).should(never()).encode(anyString());
then(memberRepository).should(never()).save(any(Member.class));
⋮----
void login_Success() {
given(memberRepository.findByEmail(loginRequest.getEmail())).willReturn(Optional.of(testMember));
given(passwordEncoder.matches(loginRequest.getPassword(), testMember.getPassword())).willReturn(true);
given(jwtTokenProvider.createToken(testMember.getEmail(), testMember.getRole().name())).willReturn("jwt_token");
⋮----
TokenResponse result = memberService.login(loginRequest);
⋮----
assertThat(result.getAccessToken()).isEqualTo("jwt_token");
assertThat(result.getTokenType()).isEqualTo("Bearer");
assertThat(result.getExpiresIn()).isEqualTo(86400000L);
assertThat(result.getMember().getEmail()).isEqualTo(testMember.getEmail());
⋮----
then(memberRepository).should().findByEmail(loginRequest.getEmail());
then(passwordEncoder).should().matches(loginRequest.getPassword(), testMember.getPassword());
then(jwtTokenProvider).should().createToken(testMember.getEmail(), testMember.getRole().name());
⋮----
void login_Fail_EmailNotFound() {
given(memberRepository.findByEmail(loginRequest.getEmail())).willReturn(Optional.empty());
⋮----
assertThatThrownBy(() -> memberService.login(loginRequest))
.isInstanceOf(CustomException.Unauthorized.class)
.hasMessage("이메일 또는 비밀번호가 올바르지 않습니다");
⋮----
then(passwordEncoder).should(never()).matches(anyString(), anyString());
then(jwtTokenProvider).should(never()).createToken(anyString(), anyString());
⋮----
void login_Fail_PasswordMismatch() {
⋮----
given(passwordEncoder.matches(loginRequest.getPassword(), testMember.getPassword())).willReturn(false);
⋮----
void login_Fail_InactiveAccount() {
Member inactiveMember = Member.builder()
⋮----
.isActive(false)
⋮----
given(memberRepository.findByEmail(loginRequest.getEmail())).willReturn(Optional.of(inactiveMember));
⋮----
.isInstanceOf(CustomException.Forbidden.class)
.hasMessage("비활성화된 계정입니다");
⋮----
void findById_Success() {
given(memberRepository.findById(1L)).willReturn(Optional.of(testMember));
⋮----
MemberResponse result = memberService.findById(1L);
⋮----
assertThat(result.getId()).isEqualTo(1L);
⋮----
then(memberRepository).should().findById(1L);
⋮----
void findById_Fail_NotFound() {
given(memberRepository.findById(999L)).willReturn(Optional.empty());
⋮----
assertThatThrownBy(() -> memberService.findById(999L))
.isInstanceOf(CustomException.NotFound.class)
.hasMessage("존재하지 않는 회원입니다");
⋮----
then(memberRepository).should().findById(999L);
⋮----
void updateProfile_Success() {
MemberUpdateRequest updateRequest = new MemberUpdateRequest("새이름", "010-0000-0000", "en", "부산");
⋮----
MemberResponse result = memberService.updateProfile(1L, updateRequest);
⋮----
assertThat(result.getName()).isEqualTo("새이름");
assertThat(result.getPhoneNumber()).isEqualTo("010-0000-0000");
assertThat(result.getLanguage()).isEqualTo("en");
assertThat(result.getRegion()).isEqualTo("부산");
⋮----
void updateProfile_PartialUpdate() {
MemberUpdateRequest updateRequest = new MemberUpdateRequest("새이름", null, null, null);
⋮----
assertThat(result.getPhoneNumber()).isEqualTo(testMember.getPhoneNumber());
assertThat(result.getLanguage()).isEqualTo(testMember.getLanguage());
assertThat(result.getRegion()).isEqualTo(testMember.getRegion());
⋮----
void toggleJobSeekerStatus_Success() {
boolean originalStatus = testMember.getIsJobSeeker();
⋮----
memberService.toggleJobSeekerStatus(1L);
⋮----
assertThat(testMember.getIsJobSeeker()).isNotEqualTo(originalStatus);
⋮----
void deactivate_Success() {
⋮----
memberService.deactivate(1L);
⋮----
assertThat(testMember.getIsActive()).isFalse();
⋮----
void findByRole_Success() {
List<Member> members = List.of(testMember);
given(memberRepository.findByRole(MemberRole.USER_DOMESTIC)).willReturn(members);
⋮----
List<MemberResponse> result = memberService.findByRole(MemberRole.USER_DOMESTIC);
⋮----
assertThat(result).hasSize(1);
assertThat(result.get(0).getRole()).isEqualTo(MemberRole.USER_DOMESTIC);
⋮----
then(memberRepository).should().findByRole(MemberRole.USER_DOMESTIC);
⋮----
void findActiveJobSeekers_Success() {
List<Member> jobSeekers = List.of(testMember);
given(memberRepository.findByIsJobSeekerAndIsActive(true, true)).willReturn(jobSeekers);
⋮----
List<MemberResponse> result = memberService.findActiveJobSeekers();
⋮----
assertThat(result.get(0).getIsJobSeeker()).isTrue();
assertThat(result.get(0).getIsActive()).isTrue();
⋮----
then(memberRepository).should().findByIsJobSeekerAndIsActive(true, true);
⋮----
void countByRole_Success() {
given(memberRepository.countByRole(MemberRole.COORDINATOR)).willReturn(5L);
⋮----
long result = memberService.countByRole(MemberRole.COORDINATOR);
⋮----
assertThat(result).isEqualTo(5L);
then(memberRepository).should().countByRole(MemberRole.COORDINATOR);
</file>

<file path="src/test/java/com/globalcarelink/coordinator/CoordinatorMatchingControllerTest.java">
class CoordinatorMatchingControllerTest {
⋮----
void setUp() {
setupTestData();
⋮----
void matchCoordinators_Success() throws Exception {
given(healthAssessmentService.getAssessmentById(1L)).willReturn(Optional.of(testAssessment));
given(matchingService.findOptimalMatches(any(HealthAssessment.class), any(MatchingPreference.class)))
.willReturn(testMatches);
⋮----
mockMvc.perform(post("/api/coordinator-matching/match")
.with(csrf())
.param("healthAssessmentId", "1")
.contentType(MediaType.APPLICATION_JSON)
.content(objectMapper.writeValueAsString(testPreference)))
.andDo(print())
.andExpect(status().isOk())
.andExpect(content().contentType(MediaType.APPLICATION_JSON))
.andExpect(jsonPath("$").isArray())
.andExpect(jsonPath("$.length()").value(2))
.andExpect(jsonPath("$[0].coordinatorId").value("coordinator-001"))
.andExpect(jsonPath("$[0].matchScore").value(4.5))
.andExpect(jsonPath("$[0].matchReason").exists())
.andExpect(jsonPath("$[0].experienceYears").value(5))
.andExpect(jsonPath("$[0].customerSatisfaction").value(4.2));
⋮----
void matchCoordinators_NotFound() throws Exception {
given(healthAssessmentService.getAssessmentById(999L)).willReturn(Optional.empty());
⋮----
.param("healthAssessmentId", "999")
⋮----
.andExpect(status().isNotFound());
⋮----
void matchCoordinators_Unauthorized() throws Exception {
⋮----
.andExpect(status().isUnauthorized());
⋮----
void matchCoordinators_ValidationError() throws Exception {
MatchingPreference invalidPreference = MatchingPreference.builder()
.maxResults(-1)
.minCustomerSatisfaction(6.0)
.build();
⋮----
.content(objectMapper.writeValueAsString(invalidPreference)))
⋮----
.andExpect(status().isBadRequest());
⋮----
void getCoordinatorsBySpecialty_Success() throws Exception {
List<CoordinatorCareSettings> specialtyCoordinators = List.of(
createTestCoordinatorSettings("coordinator-001", Set.of("medical"))
⋮----
given(coordinatorCareSettingsService.getCoordinatorsBySpecialty("medical"))
.willReturn(specialtyCoordinators);
⋮----
mockMvc.perform(get("/api/coordinator-matching/specialty/medical"))
⋮----
.andExpect(jsonPath("$.length()").value(1))
.andExpect(jsonPath("$[0].coordinatorId").value("coordinator-001"));
⋮----
void getAvailableCoordinators_Success() throws Exception {
List<CoordinatorCareSettings> availableCoordinators = List.of(
createTestCoordinatorSettings("coordinator-001", Set.of("medical")),
createTestCoordinatorSettings("coordinator-002", Set.of("rehabilitation"))
⋮----
given(coordinatorCareSettingsService.getAvailableCoordinators())
.willReturn(availableCoordinators);
⋮----
mockMvc.perform(get("/api/coordinator-matching/available"))
⋮----
.andExpect(jsonPath("$.length()").value(2));
⋮----
void getAvailableCoordinators_Forbidden() throws Exception {
⋮----
.andExpect(status().isForbidden());
⋮----
void getMatchingStatistics_Success() throws Exception {
given(coordinatorCareSettingsService.getMatchingStatistics())
.willReturn(testStatistics);
⋮----
mockMvc.perform(get("/api/coordinator-matching/statistics"))
⋮----
.andExpect(jsonPath("$.totalActiveCoordinators").value(50))
.andExpect(jsonPath("$.averageCustomerSatisfaction").value(4.1))
.andExpect(jsonPath("$.availableCoordinators").value(30))
.andExpect(jsonPath("$.totalSuccessfulMatches").value(1200))
.andExpect(jsonPath("$.overallMatchingSuccessRate").value(85.5))
.andExpect(jsonPath("$.averageResponseTime").value(12.3));
⋮----
void getMatchingStatistics_Forbidden() throws Exception {
⋮----
void simulateMatching_Success() throws Exception {
MatchingSimulationRequest simulationRequest = MatchingSimulationRequest.builder()
.healthAssessmentCount(100)
.coordinatorCount(20)
.simulationType("REALISTIC")
.includeLanguageMatching(true)
.includeSpecialtyMatching(true)
.includeWorkloadOptimization(true)
⋮----
MatchingSimulationResult simulationResult = MatchingSimulationResult.builder()
.totalHealthAssessments(100)
.totalCoordinators(20)
.successfulMatches(95)
.averageMatchingScore(4.2)
.matchingSuccessRate(95.0)
.executionTimeMs(1500L)
⋮----
given(coordinatorCareSettingsService.runMatchingSimulation(any(MatchingSimulationRequest.class)))
.willReturn(simulationResult);
⋮----
mockMvc.perform(post("/api/coordinator-matching/simulate")
⋮----
.content(objectMapper.writeValueAsString(simulationRequest)))
⋮----
.andExpect(jsonPath("$.totalHealthAssessments").value(100))
.andExpect(jsonPath("$.totalCoordinators").value(20))
.andExpect(jsonPath("$.successfulMatches").value(95))
.andExpect(jsonPath("$.averageMatchingScore").value(4.2))
.andExpect(jsonPath("$.matchingSuccessRate").value(95.0))
.andExpect(jsonPath("$.executionTimeMs").value(1500));
⋮----
void simulateMatching_ValidationError() throws Exception {
MatchingSimulationRequest invalidRequest = MatchingSimulationRequest.builder()
.healthAssessmentCount(-1)
.coordinatorCount(0)
.simulationType("INVALID")
⋮----
.content(objectMapper.writeValueAsString(invalidRequest)))
⋮----
void postWithoutCsrf_Forbidden() throws Exception {
⋮----
void postWithWrongContentType_UnsupportedMediaType() throws Exception {
⋮----
.contentType(MediaType.TEXT_PLAIN)
.content("invalid content"))
⋮----
.andExpect(status().isUnsupportedMediaType());
⋮----
private void setupTestData() {
testAssessment = HealthAssessment.builder()
.id(1L)
.memberId("test-member-001")
.mobilityLevel(2)
.eatingLevel(2)
.toiletLevel(2)
.communicationLevel(2)
.ltciGrade(3)
.careTargetStatus(4)
.mealType(1)
.adlScore(180)
.overallCareGrade("3등급 (중등증)")
⋮----
testPreference = MatchingPreference.builder()
.preferredLanguage("ko")
.preferredRegion("seoul")
.maxResults(20)
.minCustomerSatisfaction(3.0)
.needsWeekendAvailability(false)
.needsEmergencyAvailability(false)
⋮----
CoordinatorMatch match1 = CoordinatorMatch.builder()
.coordinatorId("coordinator-001")
.name("김코디네이터")
.matchScore(4.5)
.matchReason("전문 분야 매칭 및 높은 경력")
.experienceYears(5)
.successfulCases(120)
.customerSatisfaction(4.2)
.specialtyAreas(Set.of("medical", "elderly_care"))
.languageSkills(List.of())
.availableWeekends(true)
.availableEmergency(true)
.workingRegions(Set.of("seoul", "incheon"))
.currentActiveCases(3)
.maxSimultaneousCases(8)
.workloadRatio(0.375)
⋮----
CoordinatorMatch match2 = CoordinatorMatch.builder()
.coordinatorId("coordinator-002")
.name("이코디네이터")
.matchScore(4.0)
.matchReason("지역 매칭 및 적정 경력")
.experienceYears(3)
.successfulCases(80)
.customerSatisfaction(3.8)
.specialtyAreas(Set.of("rehabilitation"))
⋮----
.availableWeekends(false)
.availableEmergency(false)
.workingRegions(Set.of("seoul", "gyeonggi"))
.currentActiveCases(2)
.maxSimultaneousCases(6)
.workloadRatio(0.333)
⋮----
testMatches = List.of(match1, match2);
⋮----
testStatistics = CoordinatorMatchingStatistics.builder()
.totalActiveCoordinators(50L)
.averageCustomerSatisfaction(4.1)
.availableCoordinators(30)
.totalSuccessfulMatches(1200L)
.overallMatchingSuccessRate(85.5)
.averageResponseTime(12.3)
⋮----
private CoordinatorCareSettings createTestCoordinatorSettings(String coordinatorId, Set<String> specialtyAreas) {
return CoordinatorCareSettings.builder()
.coordinatorId(coordinatorId)
.baseCareLevel(1)
.maxCareLevel(5)
⋮----
.successfulCases(100)
.customerSatisfaction(4.0)
⋮----
.specialtyAreas(specialtyAreas)
.workingRegions(Set.of("seoul"))
⋮----
.isActive(true)
</file>

<file path="src/test/java/com/globalcarelink/coordinator/CoordinatorMatchingServiceIntegrationTest.java">
class CoordinatorMatchingServiceIntegrationTest {
⋮----
void setUp() {
setupTestData();
⋮----
void findOptimalMatches_BasicMatching() {
MatchingPreference preference = MatchingPreference.builder()
.maxResults(10)
.minCustomerSatisfaction(3.0)
.build();
⋮----
List<CoordinatorMatch> matches = matchingService.findOptimalMatches(testAssessment, preference);
⋮----
assertThat(matches).isNotEmpty();
assertThat(matches).hasSizeLessThanOrEqualTo(10);
assertThat(matches.get(0).getMatchScore()).isGreaterThan(0.0);
⋮----
matches.forEach(match -> {
assertThat(match.getCustomerSatisfaction()).isGreaterThanOrEqualTo(3.0);
assertThat(match.getMatchReason()).isNotBlank();
⋮----
void findOptimalMatches_LanguageMatching() {
⋮----
.preferredLanguage("ko")
.maxResults(5)
⋮----
boolean hasKorean = match.getLanguageSkills().stream()
.anyMatch(skill -> "ko".equals(skill.getLanguageCode()));
assertThat(hasKorean).isTrue();
⋮----
void findOptimalMatches_WorkloadOptimization() {
⋮----
.maxResults(20)
⋮----
assertThat(match.getWorkloadRatio()).isLessThanOrEqualTo(1.0);
⋮----
previousWorkloadRatio = match.getWorkloadRatio();
⋮----
void findOptimalMatches_SpecialtyMatching() {
testAssessment.setLtciGrade(2);
⋮----
.needsProfessionalConsultation(true)
⋮----
assertThat(match.getSpecialtyAreas()).isNotEmpty();
⋮----
void findOptimalMatches_WeekendAvailability() {
⋮----
.needsWeekendAvailability(true)
⋮----
assertThat(match.getAvailableWeekends()).isTrue();
⋮----
void findOptimalMatches_EmergencyAvailability() {
⋮----
.needsEmergencyAvailability(true)
⋮----
assertThat(match.getAvailableEmergency()).isTrue();
⋮----
void findOptimalMatches_RegionalMatching() {
⋮----
.preferredRegion("seoul")
⋮----
assertThat(match.getWorkingRegions()).contains("seoul");
⋮----
void findOptimalMatches_ScoreOrdering() {
⋮----
for (int i = 0; i < matches.size() - 1; i++) {
assertThat(matches.get(i).getMatchScore())
.isGreaterThanOrEqualTo(matches.get(i + 1).getMatchScore());
⋮----
void findOptimalMatches_NoMatches() {
⋮----
.minCustomerSatisfaction(5.0)
⋮----
assertThat(matches).isEmpty();
⋮----
private void setupTestData() {
createTestHealthAssessment();
createTestCoordinators();
createTestLanguageSkills();
⋮----
private void createTestHealthAssessment() {
HealthAssessmentCreateRequest request = HealthAssessmentCreateRequest.builder()
.memberId("test-member-001")
.birthYear(1950)
.gender("M")
.mobilityLevel(3)
.eatingLevel(2)
.toiletLevel(3)
.communicationLevel(2)
.careTargetStatus(2)
.mealType(1)
.diseaseTypes("고혈압, 당뇨")
.notes("주간 돌봄 필요")
⋮----
testAssessment = healthAssessmentService.createAssessment(request);
⋮----
private void createTestCoordinators() {
coordinator1 = CoordinatorCareSettings.builder()
.coordinatorId("coordinator-001")
.baseCareLevel(1)
.maxCareLevel(3)
.experienceYears(5)
.successfulCases(120)
.customerSatisfaction(4.2)
.maxSimultaneousCases(8)
.specialtyAreas(Set.of("medical", "elderly_care"))
.workingRegions(Set.of("seoul", "incheon"))
.availableWeekends(true)
.availableEmergency(true)
.isActive(true)
⋮----
coordinator2 = CoordinatorCareSettings.builder()
.coordinatorId("coordinator-002")
.baseCareLevel(2)
.maxCareLevel(5)
.experienceYears(3)
.successfulCases(80)
.customerSatisfaction(3.8)
.maxSimultaneousCases(6)
.specialtyAreas(Set.of("rehabilitation"))
.workingRegions(Set.of("seoul", "gyeonggi"))
.availableWeekends(false)
.availableEmergency(false)
⋮----
careSettingsRepository.save(coordinator1);
careSettingsRepository.save(coordinator2);
⋮----
private void createTestLanguageSkills() {
CoordinatorLanguageSkill skill1 = CoordinatorLanguageSkill.builder()
⋮----
.languageCode("ko")
.languageName("한국어")
.proficiencyLevel(CoordinatorLanguageSkill.LanguageProficiency.NATIVE)
.certification("C2")
⋮----
CoordinatorLanguageSkill skill2 = CoordinatorLanguageSkill.builder()
⋮----
.languageCode("en")
.languageName("영어")
.proficiencyLevel(CoordinatorLanguageSkill.LanguageProficiency.BUSINESS)
.certification("B2")
⋮----
CoordinatorLanguageSkill skill3 = CoordinatorLanguageSkill.builder()
⋮----
languageSkillRepository.save(skill1);
languageSkillRepository.save(skill2);
languageSkillRepository.save(skill3);
</file>

<file path="src/test/java/com/globalcarelink/e2e/HealthAssessmentToCoordinatorMatchingE2ETest.java">
class HealthAssessmentToCoordinatorMatchingE2ETest {
⋮----
void setUp() {
setupTestCoordinators();
⋮----
void completeE2EFlow_HealthAssessmentToMatching() throws Exception {
HealthAssessmentCreateRequest assessmentRequest = HealthAssessmentCreateRequest.builder()
.memberId("e2e-test-member")
.gender("M")
.birthYear(1950)
.mobilityLevel(2)
.eatingLevel(2)
.toiletLevel(3)
.communicationLevel(2)
.ltciGrade(3)
.careTargetStatus(4)
.mealType(1)
.diseaseTypes("고혈압, 당뇨")
.build();
⋮----
MvcResult assessmentResult = mockMvc.perform(post("/api/health-assessments")
.with(csrf())
.contentType(MediaType.APPLICATION_JSON)
.content(objectMapper.writeValueAsString(assessmentRequest)))
.andDo(print())
.andExpect(status().isCreated())
.andExpect(jsonPath("$.id").exists())
.andExpect(jsonPath("$.memberId").value("e2e-test-member"))
.andExpect(jsonPath("$.adlScore").exists())
.andExpect(jsonPath("$.overallCareGrade").exists())
.andReturn();
⋮----
String assessmentJson = assessmentResult.getResponse().getContentAsString();
HealthAssessment createdAssessment = objectMapper.readValue(assessmentJson, HealthAssessment.class);
Long assessmentId = createdAssessment.getId();
⋮----
assertThat(assessmentId).isNotNull();
assertThat(createdAssessment.getAdlScore()).isEqualTo(180);
⋮----
MatchingPreference matchingPreference = MatchingPreference.builder()
.preferredLanguage("ko")
.preferredRegion("seoul")
.maxResults(10)
.minCustomerSatisfaction(3.0)
.needsWeekendAvailability(false)
.needsEmergencyAvailability(false)
⋮----
mockMvc.perform(post("/api/coordinator-matching/match")
⋮----
.param("healthAssessmentId", assessmentId.toString())
⋮----
.content(objectMapper.writeValueAsString(matchingPreference)))
⋮----
.andExpect(status().isOk())
.andExpect(content().contentType(MediaType.APPLICATION_JSON))
.andExpect(jsonPath("$").isArray())
.andExpect(jsonPath("$.length()").value(2))
.andExpect(jsonPath("$[0].coordinatorId").exists())
.andExpect(jsonPath("$[0].matchScore").exists())
.andExpect(jsonPath("$[0].matchReason").exists())
.andExpect(jsonPath("$[0].experienceYears").exists())
.andExpect(jsonPath("$[0].customerSatisfaction").exists())
.andExpect(jsonPath("$[0].specialtyAreas").isArray())
.andExpect(jsonPath("$[0].languageSkills").isArray())
.andExpect(jsonPath("$[0].workingRegions").isArray());
⋮----
void severePatientE2EFlow() throws Exception {
HealthAssessmentCreateRequest severeRequest = HealthAssessmentCreateRequest.builder()
.memberId("severe-patient")
.gender("F")
.birthYear(1940)
.mobilityLevel(3)
.eatingLevel(3)
⋮----
.communicationLevel(3)
.ltciGrade(1)
.careTargetStatus(3)
.mealType(3)
.diseaseTypes("뇌졸중, 치매")
⋮----
.content(objectMapper.writeValueAsString(severeRequest)))
⋮----
.andExpect(jsonPath("$.overallCareGrade").value("1등급 (최중증 - 중증지표)"))
⋮----
MatchingPreference medicalPreference = MatchingPreference.builder()
.needsProfessionalConsultation(true)
.needsEmergencyAvailability(true)
.maxResults(5)
.minCustomerSatisfaction(4.0)
⋮----
.content(objectMapper.writeValueAsString(medicalPreference)))
⋮----
.andExpect(jsonPath("$[0].availableEmergency").value(true))
⋮----
.andExpect(jsonPath("$[0].customerSatisfaction").value(4.2));
⋮----
void dementiaPatientE2EFlow() throws Exception {
HealthAssessmentCreateRequest dementiaRequest = HealthAssessmentCreateRequest.builder()
.memberId("dementia-patient")
⋮----
.birthYear(1935)
⋮----
.toiletLevel(2)
⋮----
.ltciGrade(6)
⋮----
.mealType(2)
.diseaseTypes("알츠하이머")
⋮----
.content(objectMapper.writeValueAsString(dementiaRequest)))
⋮----
.andExpect(jsonPath("$.ltciGrade").value(6))
⋮----
MatchingPreference dementiaPreference = MatchingPreference.builder()
.preferredLanguage("en")
.countryCode("US")
⋮----
.minCustomerSatisfaction(3.5)
⋮----
.content(objectMapper.writeValueAsString(dementiaPreference)))
⋮----
.andExpect(jsonPath("$[0].specialtyAreas").isArray());
⋮----
void mildPatientE2EFlow() throws Exception {
HealthAssessmentCreateRequest mildRequest = HealthAssessmentCreateRequest.builder()
.memberId("mild-patient")
⋮----
.birthYear(1960)
.mobilityLevel(1)
.eatingLevel(1)
.toiletLevel(1)
.communicationLevel(1)
.ltciGrade(5)
⋮----
.diseaseTypes("고혈압")
⋮----
.content(objectMapper.writeValueAsString(mildRequest)))
⋮----
.andExpect(jsonPath("$.adlScore").value(100))
⋮----
MatchingPreference generalPreference = MatchingPreference.builder()
⋮----
.maxResults(15)
⋮----
.needsWeekendAvailability(true)
⋮----
.content(objectMapper.writeValueAsString(generalPreference)))
⋮----
.andExpected(jsonPath("$[0].availableWeekends").value(true))
.andExpect(jsonPath("$[0].workingRegions").isArray())
.andExpected(jsonPath("$[0].workloadRatio").exists());
⋮----
void multipleAssessmentUpdateE2EFlow() throws Exception {
HealthAssessmentCreateRequest initialRequest = HealthAssessmentCreateRequest.builder()
.memberId("update-test-member")
⋮----
MvcResult initialResult = mockMvc.perform(post("/api/health-assessments")
⋮----
.content(objectMapper.writeValueAsString(initialRequest)))
⋮----
HealthAssessment initialAssessment = objectMapper.readValue(
initialResult.getResponse().getContentAsString(), HealthAssessment.class);
⋮----
MatchingPreference initialPreference = MatchingPreference.builder()
⋮----
MvcResult initialMatchingResult = mockMvc.perform(post("/api/coordinator-matching/match")
⋮----
.param("healthAssessmentId", initialAssessment.getId().toString())
⋮----
.content(objectMapper.writeValueAsString(initialPreference)))
⋮----
.andExpected(status().isOk())
⋮----
String initialMatchingJson = initialMatchingResult.getResponse().getContentAsString();
assertThat(initialMatchingJson).contains("coordinatorId");
⋮----
com.globalcarelink.health.dto.HealthAssessmentUpdateRequest.builder()
⋮----
mockMvc.perform(put("/api/health-assessments/{assessmentId}", initialAssessment.getId())
⋮----
.content(objectMapper.writeValueAsString(updateRequest)))
⋮----
.andExpected(jsonPath("$.adlScore").value(300));
⋮----
MatchingPreference updatedPreference = MatchingPreference.builder()
⋮----
.content(objectMapper.writeValueAsString(updatedPreference)))
⋮----
.andExpected(jsonPath("$[0].specialtyAreas").isArray());
⋮----
void matchingStatisticsE2EFlow() throws Exception {
HealthAssessmentCreateRequest request1 = HealthAssessmentCreateRequest.builder()
.memberId("stats-member-1")
⋮----
HealthAssessmentCreateRequest request2 = HealthAssessmentCreateRequest.builder()
.memberId("stats-member-2")
⋮----
mockMvc.perform(post("/api/health-assessments")
⋮----
.content(objectMapper.writeValueAsString(request1)))
.andExpect(status().isCreated());
⋮----
.content(objectMapper.writeValueAsString(request2)))
⋮----
mockMvc.perform(get("/api/health-assessments/statistics"))
⋮----
.andExpect(jsonPath("$.totalAssessments").value(2))
.andExpected(jsonPath("$.completeAssessments").value(2))
.andExpect(jsonPath("$.careGradeDistribution").isArray());
⋮----
mockMvc.perform(get("/api/coordinator-matching/statistics"))
⋮----
.andExpect(jsonPath("$.totalActiveCoordinators").exists())
.andExpect(jsonPath("$.averageCustomerSatisfaction").exists())
.andExpected(jsonPath("$.availableCoordinators").exists());
⋮----
private void setupTestCoordinators() {
CoordinatorCareSettings coordinator1 = CoordinatorCareSettings.builder()
.coordinatorId("e2e-coordinator-001")
.baseCareLevel(1)
.maxCareLevel(5)
.experienceYears(5)
.successfulCases(120)
.customerSatisfaction(4.2)
.maxSimultaneousCases(8)
.specialtyAreas(Set.of("medical", "elderly_care"))
.workingRegions(Set.of("seoul", "incheon"))
.availableWeekends(true)
.availableEmergency(true)
.isActive(true)
⋮----
CoordinatorCareSettings coordinator2 = CoordinatorCareSettings.builder()
.coordinatorId("e2e-coordinator-002")
.baseCareLevel(2)
⋮----
.experienceYears(3)
.successfulCases(80)
.customerSatisfaction(3.8)
.maxSimultaneousCases(6)
.specialtyAreas(Set.of("rehabilitation"))
.workingRegions(Set.of("seoul", "gyeonggi"))
.availableWeekends(false)
.availableEmergency(false)
⋮----
coordinatorCareSettingsRepository.save(coordinator1);
coordinatorCareSettingsRepository.save(coordinator2);
⋮----
CoordinatorLanguageSkill skill1 = CoordinatorLanguageSkill.builder()
⋮----
.languageCode("ko")
.languageName("한국어")
.proficiencyLevel(CoordinatorLanguageSkill.LanguageProficiency.NATIVE)
.certification("C2")
⋮----
CoordinatorLanguageSkill skill2 = CoordinatorLanguageSkill.builder()
⋮----
.languageCode("en")
.languageName("영어")
.proficiencyLevel(CoordinatorLanguageSkill.LanguageProficiency.BUSINESS)
.certification("B2")
⋮----
CoordinatorLanguageSkill skill3 = CoordinatorLanguageSkill.builder()
⋮----
coordinatorLanguageSkillRepository.save(skill1);
coordinatorLanguageSkillRepository.save(skill2);
coordinatorLanguageSkillRepository.save(skill3);
</file>

<file path="src/test/java/com/globalcarelink/health/HealthAssessmentControllerIntegrationTest.java">
class HealthAssessmentControllerIntegrationTest {
⋮----
void setUp() {
setupTestData();
⋮----
void createAssessment_Integration_Success() throws Exception {
mockMvc.perform(post("/api/health-assessments")
.with(csrf())
.contentType(MediaType.APPLICATION_JSON)
.content(objectMapper.writeValueAsString(validCreateRequest)))
.andDo(print())
.andExpect(status().isCreated())
.andExpect(content().contentType(MediaType.APPLICATION_JSON))
.andExpect(jsonPath("$.memberId").value("test-member-001"))
.andExpect(jsonPath("$.mobilityLevel").value(2))
.andExpect(jsonPath("$.eatingLevel").value(2))
.andExpect(jsonPath("$.toiletLevel").value(3))
.andExpect(jsonPath("$.communicationLevel").value(2))
.andExpect(jsonPath("$.ltciGrade").value(3))
.andExpect(jsonPath("$.adlScore").exists())
.andExpect(jsonPath("$.overallCareGrade").exists())
.andExpect(jsonPath("$.assessmentDate").exists());
⋮----
void getAssessment_Integration_Success() throws Exception {
HealthAssessment created = healthAssessmentService.createAssessment(validCreateRequest);
⋮----
mockMvc.perform(get("/api/health-assessments/{assessmentId}", created.getId()))
⋮----
.andExpect(status().isOk())
⋮----
.andExpect(jsonPath("$.id").value(created.getId()))
⋮----
.andExpect(jsonPath("$.adlScore").value(created.getAdlScore()))
.andExpect(jsonPath("$.overallCareGrade").value(created.getOverallCareGrade()));
⋮----
void updateAssessment_Integration_Success() throws Exception {
⋮----
mockMvc.perform(put("/api/health-assessments/{assessmentId}", created.getId())
⋮----
.content(objectMapper.writeValueAsString(validUpdateRequest)))
⋮----
.andExpect(jsonPath("$.mobilityLevel").value(validUpdateRequest.getMobilityLevel()))
.andExpect(jsonPath("$.eatingLevel").value(validUpdateRequest.getEatingLevel()))
.andExpect(jsonPath("$.adlScore").exists());
⋮----
void getMemberAssessments_Integration_Success() throws Exception {
healthAssessmentService.createAssessment(validCreateRequest);
⋮----
HealthAssessmentCreateRequest secondRequest = HealthAssessmentCreateRequest.builder()
.memberId("test-member-001")
.mobilityLevel(3)
.eatingLevel(3)
.toiletLevel(3)
.communicationLevel(3)
.ltciGrade(2)
.careTargetStatus(3)
.mealType(2)
.diseaseTypes("고혈압")
.build();
⋮----
healthAssessmentService.createAssessment(secondRequest);
⋮----
mockMvc.perform(get("/api/health-assessments/member/test-member-001"))
⋮----
.andExpect(jsonPath("$").isArray())
.andExpect(jsonPath("$.length()").value(2))
.andExpect(jsonPath("$[0].memberId").value("test-member-001"))
.andExpect(jsonPath("$[1].memberId").value("test-member-001"));
⋮----
void getStatistics_Integration_Success() throws Exception {
⋮----
HealthAssessmentCreateRequest request2 = HealthAssessmentCreateRequest.builder()
.memberId("test-member-002")
.mobilityLevel(1)
.eatingLevel(1)
.toiletLevel(1)
.communicationLevel(1)
.ltciGrade(5)
⋮----
healthAssessmentService.createAssessment(request2);
⋮----
mockMvc.perform(get("/api/health-assessments/statistics"))
⋮----
.andExpect(jsonPath("$.totalAssessments").value(2))
.andExpect(jsonPath("$.completeAssessments").value(2))
.andExpect(jsonPath("$.careGradeDistribution").isArray())
.andExpect(jsonPath("$.adlScoreDistribution").isArray());
⋮----
void getAssessmentsByCareGrade_Integration_Success() throws Exception {
⋮----
HealthAssessmentCreateRequest grade1Request = HealthAssessmentCreateRequest.builder()
⋮----
.ltciGrade(1)
⋮----
healthAssessmentService.createAssessment(grade1Request);
⋮----
mockMvc.perform(get("/api/health-assessments/care-grade")
.param("minGrade", "1")
.param("maxGrade", "3"))
⋮----
.andExpect(jsonPath("$.length()").value(2));
⋮----
void getSpecializedCareTargets_Integration_Success() throws Exception {
HealthAssessmentCreateRequest hospiceRequest = HealthAssessmentCreateRequest.builder()
.memberId("hospice-patient")
⋮----
.careTargetStatus(1)
.mealType(3)
.diseaseTypes("말기암")
⋮----
healthAssessmentService.createAssessment(hospiceRequest);
⋮----
mockMvc.perform(get("/api/health-assessments/hospice-care"))
⋮----
.andExpect(jsonPath("$.length()").value(1))
.andExpect(jsonPath("$[0].memberId").value("hospice-patient"))
.andExpect(jsonPath("$[0].careTargetStatus").value(1));
⋮----
void getDementiaCareTargets_Integration_Success() throws Exception {
HealthAssessmentCreateRequest dementiaRequest = HealthAssessmentCreateRequest.builder()
.memberId("dementia-patient")
.mobilityLevel(2)
.eatingLevel(2)
.toiletLevel(2)
⋮----
.ltciGrade(6)
.diseaseTypes("치매")
⋮----
healthAssessmentService.createAssessment(dementiaRequest);
⋮----
mockMvc.perform(get("/api/health-assessments/dementia-care"))
⋮----
.andExpect(jsonPath("$[0].memberId").value("dementia-patient"))
.andExpect(jsonPath("$[0].ltciGrade").value(6));
⋮----
void adlScoreCalculation_Integration_Test() throws Exception {
HealthAssessmentCreateRequest request = HealthAssessmentCreateRequest.builder()
.memberId("adl-test-member")
⋮----
.communicationLevel(2)
⋮----
.content(objectMapper.writeValueAsString(request)))
⋮----
.andExpect(jsonPath("$.adlScore").value(180))
.andExpect(jsonPath("$.overallCareGrade").exists());
⋮----
void careGradeCalculation_Integration_Test() throws Exception {
HealthAssessmentCreateRequest severeRequest = HealthAssessmentCreateRequest.builder()
.memberId("severe-patient")
⋮----
.content(objectMapper.writeValueAsString(severeRequest)))
⋮----
.andExpect(jsonPath("$.overallCareGrade").value("1등급 (최중증 - 중증지표)"));
⋮----
void accessControl_Integration_Test() throws Exception {
⋮----
.andExpect(status().isForbidden());
⋮----
private void setupTestData() {
validCreateRequest = HealthAssessmentCreateRequest.builder()
⋮----
.gender("M")
.birthYear(1950)
⋮----
.ltciGrade(3)
.careTargetStatus(4)
.mealType(1)
.diseaseTypes("고혈압, 당뇨")
⋮----
validUpdateRequest = HealthAssessmentUpdateRequest.builder()
⋮----
.ltciGrade(4)
</file>

<file path="build.gradle.kts">
plugins {
    id("org.springframework.boot") version "3.3.5"
    id("io.spring.dependency-management") version "1.1.6"
    id("java")
}

group = "com.globalcarelink"
version = "0.0.1-SNAPSHOT"

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom(configurations.annotationProcessor.get())
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // Spring Boot Starters
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-security")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-actuator")
    
    // Database
    runtimeOnly("org.xerial:sqlite-jdbc:3.46.1.0")
    implementation("org.hibernate.community:hibernate-community-dialects:6.4.4.Final")
    
    // JWT
    implementation("io.jsonwebtoken:jjwt-api:0.12.6")
    runtimeOnly("io.jsonwebtoken:jjwt-impl:0.12.6")
    runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.12.6")
    
    // Utility Libraries
    compileOnly("org.projectlombok:lombok")
    annotationProcessor("org.projectlombok:lombok")
    implementation("org.mapstruct:mapstruct:1.6.2")
    annotationProcessor("org.mapstruct:mapstruct-processor:1.6.2")
    
    // API Documentation
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.6.0")
    
    // Structured Logging
    implementation("net.logstash.logback:logstash-logback-encoder:8.0")
    
    // AOP
    implementation("org.springframework.boot:spring-boot-starter-aop")
    
    // Caching
    implementation("com.github.ben-manes.caffeine:caffeine:3.1.8")
    implementation("org.springframework.boot:spring-boot-starter-cache")
    
    // Development Tools
    developmentOnly("org.springframework.boot:spring-boot-devtools")
    
    // Testing
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.security:spring-security-test")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

tasks.withType<Test> {
    useJUnitPlatform()
}
</file>

<file path="frontend/src/App.tsx">
/**
 * 메인 앱 컴포넌트
 * Elderberry 글로벌 요양원 구인구직 서비스
 */
import React from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
⋮----
import HealthAssessmentWizard from '@/features/health/HealthAssessmentWizard';
import CoordinatorMatchingWizard from '@/features/coordinator/CoordinatorMatchingWizard';
⋮----
// React Query 클라이언트 설정
⋮----
staleTime: 5 * 60 * 1000, // 5분
gcTime: 10 * 60 * 1000, // 10분
⋮----
function App()
⋮----
{/* 건강 평가 체크리스트 페이지 */}
⋮----
memberId="user123" // 실제로는 로그인한 사용자 ID
⋮----
// 결과 페이지로 이동
⋮----
onCancel=
⋮----
// 홈으로 이동
⋮----
{/* 코디네이터 매칭 페이지 */}
⋮----
assessmentId={123} // 실제로는 URL 파라미터에서 가져옴
⋮----
console.log('매칭 완료:', coordinatorId);
// 결과 페이지로 이동
⋮----
// 홈으로 이동
⋮----
{/* 기본 홈 페이지 (임시) */}
</file>

<file path="frontend/package.json">
{
  "name": "global-care-link-frontend",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "zustand": "^4.4.6",
    "@tanstack/react-query": "^5.8.0",
    "axios": "^1.6.0",
    "framer-motion": "^10.0.0",
    "lucide-react": "^0.292.0",
    "react-hook-form": "^7.47.0",
    "zod": "^3.22.0",
    "@hookform/resolvers": "^3.3.0",
    "tailwindcss": "^3.3.0",
    "@allpepper/memory-bank-mcp": "^0.2.1",
    "@modelcontextprotocol/server-filesystem": "^2025.7.1"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@vitejs/plugin-react": "^4.0.0",
    "autoprefixer": "^10.4.0",
    "eslint": "^8.45.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.0",
    "postcss": "^8.4.0",
    "typescript": "^5.0.0",
    "vite": "^5.0.0"
  }
}
</file>

<file path="src/main/java/com/globalcarelink/common/exception/GlobalExceptionHandler.java">
public class GlobalExceptionHandler {
⋮----
public ResponseEntity<ErrorResponse> handleBadRequest(CustomException.BadRequest ex, HttpServletRequest request) {
String errorId = UUID.randomUUID().toString();
log.warn("잘못된 요청 - ID: {}, URI: {}, 메시지: {}", errorId, request.getRequestURI(), ex.getMessage());
⋮----
ErrorResponse response = ErrorResponse.builder()
.errorId(errorId)
.status(HttpStatus.BAD_REQUEST.value())
.error("Bad Request")
.message(ex.getMessage())
.path(request.getRequestURI())
.timestamp(LocalDateTime.now())
.build();
⋮----
return ResponseEntity.badRequest().body(response);
⋮----
public ResponseEntity<ErrorResponse> handleNotFound(CustomException.NotFound ex, HttpServletRequest request) {
⋮----
log.info("리소스 없음 - ID: {}, URI: {}, 메시지: {}", errorId, request.getRequestURI(), ex.getMessage());
⋮----
.status(HttpStatus.NOT_FOUND.value())
.error("Not Found")
.message("요청한 리소스를 찾을 수 없습니다")
⋮----
return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
⋮----
public ResponseEntity<ErrorResponse> handleUnauthorized(CustomException.Unauthorized ex, HttpServletRequest request) {
⋮----
log.warn("인증 실패 - ID: {}, URI: {}, IP: {}", errorId, request.getRequestURI(), getClientIP(request));
⋮----
.status(HttpStatus.UNAUTHORIZED.value())
.error("Unauthorized")
.message("인증이 필요합니다")
⋮----
return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
⋮----
public ResponseEntity<ErrorResponse> handleForbidden(CustomException.Forbidden ex, HttpServletRequest request) {
⋮----
log.warn("접근 권한 없음 - ID: {}, URI: {}, IP: {}", errorId, request.getRequestURI(), getClientIP(request));
⋮----
.status(HttpStatus.FORBIDDEN.value())
.error("Forbidden")
.message("접근 권한이 없습니다")
⋮----
return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
⋮----
public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex, HttpServletRequest request) {
⋮----
log.warn("Spring Security 접근 거부 - ID: {}, URI: {}, IP: {}", errorId, request.getRequestURI(), getClientIP(request));
⋮----
.error("Access Denied")
⋮----
public ResponseEntity<ErrorResponse> handleBadCredentials(BadCredentialsException ex, HttpServletRequest request) {
⋮----
log.warn("잘못된 인증 정보 - ID: {}, URI: {}, IP: {}", errorId, request.getRequestURI(), getClientIP(request));
⋮----
.error("Bad Credentials")
.message("인증 정보가 올바르지 않습니다")
⋮----
public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex, HttpServletRequest request) {
⋮----
log.warn("유효성 검증 실패 - ID: {}, URI: {}", errorId, request.getRequestURI());
⋮----
ex.getBindingResult().getFieldErrors().forEach(error ->
errors.put(error.getField(), error.getDefaultMessage())
⋮----
.error("Validation Failed")
.message("입력 값이 올바르지 않습니다")
⋮----
.details(errors)
⋮----
public ResponseEntity<ErrorResponse> handleBindException(BindException ex, HttpServletRequest request) {
⋮----
log.warn("바인딩 오류 - ID: {}, URI: {}", errorId, request.getRequestURI());
⋮----
.error("Binding Error")
.message("요청 데이터 바인딩에 실패했습니다")
⋮----
public ResponseEntity<ErrorResponse> handleConstraintViolation(ConstraintViolationException ex, HttpServletRequest request) {
⋮----
log.warn("제약 조건 위반 - ID: {}, URI: {}", errorId, request.getRequestURI());
⋮----
ex.getConstraintViolations().forEach(violation ->
errors.put(violation.getPropertyPath().toString(), violation.getMessage())
⋮----
.error("Constraint Violation")
.message("데이터 제약 조건을 위반했습니다")
⋮----
public ResponseEntity<ErrorResponse> handleTypeMismatch(MethodArgumentTypeMismatchException ex, HttpServletRequest request) {
⋮----
log.warn("타입 불일치 - ID: {}, URI: {}, 파라미터: {}", errorId, request.getRequestURI(), ex.getName());
⋮----
.error("Type Mismatch")
.message("요청 파라미터 타입이 올바르지 않습니다")
⋮----
public ResponseEntity<ErrorResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex, HttpServletRequest request) {
⋮----
log.error("데이터 무결성 위반 - ID: {}, URI: {}", errorId, request.getRequestURI(), ex);
⋮----
.status(HttpStatus.CONFLICT.value())
.error("Data Integrity Violation")
.message("데이터 무결성 제약을 위반했습니다")
⋮----
return ResponseEntity.status(HttpStatus.CONFLICT).body(response);
⋮----
public ResponseEntity<ErrorResponse> handleGeneralException(Exception ex, HttpServletRequest request) {
⋮----
log.error("예상치 못한 오류 발생 - ID: {}, URI: {}", errorId, request.getRequestURI(), ex);
⋮----
.status(HttpStatus.INTERNAL_SERVER_ERROR.value())
.error("Internal Server Error")
.message("서버 내부 오류가 발생했습니다")
⋮----
return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
⋮----
private String getClientIP(HttpServletRequest request) {
String xForwardedFor = request.getHeader("X-Forwarded-For");
if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
return xForwardedFor.split(",")[0].trim();
⋮----
String xRealIP = request.getHeader("X-Real-IP");
if (xRealIP != null && !xRealIP.isEmpty()) {
⋮----
return request.getRemoteAddr();
⋮----
public static class ErrorResponse {
</file>

<file path="src/main/java/com/globalcarelink/health/HealthAssessment.java">
import lombok.*;
⋮----
/**
 * 건강 상태 평가 엔티티 (KB라이프생명 기반 돌봄지수)
 * 
 * 4개 주요 평가 영역:
 * - 걷기 활동 능력 (mobility)
 * - 식사 활동 능력 (eating) 
 * - 배변 활동 능력 (toilet)
 * - 의사소통 능력 (communication)
 */
⋮----
public class HealthAssessment extends BaseEntity {
⋮----
// ===== 기본 정보 =====
⋮----
// ===== ADL 평가 (각 영역 1-3점) =====
⋮----
/**
     * 걷기 활동 능력 (care_mobility)
     * 1: 독립 - 혼자서 가능
     * 2: 부분도움 - 부축, 지팡이 등 필요
     * 3: 완전도움 - 휠체어 사용 등
     */
⋮----
/**
     * 식사 활동 능력 (care_eating)
     * 1: 독립 - 혼자서 가능
     * 2: 부분도움 - 반찬 집기, 자르기 등 일부 도움
     * 3: 완전도움 - 음식을 떠 먹여줌
     */
⋮----
/**
     * 배변 활동 능력 (care_toilet)
     * 1: 독립 - 혼자서 화장실 이용 가능
     * 2: 부분도움 - 화장실 이용 시 부분적 도움 필요
     * 3: 완전도움 - 간이변기, 기저귀 착용 등
     */
⋮----
/**
     * 의사소통 능력 (care_communication)
     * 1: 정상 - 정상적으로 가능
     * 2: 부분제한 - 때때로 어려움 (화장실 이용의사 표현 가능)
     * 3: 심각제한 - 소통이 어려움 (화장실 이용의사 표현 잘 못함)
     */
⋮----
// ===== 장기요양보험 정보 =====
⋮----
/**
     * 장기요양보험 등급
     * 1-5: 장기요양등급 (1등급이 최중증)
     * 6: 인지지원등급 (치매 등)
     * 7: 등급 판정 중 또는 모름
     * 8: 등급 없음
     */
⋮----
/**
     * 돌봄대상자 상태 (생명예후 상태)
     * 1: 6개월 이하 기대수명 (호스피스 케어)
     * 2: 질병이 회복하기 어려운 상황으로 수명이 얼마 남지 않음
     * 3: 완전히 타인 의존적이나 사망위험이 높지 않음
     * 4: 해당사항 없음 (일반 요양)
     */
⋮----
// ===== KB라이프생명 참조: 추가 평가 항목 =====
⋮----
/**
     * 식사 형태 (KB라이프생명 기준 추가)
     * 1: 일반식 (정상 식사 가능)
     * 2: 다진식/갈은식 (부드러운 식사 필요)
     * 3: 경관식 (튜브 주입)
     */
⋮----
/**
     * 주요 질환 분류 (복수 선택 가능)
     * DEMENTIA: 치매 (인지기능 저하)
     * PARKINSON: 파킨슨 (운동장애)
     * STROKE: 뇌혈관질환 (뇌졸중 등)
     * DIABETES: 당뇨병
     * HYPERTENSION: 고혈압
     * OTHER: 기타
     * UNKNOWN: 잘 모르겠음
     */
⋮----
private String diseaseTypes; // JSON 형태로 저장: ["DEMENTIA", "STROKE"]
⋮----
// ===== 계산된 결과 =====
⋮----
/**
     * ADL 점수 (일상생활수행능력 점수)
     * 계산식: (mobility*25) + (eating*20) + (toilet*30) + (communication*25)
     * 범위: 100-300점
     */
⋮----
/**
     * 종합 케어 등급
     * ADL 점수 + 장기요양보험 등급 + 돌봄대상자 상태를 종합하여 산출
     */
⋮----
private LocalDateTime assessmentDate = LocalDateTime.now();
⋮----
// ===== 비즈니스 메서드 =====
⋮----
/**
     * ADL 점수 계산
     * 각 영역별 가중치를 적용하여 총점 계산
     */
public void calculateAdlScore() {
⋮----
/**
     * 재외동포 여부 확인
     * 회원 정보를 통해 확인 (추후 Member 엔티티와 연동)
     */
public boolean isOverseasKorean() {
// TODO: Member 엔티티의 role이 USER_OVERSEAS인지 확인
return false; // 임시 구현
⋮----
/**
     * 종합 평가 점수 (5점 만점)
     * ADL 점수를 5점 만점으로 환산
     */
public double getOverallScore() {
⋮----
calculateAdlScore();
⋮----
// 100점(최고) → 5.0점, 300점(최저) → 1.0점으로 환산
⋮----
return Math.max(1.0, Math.min(5.0, normalizedScore));
⋮----
/**
     * 케어 등급 레벨 반환
     * 1: 최중증, 2: 중증, 3: 중등증, 4: 경증, 5: 경증, 6: 인지지원
     */
public int getCareGradeLevel() {
⋮----
// 장기요양등급이 없는 경우 ADL 점수로 추정
⋮----
if (adlScore >= 250) return 1; // 최중증
if (adlScore >= 220) return 2; // 중증
if (adlScore >= 180) return 3; // 중등증
if (adlScore >= 140) return 4; // 경증
return 5; // 경증
⋮----
/**
     * 평가 완성도 확인
     */
public boolean isComplete() {
⋮----
/**
     * 평가 갱신 (새로운 평가 결과로 업데이트)
     */
public void updateAssessment(Integer mobility, Integer eating, Integer toilet, Integer communication) {
⋮----
this.assessmentDate = LocalDateTime.now();
⋮----
// 자동으로 ADL 점수 재계산
⋮----
/**
     * 특정 질환 여부 확인
     */
public boolean hasDiseaseType(String diseaseType) {
return diseaseTypes != null && diseaseTypes.contains(diseaseType);
⋮----
/**
     * 중증 지표 여부 확인 (KB라이프생명 기준)
     * - 경관식(튜브 주입) 또는
     * - 배변활동 완전도움
     */
public boolean hasSevereIndicators() {
⋮----
/**
     * 치매 관련 질환 여부 확인
     */
public boolean hasDementiaRelatedCondition() {
⋮----
hasDiseaseType("DEMENTIA");
⋮----
/**
     * 호스피스 케어 필요 여부 확인
     */
public boolean needsHospiceCare() {
⋮----
/**
     * 질환별 전문 케어 타입 반환
     */
public String getSpecializedCareType() {
if (needsHospiceCare()) {
⋮----
if (hasDementiaRelatedCondition()) {
⋮----
if (hasDiseaseType("PARKINSON")) {
⋮----
if (hasDiseaseType("STROKE")) {
⋮----
if (hasSevereIndicators()) {
⋮----
/**
     * 예상 월 비용 범위 반환 (등급 기반)
     */
public String getEstimatedMonthlyCostRange() {
int gradeLevel = getCareGradeLevel();
⋮----
/**
     * 평가 결과 요약 텍스트 생성
     */
public String generateAssessmentSummary() {
StringBuilder summary = new StringBuilder();
⋮----
summary.append("🏥 종합 케어 등급: ").append(overallCareGrade != null ? overallCareGrade : "미산출").append("\n");
summary.append("📊 ADL 점수: ").append(adlScore != null ? adlScore + "점" : "미계산").append("\n");
⋮----
summary.append("🎯 장기요양등급: ").append(ltciGrade).append("등급\n");
⋮----
summary.append("⚠️ 중증 지표 존재\n");
⋮----
summary.append("🕊️ 호스피스 케어 권장\n");
⋮----
summary.append("💰 예상 비용: ").append(getEstimatedMonthlyCostRange());
⋮----
return summary.toString();
</file>

<file path="src/main/java/com/globalcarelink/health/HealthAssessmentService.java">
/**
 * 건강 상태 평가 서비스
 * KB라이프생명 기반 돌봄지수 체크 비즈니스 로직
 */
⋮----
public class HealthAssessmentService {
⋮----
/**
     * 건강 평가 생성
     */
⋮----
public HealthAssessment createAssessment(HealthAssessmentCreateRequest request) {
log.info("건강 평가 생성 시작 - 회원: {}", request.getMemberId());
⋮----
// 입력값 검증
validateAssessmentRequest(request);
⋮----
// 엔티티 생성
HealthAssessment assessment = HealthAssessment.builder()
.memberId(request.getMemberId())
.gender(request.getGender())
.birthYear(request.getBirthYear())
.mobilityLevel(request.getMobilityLevel())
.eatingLevel(request.getEatingLevel())
.toiletLevel(request.getToiletLevel())
.communicationLevel(request.getCommunicationLevel())
.ltciGrade(request.getLtciGrade())
.careTargetStatus(request.getCareTargetStatus() != null ? request.getCareTargetStatus() : 4)
.mealType(request.getMealType() != null ? request.getMealType() : 1)
.diseaseTypes(request.getDiseaseTypes())
.assessmentDate(LocalDateTime.now())
.build();
⋮----
// ADL 점수 자동 계산
assessment.calculateAdlScore();
⋮----
// 케어 등급 계산
CareGradeCalculator.CareGradeResult gradeResult = careGradeCalculator.calculateComprehensiveGrade(assessment);
⋮----
// 저장
HealthAssessment saved = healthAssessmentRepository.save(assessment);
⋮----
log.info("건강 평가 생성 완료 - ID: {}, 회원: {}, 등급: {}",
saved.getId(), request.getMemberId(), gradeResult.getGradeName());
⋮----
/**
     * ID로 건강 평가 조회
     */
⋮----
public Optional<HealthAssessment> getAssessmentById(Long assessmentId) {
log.debug("건강 평가 조회 - ID: {}", assessmentId);
return healthAssessmentRepository.findById(assessmentId);
⋮----
/**
     * 회원별 최신 건강 평가 조회
     */
⋮----
public Optional<HealthAssessment> getLatestAssessmentByMemberId(String memberId) {
log.debug("회원 최신 건강 평가 조회 - 회원: {}", memberId);
if (memberId == null || memberId.trim().isEmpty()) {
⋮----
return healthAssessmentRepository.findTopByMemberIdOrderByAssessmentDateDesc(memberId);
⋮----
/**
     * 회원별 건강 평가 이력 조회
     */
public List<HealthAssessment> getAssessmentHistoryByMemberId(String memberId) {
⋮----
return healthAssessmentRepository.findByMemberIdOrderByAssessmentDateDesc(memberId);
⋮----
/**
     * 건강 평가 페이징 조회
     */
public Page<HealthAssessment> getAssessmentsByMemberId(String memberId, Pageable pageable) {
⋮----
return healthAssessmentRepository.findByMemberIdOrderByAssessmentDateDesc(memberId, pageable);
⋮----
/**
     * 건강 평가 수정
     */
⋮----
public HealthAssessment updateAssessment(Long assessmentId, HealthAssessmentUpdateRequest request) {
log.info("건강 평가 수정 시작 - ID: {}", assessmentId);
⋮----
// 기존 평가 조회
HealthAssessment assessment = healthAssessmentRepository.findById(assessmentId)
.orElseThrow(() -> new CustomException.NotFound("건강 평가를 찾을 수 없습니다: " + assessmentId));
⋮----
validateUpdateRequest(request);
⋮----
// 평가 정보 업데이트
if (request.getMobilityLevel() != null) {
assessment.setMobilityLevel(request.getMobilityLevel());
⋮----
if (request.getEatingLevel() != null) {
assessment.setEatingLevel(request.getEatingLevel());
⋮----
if (request.getToiletLevel() != null) {
assessment.setToiletLevel(request.getToiletLevel());
⋮----
if (request.getCommunicationLevel() != null) {
assessment.setCommunicationLevel(request.getCommunicationLevel());
⋮----
if (request.getLtciGrade() != null) {
assessment.setLtciGrade(request.getLtciGrade());
⋮----
if (request.getCareTargetStatus() != null) {
assessment.setCareTargetStatus(request.getCareTargetStatus());
⋮----
if (request.getMealType() != null) {
assessment.setMealType(request.getMealType());
⋮----
if (request.getDiseaseTypes() != null) {
assessment.setDiseaseTypes(request.getDiseaseTypes());
⋮----
// 평가 날짜 갱신
assessment.setAssessmentDate(LocalDateTime.now());
⋮----
// ADL 점수 재계산
⋮----
// 케어 등급 재계산
⋮----
HealthAssessment updated = healthAssessmentRepository.save(assessment);
⋮----
log.info("건강 평가 수정 완료 - ID: {}, 새 등급: {}", assessmentId, gradeResult.getGradeName());
⋮----
/**
     * 케어 등급 계산 (별도 호출)
     */
public CareGradeCalculator.CareGradeResult calculateCareGrade(HealthAssessment assessment) {
return careGradeCalculator.calculateComprehensiveGrade(assessment);
⋮----
/**
     * 특정 케어 등급 범위의 평가 조회
     */
public List<HealthAssessment> getAssessmentsByCareGradeRange(Integer minGrade, Integer maxGrade) {
return healthAssessmentRepository.findByCareGradeRange(minGrade, maxGrade);
⋮----
/**
     * 호스피스 케어 대상자 조회
     */
public List<HealthAssessment> getHospiceCareTargets() {
return healthAssessmentRepository.findHospiceCareTargets();
⋮----
/**
     * 치매 전문 케어 대상자 조회
     */
public List<HealthAssessment> getDementiaCareTargets() {
return healthAssessmentRepository.findDementiaCareTargets();
⋮----
/**
     * 중증 환자 조회
     */
public List<HealthAssessment> getSevereCareTargets() {
return healthAssessmentRepository.findSevereCareTargets();
⋮----
/**
     * 재외동포 대상 평가 조회
     */
public List<HealthAssessment> getOverseasKoreanAssessments() {
return healthAssessmentRepository.findOverseasKoreanAssessments();
⋮----
/**
     * 건강 평가 통계 조회
     */
⋮----
public HealthAssessmentStatistics getStatistics() {
log.info("건강 평가 통계 조회");
// 케어 등급별 통계
List<Map<String, Object>> gradeStats = healthAssessmentRepository.findCareGradeStatistics();
⋮----
// ADL 점수 구간별 통계
List<Map<String, Object>> adlStats = healthAssessmentRepository.findAdlScoreDistribution();
⋮----
// 연령대별 케어 등급 분포
List<Map<String, Object>> ageStats = healthAssessmentRepository.findAgeGroupCareGradeDistribution();
⋮----
// 성별 케어 패턴
List<Map<String, Object>> genderStats = healthAssessmentRepository.findGenderCarePatternAnalysis();
⋮----
// 최근 30일 평가 현황
Long recentCount = healthAssessmentRepository.countRecentAssessments(LocalDateTime.now().minusDays(30));
⋮----
// 전체 평가 수
long totalCount = healthAssessmentRepository.count();
⋮----
// 완성된 평가 수
long completeCount = healthAssessmentRepository.findCompleteAssessments().size();
⋮----
return HealthAssessmentStatistics.builder()
.totalAssessments(totalCount)
.completeAssessments(completeCount)
.recentAssessments(recentCount)
.careGradeDistribution(gradeStats)
.adlScoreDistribution(adlStats)
.ageGroupDistribution(ageStats)
.genderPatternAnalysis(genderStats)
.hospiceCareTargets((long) healthAssessmentRepository.findHospiceCareTargets().size())
.dementiaCareTargets((long) healthAssessmentRepository.findDementiaCareTargets().size())
.severeCareTargets((long) healthAssessmentRepository.findSevereCareTargets().size())
.overseasKoreanAssessments((long) healthAssessmentRepository.findOverseasKoreanAssessments().size())
⋮----
/**
     * 회원의 평가 개선 추이 분석
     */
public List<Map<String, Object>> getMemberAssessmentTrend(String memberId) {
⋮----
return healthAssessmentRepository.findMemberAssessmentTrend(memberId);
⋮----
/**
     * 건강 평가 삭제
     */
⋮----
public void deleteAssessment(Long assessmentId) {
⋮----
healthAssessmentRepository.delete(assessment);
⋮----
log.info("건강 평가 삭제 완료 - ID: {}, 회원: {}", assessmentId, assessment.getMemberId());
⋮----
public void evictAllCaches() {
log.info("건강 평가 관련 모든 캐시 삭제");
⋮----
// ===== 내부 검증 메서드 =====
⋮----
private void validateAssessmentRequest(HealthAssessmentCreateRequest request) {
// 필수 필드 검증
if (request.getMemberId() == null || request.getMemberId().trim().isEmpty()) {
⋮----
if (request.getMobilityLevel() == null || request.getEatingLevel() == null ||
request.getToiletLevel() == null || request.getCommunicationLevel() == null) {
⋮----
// 범위 검증
validateAdlLevels(request.getMobilityLevel(), request.getEatingLevel(),
request.getToiletLevel(), request.getCommunicationLevel());
⋮----
// 출생년도 검증
if (request.getBirthYear() != null &&
(request.getBirthYear() < 1900 || request.getBirthYear() > LocalDateTime.now().getYear())) {
⋮----
// 질환 정보 검증
if (request.getDiseaseTypes() != null && request.getDiseaseTypes().length() > 200) {
⋮----
private void validateUpdateRequest(HealthAssessmentUpdateRequest request) {
// ADL 수준 검증 (null이 아닌 경우만)
if (request.getMobilityLevel() != null || request.getEatingLevel() != null ||
request.getToiletLevel() != null || request.getCommunicationLevel() != null) {
⋮----
private void validateAdlLevels(Integer mobility, Integer eating, Integer toilet, Integer communication) {
</file>

<file path="CLAUDE.md">
# CLAUDE.md

이 문서는 LightCare 프로젝트에서 Claude Code가 코드를 다룰 때 참고할 가이드입니다.

---

## 📌 프로젝트 개요

**글로벌 요양원 구인구직 웹사이트 "엘더베리(Elderberry)"**
- 재외동포 대상 글로벌 요양 서비스
- JDK 21 + Spring Boot 3.3.5 기반 신규 프로젝트
- 자본금 0원 개발 전략 (무료 서비스 활용)

---

## 🛠 핵심 기술 스택

### 백엔드
- **Java 21 LTS** + **Spring Boot 3.3.5** + **Gradle 8.x**
- **데이터베이스**: SQLite (무료)
- **보안**: Spring Security 6.x + JWT
- **API 문서**: OpenAPI 3.0 + Swagger UI
- **캐싱**: Caffeine Cache
- **비동기 처리**: Spring Async

### 프론트엔드  
- **React 18** + **TypeScript 5.x** + **Vite 5.x**
- **UI**: Tailwind CSS + Shadcn/ui
- **상태관리**: Zustand + TanStack Query

### 배포 & 도구
- **배포**: Railway/Render (무료) + GitHub Pages
- **CI/CD**: GitHub Actions
- **테스트**: JUnit 5 + MockMvc

---

## 🎯 프로젝트 완료 현황

### Phase 1 완료 ✅
- [x] Spring Boot 3.3.5 + JDK 21 프로젝트 구조
- [x] SQLite 데이터베이스 + Hibernate 6.x 설정
- [x] JWT 기반 Spring Security 6.x 인증 시스템
- [x] 회원 관리 시스템 (국내/해외/코디네이터/시설)
- [x] OpenAPI 3.0 + Swagger UI 문서화

### Phase 2 완료 ✅
- [x] React 18 + TypeScript + Vite 프론트엔드 구조
- [x] Tailwind CSS + Shadcn/ui 디자인 시스템
- [x] Zustand 상태 관리 + TanStack Query 데이터 페칭
- [x] JWT 기반 인증 연동
- [x] 반응형 UI 컴포넌트 라이브러리

### Phase 3 완료 ✅
- [x] KB라이프생명 기반 건강 상태 평가 시스템
- [x] ADL 점수 자동 계산 (걷기/식사/배변/의사소통)
- [x] 장기요양보험 등급 연동 케어 등급 산출
- [x] React 건강 평가 마법사 UI
- [x] 단계별 평가 폼 + 실시간 점수 계산

### Phase 4 완료 ✅
- [x] **Phase 4-A**: AI 기반 코디네이터 매칭 알고리즘
  - 5점 만점 매칭 점수 (전문성 40% + 경력 25% + 만족도 20% + 위치 10% + 가용성 5%)
  - 업무량 최적화 분배 시스템
  - 지능형 매칭 결과 설명 생성
  - 실시간 통계 및 성과 모니터링
- [x] **Phase 4-B**: React 매칭 결과 UI 및 성과 모니터링
  - CoordinatorMatchingWizard 메인 인터페이스
  - CoordinatorCard 프로필 카드
  - MatchingPreferencePanel 상세 설정
  - MatchingStatsDashboard 실시간 대시보드

### Phase 5 완료 ✅
- [x] **통합 테스트 스위트**: JUnit 5 기반 완전한 테스트 환경
  - CoordinatorMatchingServiceIntegrationTest: 매칭 시스템 통합 테스트
  - CoordinatorMatchingControllerTest: API 엔드포인트 테스트
  - HealthAssessmentControllerIntegrationTest: 건강 평가 시스템 테스트
  - HealthAssessmentToCoordinatorMatchingE2ETest: 전체 플로우 E2E 테스트
- [x] **성능 최적화**: Caffeine 캐시 + 비동기 처리
  - 3단계 캐시 전략 (매칭/평가/통계)
  - ThreadPoolTaskExecutor 기반 비동기 처리
  - 쿼리 최적화 및 인덱싱
- [x] **보안 강화**: Spring Security 6.x 완전 구성
  - BCrypt 12라운드 암호화
  - CORS 정책 강화
  - HTTP 보안 헤더 적용
  - 상세한 예외 처리 및 로깅

---

## 🏆 주요 구현 성과

### 1. 건강 평가 시스템 (KB라이프생명 기준)
- **ADL 점수 계산**: 걷기(25%) + 식사(20%) + 배변(30%) + 의사소통(25%)
- **케어 등급 산출**: 장기요양보험 등급 + 돌봄대상자 상태 종합 판단
- **특화 케어 분류**: 호스피스/치매/중증/일반 케어 자동 분류

### 2. AI 코디네이터 매칭 시스템
- **5점 만점 매칭 알고리즘**: 전문성, 경력, 만족도, 위치, 가용성 종합 평가
- **업무량 최적화**: 공정한 케이스 분배 알고리즘
- **지능형 설명 생성**: 매칭 이유를 한국어로 자동 생성
- **실시간 성과 추적**: 매칭 성공률, 만족도, 응답시간 모니터링

### 3. 완전한 테스트 환경
- **통합 테스트**: 실제 데이터베이스 연동 테스트
- **API 테스트**: MockMvc 기반 컨트롤러 테스트
- **E2E 테스트**: 건강평가→매칭→결과 전체 플로우 테스트
- **성능 테스트**: 캐시 효율성 및 응답시간 검증

### 4. 엔터프라이즈급 성능 최적화
- **3단계 캐시 전략**: 매칭 결과, 건강 평가, 통계 데이터 캐싱
- **비동기 처리**: 매칭, 통계, 일반 작업 분리된 스레드풀
- **쿼리 최적화**: N+1 문제 해결, 인덱스 최적화

### 5. 강화된 보안 시스템
- **인증/인가**: JWT + Spring Security 6.x
- **데이터 보호**: BCrypt 12라운드 + SQL Injection 방지
- **네트워크 보안**: CORS 정책, HTTP 보안 헤더
- **예외 처리**: 상세한 오류 추적 및 로깅

---

## 📊 시스템 아키텍처

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   React 18      │    │  Spring Boot    │    │    SQLite       │
│   Frontend      │◄──►│   Backend       │◄──►│   Database      │
│                 │    │                 │    │                 │
│ • 건강평가 UI    │    │ • 매칭 알고리즘  │    │ • 회원 정보      │
│ • 매칭결과 UI    │    │ • 케어등급 계산  │    │ • 건강 평가      │
│ • 대시보드 UI    │    │ • 캐시 시스템    │    │ • 매칭 결과      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

---

## 🎯 다음 단계 (Phase 6)

**목표**: 배포 준비 및 최종 통합 (예상 토큰: 10,000)

### 배포 환경 구성
- [ ] Railway/Render 배포 설정
- [ ] GitHub Pages 프론트엔드 배포
- [ ] 환경별 설정 분리 (dev/prod)
- [ ] CI/CD 파이프라인 구성

### 최종 검증 및 문서화
- [ ] 전체 시스템 통합 테스트
- [ ] 사용자 매뉴얼 작성
- [ ] API 문서 최종 정리
- [ ] 성능 벤치마크 테스트

---

## 🔧 개발 가이드라인

### 코드 스타일
- **Java**: Google Java Style Guide
- **TypeScript**: Prettier + ESLint
- **커밋 메시지**: Conventional Commits

### 테스트 전략
- **단위 테스트**: 모든 비즈니스 로직
- **통합 테스트**: 데이터베이스 연동 부분
- **E2E 테스트**: 주요 사용자 플로우

### 성능 목표
- **API 응답시간**: 평균 200ms 이하
- **매칭 처리시간**: 평균 1초 이하
- **캐시 적중률**: 80% 이상

---

## 📋 주의사항

1. **보안**: 모든 API는 JWT 인증 필요
2. **성능**: 캐시 무효화 정책 준수
3. **테스트**: 새 기능 추가 시 테스트 코드 필수
4. **로깅**: 민감 정보 로깅 금지
5. **예외처리**: 사용자 친화적 오류 메시지 제공

---

## 🏁 프로젝트 현황

**전체 진행률: 90% 완료**

- ✅ 백엔드 시스템 (100%)
- ✅ 프론트엔드 UI (100%)
- ✅ 건강 평가 시스템 (100%)
- ✅ 매칭 알고리즘 (100%)
- ✅ 테스트 환경 (100%)
- ✅ 성능 최적화 (100%)
- ✅ 보안 강화 (100%)
- 🔄 배포 준비 (0%)

**남은 작업**: Phase 6 배포 환경 구성 및 최종 검증

---

*최종 업데이트: 2024년 12월*
</file>

</files>
