## 코드 베이스 분석 및 개선 제안

프로젝트 전반에 대한 엄격한 기준의 분석 및 개선 계획을 제안합니다.

### **1. 코드 베이스 전반 구조 및 스타일 평가 요약**

#### **강점 (Strengths)**

*   **견고한 문서화 문화**: `docs/` 디렉토리의 체계적인 `phases`, `work-reports`, `troubleshooting` 구조는 프로젝트의 이력과 의사결정 과정을 투명하게 관리하는 훌륭한 자산입니다.
*   **현대적인 기술 스택**: Java 21, Spring Boot 3.3.5, React 18 등 최신 기술을 채택하여 성능과 개발 생산성 면에서 잠재력이 높습니다.
*   **높은 코드 품질 인식**: `개선사항.md`와 `CLAUDE_GUIDELINES.md`를 통해 SRP, DRY, 비동기 최적화, 테스트 전략 등 클린 코드 원칙에 대한 깊은 이해와 적용 의지가 엿보입니다.
*   **정교한 아키텍처 설계**: 여러 전용 `ThreadPoolTaskExecutor`를 사용하는 `AsyncConfig`, Strategy 패턴, `@EntityGraph`를 통한 N+1 문제 해결 등 수준 높은 아키텍처 패턴을 적용하고 있습니다.

#### **개선 영역 (Opportunities for Improvement)**

*   **아키텍처 이중성**: `PlainJavaServer`와 Spring Boot 애플리케이션의 공존은 가장 시급하게 해결해야 할 구조적 문제입니다. 이는 개발 환경의 복잡성을 가중시키고, 배포 및 유지보수 오버헤드를 증가시킵니다.
*   **관심사 분리 미흡**: 일부 컨트롤러(`BoardController`) 내부에 DTO가 내부 클래스로 정의되어 있어 재사용성과 계층 분리를 저해합니다.
*   **엔티티 과잉 책임**: 일부 엔티티(`Job.java`)가 프레젠테이션 로직(`getSalaryRange`)이나 복잡한 비즈니스 규칙을 포함하여 서비스 계층과의 역할 경계가 모호합니다.
*   **일관성 부족**: `application.yml` 설정이 중앙 집중화되어 있어 환경별 설정 분리가 더 명확하게 이루어질 필요가 있습니다.

---

### **2. 클린 아키텍처 구현 계획**

아래는 코드 베이스 전반의 구조적 문제를 해결하고 클린 코드 원칙을 더욱 강화하기 위한 구체적인 실행 계획입니다.

---

### **[P0] 긴급 (Critical) 개선 계획**

#### **영역 1: 아키텍처 통합 및 단일화**

*   **문제점**: `PlainJavaServer`와 Spring Boot 애플리케이션이 공존하며, `SimpleChatbotProxy`는 임시방편적인 해결책입니다. 이는 개발, 테스트, 배포 환경의 일관성을 해치고 기술 부채를 가중시키는 가장 큰 구조적 문제입니다.
*   **제안**:
    1.  `PlainJavaServer`와 `SimpleApp`을 과감히 **제거**합니다.
    2.  `SimpleChatbotProxy`의 기능을 Spring Boot 애플리케이션 내에 완전히 통합합니다. `WebClient`를 사용하는 프록시 컨트롤러(`ChatbotProxyController`)를 구현하여 모든 외부 챗봇 API 호출을 담당하게 합니다.
    3.  모든 개발 스크립트(`start-*.ps1`)를 Spring Boot 애플리케이션 실행을 기본으로 하도록 수정하고, 더 이상 필요 없는 스크립트는 제거합니다.
*   **기대 효과**:
    *   **단일 배포**: 프로젝트를 하나의 실행 가능한 JAR 파일로 통일하여 배포 복잡성을 획기적으로 줄입니다.
    *   **일관된 환경**: Spring Security, 로깅, 모니터링 등 Spring Boot의 모든 기능을 일관되게 적용합니다.
    *   **개발 생산성 향상**: 복잡한 하이브리드 서버 구조를 이해할 필요 없이 단일 환경에 집중할 수 있습니다.

---

### **[P1] 중요 (High) 개선 계획**

#### **영역 2: 컨트롤러와 DTO의 완전한 분리**

*   **문제점**: `BoardController`, `JobController` 등 여러 컨트롤러 내부에 Request/Response DTO가 내부 정적 클래스로 정의되어 있습니다. 이는 DTO의 재사용을 막고, 컨트롤러의 책임을 가중시키며, API 명세의 가독성을 떨어뜨립니다.
*   **제안**:
    1.  각 도메인 패키지 내에 `dto` 하위 패키지를 생성합니다. (예: `com.globalcarelink.board.dto`)
    2.  모든 내부 클래스 DTO를 각각의 public 클래스 파일로 분리하여 해당 `dto` 패키지로 이동시킵니다.
    3.  `@Valid` 어노테이션을 사용하여 컨트롤러에서 DTO 유효성 검사를 일관되게 수행합니다.
*   **기대 효과**:
    *   **재사용성 증대**: DTO를 다른 서비스나 계층에서 쉽게 재사용할 수 있습니다.
    *   **단일 책임 원칙(SRP) 준수**: 컨트롤러는 API 엔드포인트 역할에, DTO는 데이터 전송 역할에 집중합니다.
    *   **명확한 API 계약**: API의 입출력 데이터 구조가 명확해져 프론트엔드와의 협업 효율이 증대됩니다.

#### **영역 3: 서비스 계층(Service Layer) 세분화**

*   **문제점**: `FacilityProfileService`에 적용된 SRP 원칙이 다른 서비스에는 아직 완전히 적용되지 않았습니다. `ProfileService`는 국내/해외 프로필 로직이 혼재되어 있고, `JobService`는 구인 공고와 지원서 관리 로직이 결합되어 비대해질 가능성이 높습니다.
*   **제안**:
    1.  **`ProfileService` 분리**:
        *   `DomesticProfileService`: 국내 프로필 관련 비즈니스 로직 담당.
        *   `OverseasProfileService`: 해외 프로필 및 외교부 API 연동 로직 담당.
        *   `ProfileQueryService`: 국내/해외 프로필의 복잡한 조회 및 검색 로직 담당.
    2.  **`JobService` 분리**:
        *   `JobPostingService`: 구인 공고의 생성, 수정, 삭제, 상태 관리 등 기업회원 중심의 로직 담당.
        *   `JobApplicationService`: 구직 지원, 이력서 관리, 지원 상태 추적 등 구직자 중심의 로직 담당.
*   **기대 효과**:
    *   **높은 응집도, 낮은 결합도**: 각 서비스가 명확한 책임을 갖게 되어 코드의 응집도가 높아지고 서비스 간 결합도가 낮아집니다.
    *   **테스트 용이성**: 각 서비스를 독립적으로 쉽게 테스트할 수 있습니다.
    *   **유지보수성 향상**: 특정 기능 변경 시 수정해야 할 코드 범위가 명확해집니다.

---

### **[P2] 권장 (Medium) 개선 계획**

#### **영역 4: 엔티티(Entity) 역할 정제**

*   **문제점**: `Job`, `Review` 등 일부 엔티티가 `getSalaryRange()`, `isExpired()`, `getHelpfulPercentage()`와 같이 프레젠테이션이나 복잡한 비즈니스 로직을 포함하고 있습니다.
*   **제안**:
    1.  **프레젠테이션 로직 이동**: `getSalaryRange()`와 같은 데이터 포매팅 로직은 DTO 내부나 별도의 Mapper 클래스로 이동합니다.
    2.  **비즈니스 규칙 이동**: `isExpired()`와 같은 단순 상태 확인 이상의 복잡한 비즈니스 규칙은 서비스 계층으로 이동하여 처리합니다. 엔티티는 단순한 상태 확인 메서드(예: `isActive()`)만 유지합니다.
    3.  엔티티는 데이터와 핵심 상태 변경(예: `close()`, `withdraw()`)에만 집중하도록 역할을 명확히 합니다.
*   **기대 효과**:
    *   **명확한 역할 분리**: 데이터 모델(Entity), 데이터 전송(DTO), 비즈니스 로직(Service) 간의 역할이 명확해집니다.
    *   **데이터베이스 중심 설계 탈피**: 도메인 주도 설계(DDD)에 더 가까운 구조로 발전할 수 있습니다.
    *   **유연성 증가**: 프레젠테이션 방식 변경이 데이터베이스 스키마에 영향을 주지 않습니다.

#### **영역 5: 테스트 전략의 실질적 강화**

*   **문제점**: `CLAUDE_GUIDELINES.md`에 훌륭한 테스트 전략이 정의되어 있으나, `FacilityRecommendationServiceTest.java` 등 일부 테스트 코드가 여전히 Mock 객체에 과도하게 의존하여 실제 상호작용을 검증하지 못하고 있습니다.
*   **제안**:
    1.  `@SpringBootTest`와 `@ActiveProfiles("test")`를 사용한 통합 테스트 비중을 높여 실제 데이터베이스와 상호작용을 검증합니다.
    2.  Mock 객체는 외부 API 호출과 같이 제어가 불가능한 부분에 제한적으로 사용합니다.
    3.  `TestEntityManager` 또는 `@Sql` 어노테이션을 사용하여 각 테스트 시나리오에 맞는 정교한 데이터를 준비하고, 테스트 간 격리를 보장합니다.
    4.  성능 테스트(`@Timeout`)와 비동기 테스트(`awaitility` 라이브러리 활용)를 실제 코드에 적극적으로 적용하여 가이드라인을 실천합니다.
*   **기대 효과**:
    *   **테스트 신뢰도 향상**: 실제 운영 환경과 유사한 조건에서 테스트하여 코드의 신뢰도를 높입니다.
    *   **회귀(Regression) 방지**: 리팩토링이나 기능 추가 시 의도치 않은 버그 발생을 사전에 효과적으로 방지합니다.
    *   **문서화 효과**: 테스트 코드가 시스템의 실제 동작을 보여주는 살아있는 문서 역할을 합니다.

---

### **3. Claude AI 기반 보완 시스템 평가 및 개선 제안**

`claude-guides/` 시스템은 매우 인상적이며, 프로젝트의 품질을 높이려는 높은 수준의 메타 인지를 보여줍니다. 이미 자체적으로 30개 이상의 파일에서 8개로 최적화를 진행한 점은 훌륭합니다. 하지만 더 발전하기 위한 몇 가지 허점과 보완점을 제안합니다.

#### **현재 시스템의 허점 (Flaws)**

1.  **정적 지식 기반**: 핵심 지능이 정적인 `CLAUDE_GUIDELINES.md` 파일 파싱에 의존합니다. 이는 "규칙 기반 전문가 시스템"에 가까우며, 새로운 패턴이나 예외 상황에 대한 학습 능력이 없습니다.
2.  **피상적인 컨텍스트 분석**: `work-type-detector.js`는 파일명과 키워드라는 피상적인 정보에 의존합니다. `ApiServiceTest.java`와 같은 파일은 `api`와 `test` 유형 모두에 해당되어 모호한 분석을 내놓을 수 있습니다.
3.  **수동 피드백 루프**: `solutions-db.md`는 훌륭한 시도이지만, 시스템이 제안한 해결책의 성공 여부를 자동으로 학습하는 피드백 루프가 없습니다.

#### **개선 및 보완 계획**

1.  **지식 베이스의 구조화 (Knowledge Base Structuring)**
    *   `.md` 파일 대신, 각 가이드라인을 구조화된 데이터(JSON, YAML 또는 SQLite)로 변환합니다. 각 규칙에 `id`, `category`, `severity`, `pattern_to_detect`, `good_code_example`, `bad_code_example`, `solution` 등의 필드를 부여하여 기계가 더 쉽게 처리하고 학습할 수 있도록 합니다.

2.  **지능형 컨텍스트 분석 (Intelligent Context Analysis)**
    *   단순 텍스트 매칭을 넘어, **AST(Abstract Syntax Tree) 파서**를 도입하여 코드의 구조 자체를 분석하도록 합니다. 이를 통해 "JPA Repository 메서드에 `@EntityGraph` 어노테이션이 누락되었다"와 같은 훨씬 정교하고 구체적인 문제점을 자동으로 감지할 수 있습니다.

3.  **자동화된 피드백 루프 구축 (Automated Feedback Loop)**
    *   시스템이 제안을 할 때마다 고유 ID를 부여하고, 개발자가 해당 제안을 채택하여 커밋할 때 특정 형식(`fix(guide-123): ...`)을 사용하도록 유도합니다.
    *   CI(Continuous Integration) 파이프라인에서 커밋 메시지를 파싱하고, 해당 커밋으로 인해 빌드나 테스트가 성공했는지 여부를 추적하여 시스템이 "어떤 제안이 성공적인 결과로 이어졌는지"를 **자동으로 학습**하게 합니다.

이러한 개선을 통해 현재의 "지능형 가이드 시스템"을 **"자기 진화형 AI 개발 파트너"**로 발전시킬 수 있습니다.